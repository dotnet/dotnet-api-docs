<Type Name="UIntPtr" FullName="System.UIntPtr">
  <TypeSignature Language="C#" Value="public struct UIntPtr" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit native unsigned int extends System.ValueType" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.UIntPtr" />
  <TypeSignature Language="VB.NET" Value="Public Structure UIntPtr" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type unativeint = struct" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public value class UIntPtr" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public readonly struct UIntPtr : IComparable, IComparable&lt;UIntPtr&gt;, IEquatable&lt;UIntPtr&gt;, IFormattable, System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit native unsigned int extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;native unsigned int&gt;, class System.IEquatable`1&lt;native unsigned int&gt;, class System.IFormattable, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure UIntPtr&#xA;Implements IComparable, IComparable(Of UIntPtr), IEquatable(Of UIntPtr), IFormattable, ISerializable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="F#" Value="type unativeint = struct&#xA;    interface IFormattable&#xA;    interface ISerializable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="C++ CLI" Value="public value class UIntPtr : IComparable, IComparable&lt;UIntPtr&gt;, IEquatable&lt;UIntPtr&gt;, IFormattable, System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="C#" Value="public readonly struct UIntPtr : IComparable, IComparable&lt;UIntPtr&gt;, IEquatable&lt;UIntPtr&gt;, ISpanFormattable, System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit native unsigned int extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;native unsigned int&gt;, class System.IEquatable`1&lt;native unsigned int&gt;, class System.IFormattable, class System.ISpanFormattable, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure UIntPtr&#xA;Implements IComparable, IComparable(Of UIntPtr), IEquatable(Of UIntPtr), ISerializable, ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="F#" Value="type unativeint = struct&#xA;    interface ISpanFormattable&#xA;    interface IFormattable&#xA;    interface ISerializable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="C++ CLI" Value="public value class UIntPtr : IComparable, IComparable&lt;UIntPtr&gt;, IEquatable&lt;UIntPtr&gt;, ISpanFormattable, System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="C#" Value="public readonly struct UIntPtr : IComparable&lt;UIntPtr&gt;, IEquatable&lt;UIntPtr&gt;, IParsable&lt;UIntPtr&gt;, ISpanParsable&lt;UIntPtr&gt;, System.Numerics.IAdditionOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.IAdditiveIdentity&lt;UIntPtr,UIntPtr&gt;, System.Numerics.IBinaryInteger&lt;UIntPtr&gt;, System.Numerics.IBinaryNumber&lt;UIntPtr&gt;, System.Numerics.IBitwiseOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.IComparisonOperators&lt;UIntPtr,UIntPtr,bool&gt;, System.Numerics.IDecrementOperators&lt;UIntPtr&gt;, System.Numerics.IDivisionOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.IEqualityOperators&lt;UIntPtr,UIntPtr,bool&gt;, System.Numerics.IIncrementOperators&lt;UIntPtr&gt;, System.Numerics.IMinMaxValue&lt;UIntPtr&gt;, System.Numerics.IModulusOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.IMultiplicativeIdentity&lt;UIntPtr,UIntPtr&gt;, System.Numerics.IMultiplyOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.INumber&lt;UIntPtr&gt;, System.Numerics.INumberBase&lt;UIntPtr&gt;, System.Numerics.IShiftOperators&lt;UIntPtr,int,UIntPtr&gt;, System.Numerics.ISubtractionOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.IUnaryNegationOperators&lt;UIntPtr,UIntPtr&gt;, System.Numerics.IUnaryPlusOperators&lt;UIntPtr,UIntPtr&gt;, System.Numerics.IUnsignedNumber&lt;UIntPtr&gt;, System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit native unsigned int extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;native unsigned int&gt;, class System.IEquatable`1&lt;native unsigned int&gt;, class System.IFormattable, class System.IParsable`1&lt;native unsigned int&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;native unsigned int&gt;, class System.Numerics.IAdditionOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.IAdditiveIdentity`2&lt;native unsigned int, native unsigned int&gt;, class System.Numerics.IBinaryInteger`1&lt;native unsigned int&gt;, class System.Numerics.IBinaryNumber`1&lt;native unsigned int&gt;, class System.Numerics.IBitwiseOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.IComparisonOperators`3&lt;native unsigned int, native unsigned int, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;native unsigned int&gt;, class System.Numerics.IDivisionOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.IEqualityOperators`3&lt;native unsigned int, native unsigned int, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;native unsigned int&gt;, class System.Numerics.IMinMaxValue`1&lt;native unsigned int&gt;, class System.Numerics.IModulusOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;native unsigned int, native unsigned int&gt;, class System.Numerics.IMultiplyOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.INumber`1&lt;native unsigned int&gt;, class System.Numerics.INumberBase`1&lt;native unsigned int&gt;, class System.Numerics.IShiftOperators`3&lt;native unsigned int, int32, native unsigned int&gt;, class System.Numerics.ISubtractionOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;native unsigned int, native unsigned int&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;native unsigned int, native unsigned int&gt;, class System.Numerics.IUnsignedNumber`1&lt;native unsigned int&gt;, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure UIntPtr&#xA;Implements IAdditionOperators(Of UIntPtr, UIntPtr, UIntPtr), IAdditiveIdentity(Of UIntPtr, UIntPtr), IBinaryInteger(Of UIntPtr), IBinaryNumber(Of UIntPtr), IBitwiseOperators(Of UIntPtr, UIntPtr, UIntPtr), IComparable(Of UIntPtr), IComparisonOperators(Of UIntPtr, UIntPtr, Boolean), IDecrementOperators(Of UIntPtr), IDivisionOperators(Of UIntPtr, UIntPtr, UIntPtr), IEqualityOperators(Of UIntPtr, UIntPtr, Boolean), IEquatable(Of UIntPtr), IIncrementOperators(Of UIntPtr), IMinMaxValue(Of UIntPtr), IModulusOperators(Of UIntPtr, UIntPtr, UIntPtr), IMultiplicativeIdentity(Of UIntPtr, UIntPtr), IMultiplyOperators(Of UIntPtr, UIntPtr, UIntPtr), INumber(Of UIntPtr), INumberBase(Of UIntPtr), IParsable(Of UIntPtr), ISerializable, IShiftOperators(Of UIntPtr, Integer, UIntPtr), ISpanParsable(Of UIntPtr), ISubtractionOperators(Of UIntPtr, UIntPtr, UIntPtr), IUnaryNegationOperators(Of UIntPtr, UIntPtr), IUnaryPlusOperators(Of UIntPtr, UIntPtr), IUnsignedNumber(Of UIntPtr)" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="F#" Value="type unativeint = struct&#xA;    interface IFormattable&#xA;    interface IParsable&lt;unativeint&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;unativeint&gt;&#xA;    interface IAdditionOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IAdditiveIdentity&lt;unativeint, unativeint&gt;&#xA;    interface IBinaryInteger&lt;unativeint&gt;&#xA;    interface IBinaryNumber&lt;unativeint&gt;&#xA;    interface IBitwiseOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IComparisonOperators&lt;unativeint, unativeint, bool&gt;&#xA;    interface IEqualityOperators&lt;unativeint, unativeint, bool&gt;&#xA;    interface IDecrementOperators&lt;unativeint&gt;&#xA;    interface IDivisionOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IIncrementOperators&lt;unativeint&gt;&#xA;    interface IModulusOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IMultiplicativeIdentity&lt;unativeint, unativeint&gt;&#xA;    interface IMultiplyOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface INumber&lt;unativeint&gt;&#xA;    interface INumberBase&lt;unativeint&gt;&#xA;    interface ISubtractionOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IUnaryNegationOperators&lt;unativeint, unativeint&gt;&#xA;    interface IUnaryPlusOperators&lt;unativeint, unativeint&gt;&#xA;    interface IShiftOperators&lt;unativeint, int, unativeint&gt;&#xA;    interface IMinMaxValue&lt;unativeint&gt;&#xA;    interface IUnsignedNumber&lt;unativeint&gt;&#xA;    interface ISerializable" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C++ CLI" Value="public value class UIntPtr : IComparable&lt;UIntPtr&gt;, IEquatable&lt;UIntPtr&gt;, IParsable&lt;UIntPtr&gt;, ISpanParsable&lt;UIntPtr&gt;, System::Numerics::IAdditionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::IAdditiveIdentity&lt;UIntPtr, UIntPtr&gt;, System::Numerics::IBinaryInteger&lt;UIntPtr&gt;, System::Numerics::IBinaryNumber&lt;UIntPtr&gt;, System::Numerics::IBitwiseOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::IComparisonOperators&lt;UIntPtr, UIntPtr, bool&gt;, System::Numerics::IDecrementOperators&lt;UIntPtr&gt;, System::Numerics::IDivisionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::IEqualityOperators&lt;UIntPtr, UIntPtr, bool&gt;, System::Numerics::IIncrementOperators&lt;UIntPtr&gt;, System::Numerics::IMinMaxValue&lt;UIntPtr&gt;, System::Numerics::IModulusOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::IMultiplicativeIdentity&lt;UIntPtr, UIntPtr&gt;, System::Numerics::IMultiplyOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::INumber&lt;UIntPtr&gt;, System::Numerics::INumberBase&lt;UIntPtr&gt;, System::Numerics::IShiftOperators&lt;UIntPtr, int, UIntPtr&gt;, System::Numerics::ISubtractionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::IUnaryNegationOperators&lt;UIntPtr, UIntPtr&gt;, System::Numerics::IUnaryPlusOperators&lt;UIntPtr, UIntPtr&gt;, System::Numerics::IUnsignedNumber&lt;UIntPtr&gt;, System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C#" Value="public readonly struct UIntPtr : IComparable&lt;UIntPtr&gt;, IEquatable&lt;UIntPtr&gt;, IParsable&lt;UIntPtr&gt;, ISpanParsable&lt;UIntPtr&gt;, IUtf8SpanParsable&lt;UIntPtr&gt;, System.Numerics.IAdditionOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.IAdditiveIdentity&lt;UIntPtr,UIntPtr&gt;, System.Numerics.IBinaryInteger&lt;UIntPtr&gt;, System.Numerics.IBinaryNumber&lt;UIntPtr&gt;, System.Numerics.IBitwiseOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.IComparisonOperators&lt;UIntPtr,UIntPtr,bool&gt;, System.Numerics.IDecrementOperators&lt;UIntPtr&gt;, System.Numerics.IDivisionOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.IEqualityOperators&lt;UIntPtr,UIntPtr,bool&gt;, System.Numerics.IIncrementOperators&lt;UIntPtr&gt;, System.Numerics.IMinMaxValue&lt;UIntPtr&gt;, System.Numerics.IModulusOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.IMultiplicativeIdentity&lt;UIntPtr,UIntPtr&gt;, System.Numerics.IMultiplyOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.INumber&lt;UIntPtr&gt;, System.Numerics.INumberBase&lt;UIntPtr&gt;, System.Numerics.IShiftOperators&lt;UIntPtr,int,UIntPtr&gt;, System.Numerics.ISubtractionOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;, System.Numerics.IUnaryNegationOperators&lt;UIntPtr,UIntPtr&gt;, System.Numerics.IUnaryPlusOperators&lt;UIntPtr,UIntPtr&gt;, System.Numerics.IUnsignedNumber&lt;UIntPtr&gt;, System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit native unsigned int extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;native unsigned int&gt;, class System.IEquatable`1&lt;native unsigned int&gt;, class System.IFormattable, class System.IParsable`1&lt;native unsigned int&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;native unsigned int&gt;, class System.IUtf8SpanFormattable, class System.IUtf8SpanParsable`1&lt;native unsigned int&gt;, class System.Numerics.IAdditionOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.IAdditiveIdentity`2&lt;native unsigned int, native unsigned int&gt;, class System.Numerics.IBinaryInteger`1&lt;native unsigned int&gt;, class System.Numerics.IBinaryNumber`1&lt;native unsigned int&gt;, class System.Numerics.IBitwiseOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.IComparisonOperators`3&lt;native unsigned int, native unsigned int, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;native unsigned int&gt;, class System.Numerics.IDivisionOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.IEqualityOperators`3&lt;native unsigned int, native unsigned int, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;native unsigned int&gt;, class System.Numerics.IMinMaxValue`1&lt;native unsigned int&gt;, class System.Numerics.IModulusOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;native unsigned int, native unsigned int&gt;, class System.Numerics.IMultiplyOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.INumber`1&lt;native unsigned int&gt;, class System.Numerics.INumberBase`1&lt;native unsigned int&gt;, class System.Numerics.IShiftOperators`3&lt;native unsigned int, int32, native unsigned int&gt;, class System.Numerics.ISubtractionOperators`3&lt;native unsigned int, native unsigned int, native unsigned int&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;native unsigned int, native unsigned int&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;native unsigned int, native unsigned int&gt;, class System.Numerics.IUnsignedNumber`1&lt;native unsigned int&gt;, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure UIntPtr&#xA;Implements IAdditionOperators(Of UIntPtr, UIntPtr, UIntPtr), IAdditiveIdentity(Of UIntPtr, UIntPtr), IBinaryInteger(Of UIntPtr), IBinaryNumber(Of UIntPtr), IBitwiseOperators(Of UIntPtr, UIntPtr, UIntPtr), IComparable(Of UIntPtr), IComparisonOperators(Of UIntPtr, UIntPtr, Boolean), IDecrementOperators(Of UIntPtr), IDivisionOperators(Of UIntPtr, UIntPtr, UIntPtr), IEqualityOperators(Of UIntPtr, UIntPtr, Boolean), IEquatable(Of UIntPtr), IIncrementOperators(Of UIntPtr), IMinMaxValue(Of UIntPtr), IModulusOperators(Of UIntPtr, UIntPtr, UIntPtr), IMultiplicativeIdentity(Of UIntPtr, UIntPtr), IMultiplyOperators(Of UIntPtr, UIntPtr, UIntPtr), INumber(Of UIntPtr), INumberBase(Of UIntPtr), IParsable(Of UIntPtr), ISerializable, IShiftOperators(Of UIntPtr, Integer, UIntPtr), ISpanParsable(Of UIntPtr), ISubtractionOperators(Of UIntPtr, UIntPtr, UIntPtr), IUnaryNegationOperators(Of UIntPtr, UIntPtr), IUnaryPlusOperators(Of UIntPtr, UIntPtr), IUnsignedNumber(Of UIntPtr), IUtf8SpanParsable(Of UIntPtr)" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type unativeint = struct&#xA;    interface IFormattable&#xA;    interface IParsable&lt;unativeint&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;unativeint&gt;&#xA;    interface IAdditionOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IAdditiveIdentity&lt;unativeint, unativeint&gt;&#xA;    interface IBinaryInteger&lt;unativeint&gt;&#xA;    interface IBinaryNumber&lt;unativeint&gt;&#xA;    interface IBitwiseOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IComparisonOperators&lt;unativeint, unativeint, bool&gt;&#xA;    interface IEqualityOperators&lt;unativeint, unativeint, bool&gt;&#xA;    interface IDecrementOperators&lt;unativeint&gt;&#xA;    interface IDivisionOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IIncrementOperators&lt;unativeint&gt;&#xA;    interface IModulusOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IMultiplicativeIdentity&lt;unativeint, unativeint&gt;&#xA;    interface IMultiplyOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface INumber&lt;unativeint&gt;&#xA;    interface INumberBase&lt;unativeint&gt;&#xA;    interface ISubtractionOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IUnaryNegationOperators&lt;unativeint, unativeint&gt;&#xA;    interface IUnaryPlusOperators&lt;unativeint, unativeint&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;unativeint&gt;&#xA;    interface IShiftOperators&lt;unativeint, int, unativeint&gt;&#xA;    interface IMinMaxValue&lt;unativeint&gt;&#xA;    interface IUnsignedNumber&lt;unativeint&gt;&#xA;    interface ISerializable" FrameworkAlternate="net-8.0" />
  <TypeSignature Language="C++ CLI" Value="public value class UIntPtr : IComparable&lt;UIntPtr&gt;, IEquatable&lt;UIntPtr&gt;, IParsable&lt;UIntPtr&gt;, ISpanParsable&lt;UIntPtr&gt;, IUtf8SpanParsable&lt;UIntPtr&gt;, System::Numerics::IAdditionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::IAdditiveIdentity&lt;UIntPtr, UIntPtr&gt;, System::Numerics::IBinaryInteger&lt;UIntPtr&gt;, System::Numerics::IBinaryNumber&lt;UIntPtr&gt;, System::Numerics::IBitwiseOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::IComparisonOperators&lt;UIntPtr, UIntPtr, bool&gt;, System::Numerics::IDecrementOperators&lt;UIntPtr&gt;, System::Numerics::IDivisionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::IEqualityOperators&lt;UIntPtr, UIntPtr, bool&gt;, System::Numerics::IIncrementOperators&lt;UIntPtr&gt;, System::Numerics::IMinMaxValue&lt;UIntPtr&gt;, System::Numerics::IModulusOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::IMultiplicativeIdentity&lt;UIntPtr, UIntPtr&gt;, System::Numerics::IMultiplyOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::INumber&lt;UIntPtr&gt;, System::Numerics::INumberBase&lt;UIntPtr&gt;, System::Numerics::IShiftOperators&lt;UIntPtr, int, UIntPtr&gt;, System::Numerics::ISubtractionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, System::Numerics::IUnaryNegationOperators&lt;UIntPtr, UIntPtr&gt;, System::Numerics::IUnaryPlusOperators&lt;UIntPtr, UIntPtr&gt;, System::Numerics::IUnsignedNumber&lt;UIntPtr&gt;, System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type unativeint = struct&#xA;    interface IFormattable&#xA;    interface IParsable&lt;unativeint&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;unativeint&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;unativeint&gt;&#xA;    interface IAdditionOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IAdditiveIdentity&lt;unativeint, unativeint&gt;&#xA;    interface IBinaryInteger&lt;unativeint&gt;&#xA;    interface IBinaryNumber&lt;unativeint&gt;&#xA;    interface IBitwiseOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IComparisonOperators&lt;unativeint, unativeint, bool&gt;&#xA;    interface IEqualityOperators&lt;unativeint, unativeint, bool&gt;&#xA;    interface IDecrementOperators&lt;unativeint&gt;&#xA;    interface IDivisionOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IIncrementOperators&lt;unativeint&gt;&#xA;    interface IModulusOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IMultiplicativeIdentity&lt;unativeint, unativeint&gt;&#xA;    interface IMultiplyOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface INumber&lt;unativeint&gt;&#xA;    interface INumberBase&lt;unativeint&gt;&#xA;    interface ISubtractionOperators&lt;unativeint, unativeint, unativeint&gt;&#xA;    interface IUnaryNegationOperators&lt;unativeint, unativeint&gt;&#xA;    interface IUnaryPlusOperators&lt;unativeint, unativeint&gt;&#xA;    interface IShiftOperators&lt;unativeint, int, unativeint&gt;&#xA;    interface IMinMaxValue&lt;unativeint&gt;&#xA;    interface IUnsignedNumber&lt;unativeint&gt;&#xA;    interface ISerializable" FrameworkAlternate="net-9.0" />
  <TypeSignature Language="C#" Value="public struct UIntPtr : IEquatable&lt;UIntPtr&gt;, System.Runtime.Serialization.ISerializable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit native unsigned int extends System.ValueType implements class System.IEquatable`1&lt;native unsigned int&gt;, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure UIntPtr&#xA;Implements IEquatable(Of UIntPtr), ISerializable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type unativeint = struct&#xA;    interface ISerializable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C++ CLI" Value="public value class UIntPtr : IEquatable&lt;UIntPtr&gt;, System::Runtime::Serialization::ISerializable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public readonly struct UIntPtr : IEquatable&lt;UIntPtr&gt;, System.Runtime.Serialization.ISerializable" FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public struct UIntPtr : System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-2.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit native unsigned int extends System.ValueType implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure UIntPtr&#xA;Implements ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-2.0" />
  <TypeSignature Language="C++ CLI" Value="public value class UIntPtr : System::Runtime::Serialization::ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-2.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit native unsigned int extends System.ValueType implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netstandard-2.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="6.0.0.0" FrameworkAlternate="net-6.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="7.0.0.0" FrameworkAlternate="net-7.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="8.0.0.0" FrameworkAlternate="net-8.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="9.0.0.0" FrameworkAlternate="net-9.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IComparable&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
      <InterfaceName>System.IEquatable&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-2.0;netstandard-2.1">
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IComparable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IEquatable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IParsable&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanParsable&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;System.UIntPtr,System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryInteger&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryNumber&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryNumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IComparisonOperators&lt;System.UIntPtr,System.UIntPtr,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IComparisonOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;System.UIntPtr,System.UIntPtr,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TOther,TResult&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMinMaxValue&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IModulusOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;System.UIntPtr,System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumber&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumberBase&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumberBase&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IShiftOperators&lt;System.UIntPtr,System.Int32,System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IShiftOperators&lt;TSelf,System.Int32,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;System.UIntPtr,System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;System.UIntPtr,System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnsignedNumber&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;System.UIntPtr&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1;netstandard-2.1">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents an unsigned integer where the bit-width is the same as a pointer.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

 The <xref:System.UIntPtr> type is designed to be an integer whose size is the same as a pointer. That is, an instance of this type is expected to be 32-bits in a 32-bit process and 64-bits in a 64-bit process.

 The <xref:System.UIntPtr> type can be used by languages that support pointers, and as a common means of referring to data between languages that do and do not support pointers. <xref:System.UIntPtr> objects can also be used to hold handles.

 > [!NOTE]
 > Using <xref:System.UIntPtr> as a pointer or a handle is error prone and unsafe. It is simply an integer type that can be used as an interchange format for pointers and handles due to being the same size. Outside of specific interchange requirements, such as for passing data to a language that doesn't support pointers, a correctly typed pointer should be used to represent pointers and <xref:System.Runtime.InteropServices.SafeHandle> should be used to represent handles.

 This type implements the <xref:System.Runtime.Serialization.ISerializable>. In .NET 5 and later versions, this type also implements the <xref:System.IFormattable> interfaces. In .NET 7 and later versions, this type also implements the <xref:System.Numerics.IBinaryInteger%601>, <xref:System.Numerics.IMinMaxValue%601>, and <xref:System.Numerics.IUnsignedNumber%601> interfaces.

 In C# starting from version 9.0, you can use the built-in `nuint` type to define native-sized integers. This type is represented by the <xref:System.UIntPtr> type internally and provides operations and conversions that are appropriate for integer types. For more information, see [nint and nuint types](/dotnet/csharp/language-reference/builtin-types/nint-nuint).

 In C# starting from version 11 and when targeting the .NET 7 or later runtime, `nuint` is an alias for <xref:System.UIntPtr> in the same way that `uint` is an alias for <xref:System.UInt32>.

 ]]></format>
    </remarks>
    <threadsafe>This type is thread safe.</threadsafe>
    <altmember cref="T:System.IntPtr" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of <see cref="T:System.UIntPtr" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIntPtr (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="F#" Value="new unativeint : uint32 -&gt; unativeint" Usage="new System.unativeint value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UIntPtr(System::UInt32 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">A 32-bit unsigned integer.</param>
        <summary>Initializes a new instance of the <see cref="T:System.UIntPtr" /> structure using the specified 32-bit unsigned integer.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIntPtr (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="F#" Value="new unativeint : uint64 -&gt; unativeint" Usage="new System.unativeint value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UIntPtr(System::UInt64 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">A 64-bit unsigned integer.</param>
        <summary>Initializes a new instance of <see cref="T:System.UIntPtr" /> using the specified 64-bit unsigned integer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 An exception is only thrown if the value of `value` requires more bits than the executing process supports.

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">In a 32-bit process, <paramref name="value" /> is too large to represent as an <see cref="T:System.UIntPtr" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.#ctor(System.Void*)" />
      <MemberSignature Language="F#" Value="new unativeint : nativeptr&lt;unit&gt; -&gt; unativeint" Usage="new System.unativeint value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UIntPtr(void* value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value">A pointer to an unspecified type.</param>
        <summary>Initializes a new instance of <see cref="T:System.UIntPtr" /> using the specified pointer to an unspecified type.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Void" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static UIntPtr Add (UIntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Add(native unsigned int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Add(System.UIntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (pointer As UIntPtr, offset As Integer) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Add : unativeint * int -&gt; unativeint" Usage="System.unativeint.Add (pointer, offset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Add(UIntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.UIntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="pointer">The unsigned integer to add the offset to.</param>
        <param name="offset">The offset to add.</param>
        <summary>Adds an offset to an unsigned integer.</summary>
        <returns>A new unsigned integer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.UIntPtr.Add%2A> method does not throw an exception if the result is too large to represent as an unsigned integer in the executing process. Instead, the addition operation is performed in an unchecked context.

 Languages that do not support operator overloading or custom operators can use this method to add an offset to the value of a pointer.

## Examples
 The following example instantiates a <xref:System.UIntPtr> object that points to the beginning of a ten-element array, and then calls the <xref:System.UIntPtr.Add%2A> method to iterate the elements in the array.

 :::code language="csharp" source="~/snippets/csharp/System/UIntPtr/Add/add1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System/UIntPtr/Add/add1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.uintptr.add/vb/add1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.UIntPtr.op_Addition(System.UIntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static UIntPtr Clamp (UIntPtr value, UIntPtr min, UIntPtr max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Clamp(native unsigned int value, native unsigned int min, native unsigned int max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Clamp(System.UIntPtr,System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UIntPtr, min As UIntPtr, max As UIntPtr) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Clamp : unativeint * unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Clamp(UIntPtr value, UIntPtr min, UIntPtr max) = System::Numerics::INumber&lt;UIntPtr&gt;::Clamp;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Clamp(`0,`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="min" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="max" Type="System.UIntPtr" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to clamp.</param>
        <param name="min">The inclusive minimum to which <paramref name="value" /> should clamp.</param>
        <param name="max">The inclusive maximum to which <paramref name="value" /> should clamp.</param>
        <summary>Clamps a value to an inclusive minimum and maximum value.</summary>
        <returns>The result of clamping <paramref name="value" /> to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Clamp(`0,`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object? value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="unativeint.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">An object to compare, or <see langword="null" />.</param>
        <summary>Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
        <returns>A value that indicates the relative order of the objects being compared. The return value has these meanings:
 <list type="table"><listheader><term> Value
 </term><description> Meaning
 </description></listheader><item><term> Less than zero
 </term><description> This instance precedes <paramref name="value" /> in the sort order.
 </description></item><item><term> Zero
 </term><description> This instance occurs in the same position in the sort order as <paramref name="value" />.
 </description></item><item><term> Greater than zero
 </term><description> This instance follows <paramref name="value" /> in the sort order.
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.CompareTo(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As UIntPtr) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : unativeint -&gt; int&#xA;override this.CompareTo : unativeint -&gt; int" Usage="unativeint.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(UIntPtr value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">An unsigned native integer to compare.</param>
        <summary>Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
        <returns>A value that indicates the relative order of the objects being compared. The return value has these meanings:
 <list type="table"><listheader><term> Value
 </term><description> Meaning
 </description></listheader><item><term> Less than zero
 </term><description> This instance precedes <paramref name="value" /> in the sort order.
 </description></item><item><term> Zero
 </term><description> This instance occurs in the same position in the sort order as <paramref name="value" />.
 </description></item><item><term> Greater than zero
 </term><description> This instance follows <paramref name="value" /> in the sort order.
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static UIntPtr CreateChecked&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int CreateChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.CreateChecked``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateChecked(Of TOther As INumberBase(Of TOther)) (value As TOther) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member CreateChecked : 'Other -&gt; unativeint (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.unativeint.CreateChecked value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static UIntPtr CreateChecked(TOther value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::CreateChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateChecked``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <code data-dev-comment-type="typeparamref">TSelf</code>.</param>
        <summary>Creates an instance of the current type from a value, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateChecked``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static UIntPtr CreateSaturating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int CreateSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.CreateSaturating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member CreateSaturating : 'Other -&gt; unativeint (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.unativeint.CreateSaturating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static UIntPtr CreateSaturating(TOther value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::CreateSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <code data-dev-comment-type="typeparamref">TSelf</code>.</param>
        <summary>Creates an instance of the current type from a value, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, saturating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static UIntPtr CreateTruncating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int CreateTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.CreateTruncating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member CreateTruncating : 'Other -&gt; unativeint (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.unativeint.CreateTruncating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static UIntPtr CreateTruncating(TOther value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::CreateTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <code data-dev-comment-type="typeparamref">TSelf</code>.</param>
        <summary>Creates an instance of the current type from a value, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, truncating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (UIntPtr Quotient, UIntPtr Remainder) DivRem (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;native unsigned int, native unsigned int&gt; DivRem(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.DivRem(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As UIntPtr, right As UIntPtr) As ValueTuple(Of UIntPtr, UIntPtr)" />
      <MemberSignature Language="F#" Value="static member DivRem : unativeint * unativeint -&gt; ValueTuple&lt;unativeint, unativeint&gt;" Usage="System.unativeint.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;UIntPtr, UIntPtr&gt; DivRem(UIntPtr left, UIntPtr right) = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::DivRem;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.DivRem(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.UIntPtr,System.UIntPtr&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-7.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value which <paramref name="right" /> divides.</param>
        <param name="right">The value which divides <paramref name="left" />.</param>
        <summary>Computes the quotient and remainder of two values.</summary>
        <returns>The quotient and remainder of <paramref name="left" /> divided-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.DivRem(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="unativeint.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="C#" Value="public override bool Equals (object? obj);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="obj">An object to compare with this instance or <see langword="null" />.</param>
        <summary>Returns a value indicating whether this instance is equal to a specified object.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> is an instance of <see cref="T:System.UIntPtr" /> and equals the value of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (UIntPtr other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(native unsigned int other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Equals(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : unativeint -&gt; bool" Usage="unativeint.Equals other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(UIntPtr other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="other">An object to compare with this object.</param>
        <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        <returns>
          <see langword="true" /> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="unativeint.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this instance.</summary>
        <returns>A 32-bit signed integer hash code.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvenInteger">
      <MemberSignature Language="C#" Value="public static bool IsEvenInteger (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEvenInteger(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.IsEvenInteger(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEvenInteger (value As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsEvenInteger : unativeint -&gt; bool" Usage="System.unativeint.IsEvenInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEvenInteger(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsEvenInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsEvenInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an even integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an even integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `2.0` will return `true` while `2.2` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsOddInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsEvenInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsOddInteger">
      <MemberSignature Language="C#" Value="public static bool IsOddInteger (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOddInteger(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.IsOddInteger(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOddInteger (value As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsOddInteger : unativeint -&gt; bool" Usage="System.unativeint.IsOddInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOddInteger(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsOddInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsOddInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an odd integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an odd integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `3.0` will return `true` while `3.3` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsEvenInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsOddInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsPow2">
      <MemberSignature Language="C#" Value="public static bool IsPow2 (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPow2(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.IsPow2(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPow2 (value As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPow2 : unativeint -&gt; bool" Usage="System.unativeint.IsPow2 value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPow2(UIntPtr value) = System::Numerics::IBinaryNumber&lt;UIntPtr&gt;::IsPow2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.IsPow2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is a power of two.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a power of two; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryNumber`1.IsPow2(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount">
      <MemberSignature Language="C#" Value="public static UIntPtr LeadingZeroCount (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int LeadingZeroCount(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.LeadingZeroCount(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeadingZeroCount (value As UIntPtr) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : unativeint -&gt; unativeint" Usage="System.unativeint.LeadingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr LeadingZeroCount(UIntPtr value) = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::LeadingZeroCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.LeadingZeroCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose leading zeroes are to be counted.</param>
        <summary>Computes the number of leading zeros in a value.</summary>
        <returns>The number of leading zeros in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.LeadingZeroCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static UIntPtr Log2 (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Log2(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Log2(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (value As UIntPtr) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Log2 : unativeint -&gt; unativeint" Usage="System.unativeint.Log2 value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Log2(UIntPtr value) = System::Numerics::IBinaryNumber&lt;UIntPtr&gt;::Log2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.Log2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose log2 is to be computed.</param>
        <summary>Computes the log2 of a value.</summary>
        <returns>The log2 of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryNumber`1.Log2(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static UIntPtr Max (UIntPtr x, UIntPtr y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Max(native unsigned int x, native unsigned int y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Max(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As UIntPtr, y As UIntPtr) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Max : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.Max (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Max(UIntPtr x, UIntPtr y) = System::Numerics::INumber&lt;UIntPtr&gt;::Max;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Max(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `maximum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Max(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public static UIntPtr MaxValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property native unsigned int MaxValue" />
      <MemberSignature Language="DocId" Value="P:System.UIntPtr.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxValue As UIntPtr" />
      <MemberSignature Language="F#" Value="static member MaxValue : unativeint" Usage="System.unativeint.MaxValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property UIntPtr MaxValue { UIntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">P:System.Numerics.IMinMaxValue`1.MaxValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the largest possible value of <see cref="T:System.UIntPtr" />.</summary>
        <value>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.IMinMaxValue`1.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static UIntPtr Min (UIntPtr x, UIntPtr y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Min(native unsigned int x, native unsigned int y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Min(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As UIntPtr, y As UIntPtr) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Min : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.Min (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Min(UIntPtr x, UIntPtr y) = System::Numerics::INumber&lt;UIntPtr&gt;::Min;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Min(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `minimum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Min(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public static UIntPtr MinValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property native unsigned int MinValue" />
      <MemberSignature Language="DocId" Value="P:System.UIntPtr.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinValue As UIntPtr" />
      <MemberSignature Language="F#" Value="static member MinValue : unativeint" Usage="System.unativeint.MinValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property UIntPtr MinValue { UIntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">P:System.Numerics.IMinMaxValue`1.MinValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the smallest possible value of <see cref="T:System.UIntPtr" />.</summary>
        <value>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.IMinMaxValue`1.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static UIntPtr operator + (UIntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native unsigned int op_Addition(native unsigned int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.op_Addition(System.UIntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (pointer As UIntPtr, offset As Integer) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member ( + ) : unativeint * int -&gt; unativeint" Usage="pointer + offset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr operator +(UIntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.UIntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="pointer">The unsigned integer to add the offset to.</param>
        <param name="offset">The offset to add.</param>
        <summary>Adds an offset to an unsigned integer.</summary>
        <returns>A new unsigned integer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.UIntPtr.op_Addition%2A> method defines the addition operation for <xref:System.UIntPtr> objects. It enables code such as the following.

 :::code language="csharp" source="~/snippets/csharp/System/UIntPtr/op_Addition/op_addition1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System/UIntPtr/op_Addition/op_addition1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.uintptr.op_addition/vb/op_addition1.vb" id="Snippet1":::

 Languages that do not support custom operators can call the <xref:System.UIntPtr.Add%2A> method instead.

 The addition operation does not throw an exception if the result is too large to represent as an unsigned integer in the executing process. Instead, it is performed in an unchecked context.

 In C# starting from version 11 and when targeting the .NET 7 or later runtime, this API is only accessible via reflection. The addition operator is directly recognized by the language and will follow the normal language behavior for addition operations, including overflowing in a `checked` context if the result is too large to represent.

 The equivalent method for this operator is <xref:System.UIntPtr.Add%28System.UIntPtr%2CSystem.Int32%29?displayProperty=nameWithType>. ]]></format>
        </remarks>
        <altmember cref="M:System.UIntPtr.Add(System.UIntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (UIntPtr value1, UIntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(native unsigned int value1, native unsigned int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.op_Equality(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (value1 As UIntPtr, value2 As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( = ) : unativeint * unativeint -&gt; bool" Usage="value1 = value2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(UIntPtr value1, UIntPtr value2);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(UIntPtr value1, UIntPtr value2) = System::Numerics::IEqualityOperators&lt;UIntPtr, UIntPtr, bool&gt;::op_Equality;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.UIntPtr" />
        <Parameter Name="value2" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="value1">The first unsigned integer to compare.</param>
        <param name="value2">The second unsigned integer to compare.</param>
        <summary>Determines whether two specified instances of <see cref="T:System.UIntPtr" /> are equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value1" /> equals <paramref name="value2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[The equivalent method for this operator is <xref:System.UIntPtr.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UIntPtr (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native unsigned int op_Explicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.op_Explicit(System.UInt32)~System.UIntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInteger) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member op_Explicit : uint32 -&gt; unativeint" Usage="System.unativeint.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UIntPtr(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">A 32-bit unsigned integer. </param>
        <summary>Converts the value of a 32-bit unsigned integer to an <see cref="T:System.UIntPtr" />.</summary>
        <returns>A new instance of <see cref="T:System.UIntPtr" /> initialized to <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.UIntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UIntPtr (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native unsigned int op_Explicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.op_Explicit(System.UInt64)~System.UIntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As ULong) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member op_Explicit : uint64 -&gt; unativeint" Usage="System.unativeint.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UIntPtr(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">A 64-bit unsigned integer.</param>
        <summary>Converts the value of a 64-bit unsigned integer to an <see cref="T:System.UIntPtr" />.</summary>
        <returns>A new instance of <see cref="T:System.UIntPtr" /> initialized to <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">In a 32-bit process, <paramref name="value" /> is too large to represent as an <see cref="T:System.UIntPtr" />.</exception>
        <altmember cref="Overload:System.UIntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.op_Explicit(System.UIntPtr)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UIntPtr) As UInteger" />
      <MemberSignature Language="F#" Value="static member op_Explicit : unativeint -&gt; uint32" Usage="System.unativeint.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(UIntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="value">The unsigned integer to convert.</param>
        <summary>Converts the value of the specified <see cref="T:System.UIntPtr" /> to a 32-bit unsigned integer.</summary>
        <returns>The contents of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 An exception is only thrown if the value of `value` requires more bits than the executing process supports.
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">In a 64-bit process, the value of <paramref name="value" /> is too large to represent as a 32-bit unsigned integer.</exception>
        <altmember cref="M:System.UIntPtr.ToUInt32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.op_Explicit(System.UIntPtr)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UIntPtr) As ULong" />
      <MemberSignature Language="F#" Value="static member op_Explicit : unativeint -&gt; uint64" Usage="System.unativeint.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(UIntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="value">The unsigned integer to convert.</param>
        <summary>Converts the value of the specified <see cref="T:System.UIntPtr" /> to a 64-bit unsigned integer.</summary>
        <returns>The contents of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.UIntPtr.ToUInt64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator void* (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname void* op_Explicit(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.op_Explicit(System.UIntPtr)~System.Void*" />
      <MemberSignature Language="F#" Value="static member op_Explicit : unativeint -&gt; nativeptr&lt;unit&gt;" Usage="System.unativeint.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator void*(UIntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="value">The unsigned integer to convert.</param>
        <summary>Converts the value of the specified <see cref="T:System.UIntPtr" /> to a pointer to an unspecified type.

 This API is not CLS-compliant.</summary>
        <returns>The contents of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.UIntPtr.ToPointer" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UIntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native unsigned int op_Explicit(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.op_Explicit(System.Void*)~System.UIntPtr" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeptr&lt;unit&gt; -&gt; unativeint" Usage="System.unativeint.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UIntPtr(void* value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value">A pointer to an unspecified type.</param>
        <summary>Converts the specified pointer to an unspecified type to an <see cref="T:System.UIntPtr" />.

 This API is not CLS-compliant.</summary>
        <returns>A new instance of <see cref="T:System.UIntPtr" /> initialized to <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.UIntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (UIntPtr value1, UIntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(native unsigned int value1, native unsigned int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.op_Inequality(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (value1 As UIntPtr, value2 As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member op_Inequality : unativeint * unativeint -&gt; bool" Usage="System.unativeint.op_Inequality (value1, value2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(UIntPtr value1, UIntPtr value2);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(UIntPtr value1, UIntPtr value2) = System::Numerics::IEqualityOperators&lt;UIntPtr, UIntPtr, bool&gt;::op_Inequality;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.UIntPtr" />
        <Parameter Name="value2" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="value1">The first unsigned integer to compare.</param>
        <param name="value2">The second unsigned integer to compare.</param>
        <summary>Determines whether two specified instances of <see cref="T:System.UIntPtr" /> are not equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value1" /> does not equal <paramref name="value2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[The equivalent method for this operator is <xref:System.UIntPtr.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static UIntPtr operator - (UIntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native unsigned int op_Subtraction(native unsigned int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.op_Subtraction(System.UIntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (pointer As UIntPtr, offset As Integer) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member ( - ) : unativeint * int -&gt; unativeint" Usage="pointer - offset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr operator -(UIntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.UIntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="pointer">The unsigned integer to subtract the offset from.</param>
        <param name="offset">The offset to subtract.</param>
        <summary>Subtracts an offset from an unsigned integer.</summary>
        <returns>A new unsigned integer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.UIntPtr.op_Subtraction%2A> method defines the subtraction operation for <xref:System.UIntPtr> objects. It enables code such as the following.

 :::code language="csharp" source="~/snippets/csharp/System/UIntPtr/op_Addition/op_subtraction1.cs" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/System/UIntPtr/op_Addition/op_subtraction1.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.uintptr.op_addition/vb/op_subtraction1.vb" id="Snippet2":::

 Languages that do not support custom operators can call the <xref:System.UIntPtr.Subtract%2A> method instead.

 The subtraction operation does not throw an exception if the result is too small to represent as an unsigned integer in the executing process. Instead, it is performed in an unchecked context.

 In C# starting from version 11 and when targeting the .NET 7 or later runtime, this API is only accessible via reflection. The subtraction operator is directly recognized by the language and will follow the normal language behavior for subtraction operations, including overflowing in a `checked` context if the result is too small to represent.

 ]]></format>
        </remarks>
        <altmember cref="M:System.UIntPtr.Subtract(System.UIntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UIntPtr Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; unativeint" Usage="System.unativeint.Parse s" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert.</param>
        <summary>Converts the string representation of a number to its unsigned native integer equivalent.</summary>
        <returns>An unsigned native integer equivalent to the number contained in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="P:System.UIntPtr.MinValue" /> or greater than <see cref="P:System.UIntPtr.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UIntPtr Parse (ReadOnlySpan&lt;byte&gt; utf8Text, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Parse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (utf8Text As ReadOnlySpan(Of Byte), provider As IFormatProvider) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;byte&gt; * IFormatProvider -&gt; unativeint" Usage="System.unativeint.Parse (utf8Text, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Parse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, IFormatProvider ^ provider) = IUtf8SpanParsable&lt;UIntPtr&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IUtf8SpanParsable`1.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanParsable`1.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UIntPtr Parse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), provider As IFormatProvider) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; unativeint" Usage="System.unativeint.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider) = ISpanParsable&lt;UIntPtr&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UIntPtr Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; unativeint" Usage="System.unativeint.Parse (s, style)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert.</param>
        <param name="style">A bitwise combination of the enumeration values that indicates the style elements that can be present in <paramref name="s" />.</param>
        <summary>Converts the string representation of a number in a specified style to its unsigned native integer equivalent.</summary>
        <returns>An unsigned native integer equivalent to the number contained in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value or <paramref name="style" /> is not a combination of <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="F:System.Globalization.NumberStyles.HexNumber" /> values.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="P:System.UIntPtr.MinValue" /> or greater than <see cref="P:System.UIntPtr.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UIntPtr Parse (string s, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; unativeint" Usage="System.unativeint.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Parse(System::String ^ s, IFormatProvider ^ provider);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Parse(System::String ^ s, IFormatProvider ^ provider) = IParsable&lt;UIntPtr&gt;::Parse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.IParsable`1.Parse(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Converts the string representation of a number in a specified culture-specific format to its unsigned native integer equivalent.</summary>
        <returns>An unsigned native integer equivalent to the number contained in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="P:System.UIntPtr.MinValue" /> or greater than <see cref="P:System.UIntPtr.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UIntPtr Parse (ReadOnlySpan&lt;byte&gt; utf8Text, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Parse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (utf8Text As ReadOnlySpan(Of Byte), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = Nothing) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;byte&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; unativeint" Usage="System.unativeint.Parse (utf8Text, style, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UIntPtr Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = Nothing) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; unativeint" Usage="System.unativeint.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">A read-only span of characters containing a number to convert.</param>
        <param name="style">An optional bitwise combination of the enumeration values that indicates the style elements that can be present in <paramref name="s" />. The default value is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">An optional object that supplies culture-specific formatting information about <paramref name="s" />. The default value is <see langword="default" />.</param>
        <summary>Converts the read-only span of characters representation of a number in optionally specified style and optionally specified culture-specific format to its unsigned native integer equivalent.</summary>
        <returns>An unsigned native integer equivalent to the number contained in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value or <paramref name="style" /> is not a combination of <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="F:System.Globalization.NumberStyles.HexNumber" /> values.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="P:System.UIntPtr.MinValue" /> or greater than <see cref="P:System.UIntPtr.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UIntPtr Parse (string s, System.Globalization.NumberStyles style, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; unativeint" Usage="System.unativeint.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider) = System::Numerics::INumberBase&lt;UIntPtr&gt;::Parse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.INumberBase`1.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert.</param>
        <param name="style">A bitwise combination of the enumeration values that indicates the style elements that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Converts the string representation of a number in a specified style and culture-specific format to its unsigned native integer equivalent.</summary>
        <returns>An unsigned native integer equivalent to the number contained in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value or <paramref name="style" /> is not a combination of <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="F:System.Globalization.NumberStyles.HexNumber" /> values.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="P:System.UIntPtr.MinValue" /> or greater than <see cref="P:System.UIntPtr.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PopCount">
      <MemberSignature Language="C#" Value="public static UIntPtr PopCount (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int PopCount(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.PopCount(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PopCount (value As UIntPtr) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member PopCount : unativeint -&gt; unativeint" Usage="System.unativeint.PopCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr PopCount(UIntPtr value) = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::PopCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.PopCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose set bits are to be counted.</param>
        <summary>Computes the number of bits that are set in a value.</summary>
        <returns>The number of set bits in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.PopCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="RotateLeft">
      <MemberSignature Language="C#" Value="public static UIntPtr RotateLeft (UIntPtr value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int RotateLeft(native unsigned int value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.RotateLeft(System.UIntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RotateLeft (value As UIntPtr, rotateAmount As Integer) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member RotateLeft : unativeint * int -&gt; unativeint" Usage="System.unativeint.RotateLeft (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr RotateLeft(UIntPtr value, int rotateAmount) = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::RotateLeft;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.RotateLeft(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value which is rotated left by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated left.</param>
        <summary>Rotates a value left by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> left by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.RotateLeft(`0,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RotateRight">
      <MemberSignature Language="C#" Value="public static UIntPtr RotateRight (UIntPtr value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int RotateRight(native unsigned int value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.RotateRight(System.UIntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RotateRight (value As UIntPtr, rotateAmount As Integer) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member RotateRight : unativeint * int -&gt; unativeint" Usage="System.unativeint.RotateRight (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr RotateRight(UIntPtr value, int rotateAmount) = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::RotateRight;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.RotateRight(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value which is rotated right by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated right.</param>
        <summary>Rotates a value right by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> right by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.RotateRight(`0,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Sign(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As UIntPtr) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : unativeint -&gt; int" Usage="System.unativeint.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(UIntPtr value) = System::Numerics::INumber&lt;UIntPtr&gt;::Sign;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Sign(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose sign is to be computed.</param>
        <summary>Computes the sign of a value.</summary>
        <returns>A positive value if <paramref name="value" /> is positive, <see cref="P:System.Numerics.INumberBase`1.Zero" /> if <paramref name="value" /> is zero, and a negative value if <paramref name="value" /> is negative.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

It is recommended that a function return `1`, `0`, and `-1`, respectively.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Sign(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public static int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.UIntPtr.Size" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Size As Integer" />
      <MemberSignature Language="F#" Value="static member Size : int" Usage="System.unativeint.Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int Size { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size of this instance.</summary>
        <value>The size of an unsigned integer in the executing process, measured in bytes. The value of this property is 4 in a 32-bit process, and 8 in a 64-bit process. You can define the process type by setting the <see langword="/platform" /> switch when you compile your code with the C# and Visual Basic compilers.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static UIntPtr Subtract (UIntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Subtract(native unsigned int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.Subtract(System.UIntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (pointer As UIntPtr, offset As Integer) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Subtract : unativeint * int -&gt; unativeint" Usage="System.unativeint.Subtract (pointer, offset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Subtract(UIntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.UIntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="pointer">The unsigned integer to subtract the offset from.</param>
        <param name="offset">The offset to subtract.</param>
        <summary>Subtracts an offset from an unsigned integer.</summary>
        <returns>A new unsigned integer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.IntPtr.Subtract%2A> method does not throw an exception if the result is too small to represent as an unsigned integer in the executing process. Instead, the subtraction operation is performed in an unchecked context.

 Languages that do not support operator overloading or custom operators can use this method to subtract an offset from the value of a pointer.

## Examples
 The following example instantiates an <xref:System.IntPtr> object that points to the end of a ten-element array, and then calls the <xref:System.IntPtr.Subtract%2A> method to iterate the elements in the array in reverse order.

 :::code language="csharp" source="~/snippets/csharp/System/UIntPtr/Subtract/subtract1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System/UIntPtr/Subtract/subtract1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.uintptr.subtract/vb/subtract1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.UIntPtr.op_Subtraction(System.UIntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.IEquatable&lt;System.UIntPtr&gt;.Equals">
      <MemberSignature Language="C#" Value="bool IEquatable&lt;UIntPtr&gt;.Equals (UIntPtr other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IEquatable&lt;System.UIntPtr&gt;.Equals(native unsigned int other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#IEquatable&lt;System#UIntPtr&gt;#Equals(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As UIntPtr) As Boolean Implements IEquatable(Of UIntPtr).Equals" />
      <MemberSignature Language="F#" Value="abstract member System.IEquatable&lt;System.UIntPtr&gt;.Equals : unativeint -&gt; bool&#xA;override this.System.IEquatable&lt;System.UIntPtr&gt;.Equals : unativeint -&gt; bool" Usage="unativeint.System.IEquatable&lt;System.UIntPtr&gt;.Equals other" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IEquatable&lt;System.UIntPtr&gt;.Equals(UIntPtr other) = IEquatable&lt;UIntPtr&gt;::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UIntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="other">An unsigned integer to compare with this instance.</param>
        <summary>Returns a value that indicates whether this instance is equal to another unsigned integer.</summary>
        <returns>
          <see langword="true" /> if <paramref name="other" /> equals the value of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This member is an explicit interface member implementation. It can be used only when the <xref:System.UIntPtr> instance is cast to an <xref:System.IEquatable%601> interface.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditionOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_Addition" ExplicitInterfaceMemberName="System.Numerics.IAdditionOperators&lt;nuint,nuint,nuint&gt;.op_Addition">
      <MemberSignature Language="C#" Value="static UIntPtr IAdditionOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.operator + (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IAdditionOperators&lt;nuint,nuint,nuint&gt;.op_Addition(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IAdditionOperators&lt;nuint,nuint,nuint&gt;#op_Addition(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator + (left As UIntPtr, right As UIntPtr) As UIntPtr Implements IAdditionOperators(Of UIntPtr, UIntPtr, UIntPtr).op_Addition" />
      <MemberSignature Language="F#" Value="static member ( + ) : unativeint * unativeint -&gt; unativeint" Usage="left + right" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IAdditionOperators&lt;nuint,nuint,nuint&gt;.operator +(UIntPtr left, UIntPtr right) = System::Numerics::IAdditionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_Addition;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IAdditionOperators`3.op_Addition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to which <paramref name="right" /> is added.</param>
        <param name="right">The value that's added to <paramref name="left" />.</param>
        <summary>Adds two values together to compute their sum.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditionOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_CheckedAddition" ExplicitInterfaceMemberName="System.Numerics.IAdditionOperators&lt;nuint,nuint,nuint&gt;.op_CheckedAddition">
      <MemberSignature Language="C#" Value="static UIntPtr IAdditionOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.op_CheckedAddition (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IAdditionOperators&lt;nuint,nuint,nuint&gt;.op_CheckedAddition(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IAdditionOperators&lt;nuint,nuint,nuint&gt;#op_CheckedAddition(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedAddition (left As UIntPtr, right As UIntPtr) As UIntPtr Implements IAdditionOperators(Of UIntPtr, UIntPtr, UIntPtr).op_CheckedAddition" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IAdditionOperators&lt;nuint,nuint,nuint&gt;.op_CheckedAddition : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.IAdditionOperators&lt;nuint,nuint,nuint&gt;.op_CheckedAddition (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IAdditionOperators&lt;nuint,nuint,nuint&gt;.op_CheckedAddition(UIntPtr left, UIntPtr right) = System::Numerics::IAdditionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_CheckedAddition;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IAdditionOperators`3.op_CheckedAddition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to which <paramref name="right" /> is added.</param>
        <param name="right">The value that's added to <paramref name="left" />.</param>
        <summary>Adds two values together to compute their sum.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditiveIdentity&lt;System.UIntPtr,System.UIntPtr&gt;.AdditiveIdentity" ExplicitInterfaceMemberName="System.Numerics.IAdditiveIdentity&lt;nuint,nuint&gt;.AdditiveIdentity">
      <MemberSignature Language="C#" Value="static UIntPtr System.Numerics.IAdditiveIdentity&lt;System.UIntPtr,System.UIntPtr&gt;.AdditiveIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property native unsigned int System.Numerics.IAdditiveIdentity&lt;nuint,nuint&gt;.AdditiveIdentity" />
      <MemberSignature Language="DocId" Value="P:System.UIntPtr.System#Numerics#IAdditiveIdentity&lt;nuint,nuint&gt;#AdditiveIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property AdditiveIdentity As UIntPtr Implements IAdditiveIdentity(Of UIntPtr, UIntPtr).AdditiveIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IAdditiveIdentity&lt;System.UIntPtr,System.UIntPtr&gt;.AdditiveIdentity : unativeint" Usage="System.Numerics.IAdditiveIdentity&lt;System.UIntPtr,System.UIntPtr&gt;.AdditiveIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property UIntPtr System::Numerics::IAdditiveIdentity&lt;System::UIntPtr,System::UIntPtr&gt;::AdditiveIdentity { UIntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IAdditiveIdentity`2.AdditiveIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the additive identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UIntPtr&gt;.GetByteCount" ExplicitInterfaceMemberName="System.Numerics.IBinaryInteger&lt;nuint&gt;.GetByteCount">
      <MemberSignature Language="C#" Value="int IBinaryInteger&lt;UIntPtr&gt;.GetByteCount ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IBinaryInteger&lt;nuint&gt;.GetByteCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IBinaryInteger&lt;nuint&gt;#GetByteCount" />
      <MemberSignature Language="VB.NET" Value="Function GetByteCount () As Integer Implements IBinaryInteger(Of UIntPtr).GetByteCount" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;nuint&gt;.GetByteCount : unit -&gt; int&#xA;override this.System.Numerics.IBinaryInteger&lt;nuint&gt;.GetByteCount : unit -&gt; int" Usage="unativeint.System.Numerics.IBinaryInteger&lt;nuint&gt;.GetByteCount " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IBinaryInteger&lt;nuint&gt;.GetByteCount() = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::GetByteCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.GetByteCount</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</summary>
        <returns>The number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.GetByteCount" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UIntPtr&gt;.GetShortestBitLength" ExplicitInterfaceMemberName="System.Numerics.IBinaryInteger&lt;nuint&gt;.GetShortestBitLength">
      <MemberSignature Language="C#" Value="int IBinaryInteger&lt;UIntPtr&gt;.GetShortestBitLength ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IBinaryInteger&lt;nuint&gt;.GetShortestBitLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IBinaryInteger&lt;nuint&gt;#GetShortestBitLength" />
      <MemberSignature Language="VB.NET" Value="Function GetShortestBitLength () As Integer Implements IBinaryInteger(Of UIntPtr).GetShortestBitLength" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;nuint&gt;.GetShortestBitLength : unit -&gt; int&#xA;override this.System.Numerics.IBinaryInteger&lt;nuint&gt;.GetShortestBitLength : unit -&gt; int" Usage="unativeint.System.Numerics.IBinaryInteger&lt;nuint&gt;.GetShortestBitLength " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IBinaryInteger&lt;nuint&gt;.GetShortestBitLength() = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::GetShortestBitLength;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.GetShortestBitLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the length, in bits, of the shortest two's complement representation of the current value.</summary>
        <returns>The length, in bits, of the shortest two's complement representation of the current value.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.GetShortestBitLength" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UIntPtr&gt;.TryReadBigEndian" ExplicitInterfaceMemberName="System.Numerics.IBinaryInteger&lt;nuint&gt;.TryReadBigEndian">
      <MemberSignature Language="C#" Value="static bool IBinaryInteger&lt;UIntPtr&gt;.TryReadBigEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IBinaryInteger&lt;nuint&gt;.TryReadBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] native unsigned int&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IBinaryInteger&lt;nuint&gt;#TryReadBigEndian(System.ReadOnlySpan{System.Byte},System.Boolean,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryReadBigEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As UIntPtr) As Boolean Implements IBinaryInteger(Of UIntPtr).TryReadBigEndian" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;nuint&gt;.TryReadBigEndian : ReadOnlySpan&lt;byte&gt; * bool * unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.IBinaryInteger&lt;nuint&gt;.TryReadBigEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IBinaryInteger&lt;nuint&gt;.TryReadBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] UIntPtr % value) = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::TryReadBigEndian;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="value" Type="System.UIntPtr" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UIntPtr&gt;.TryReadLittleEndian" ExplicitInterfaceMemberName="System.Numerics.IBinaryInteger&lt;nuint&gt;.TryReadLittleEndian">
      <MemberSignature Language="C#" Value="static bool IBinaryInteger&lt;UIntPtr&gt;.TryReadLittleEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IBinaryInteger&lt;nuint&gt;.TryReadLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] native unsigned int&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IBinaryInteger&lt;nuint&gt;#TryReadLittleEndian(System.ReadOnlySpan{System.Byte},System.Boolean,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryReadLittleEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As UIntPtr) As Boolean Implements IBinaryInteger(Of UIntPtr).TryReadLittleEndian" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;nuint&gt;.TryReadLittleEndian : ReadOnlySpan&lt;byte&gt; * bool * unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.IBinaryInteger&lt;nuint&gt;.TryReadLittleEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IBinaryInteger&lt;nuint&gt;.TryReadLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] UIntPtr % value) = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::TryReadLittleEndian;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="value" Type="System.UIntPtr" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UIntPtr&gt;.TryWriteBigEndian" ExplicitInterfaceMemberName="System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteBigEndian">
      <MemberSignature Language="C#" Value="bool IBinaryInteger&lt;UIntPtr&gt;.TryWriteBigEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IBinaryInteger&lt;nuint&gt;#TryWriteBigEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteBigEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IBinaryInteger(Of UIntPtr).TryWriteBigEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteBigEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteBigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="unativeint.System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteBigEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteBigEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::TryWriteBigEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TryWriteBigEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in big-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TryWriteBigEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UIntPtr&gt;.TryWriteLittleEndian" ExplicitInterfaceMemberName="System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteLittleEndian">
      <MemberSignature Language="C#" Value="bool IBinaryInteger&lt;UIntPtr&gt;.TryWriteLittleEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IBinaryInteger&lt;nuint&gt;#TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteLittleEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IBinaryInteger(Of UIntPtr).TryWriteLittleEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteLittleEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteLittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="unativeint.System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteLittleEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IBinaryInteger&lt;nuint&gt;.TryWriteLittleEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::TryWriteLittleEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in little-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryNumber&lt;System.UIntPtr&gt;.AllBitsSet" ExplicitInterfaceMemberName="System.Numerics.IBinaryNumber&lt;nuint&gt;.AllBitsSet">
      <MemberSignature Language="C#" Value="static UIntPtr System.Numerics.IBinaryNumber&lt;System.UIntPtr&gt;.AllBitsSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property native unsigned int System.Numerics.IBinaryNumber&lt;nuint&gt;.AllBitsSet" />
      <MemberSignature Language="DocId" Value="P:System.UIntPtr.System#Numerics#IBinaryNumber&lt;nuint&gt;#AllBitsSet" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property AllBitsSet As UIntPtr Implements IBinaryNumber(Of UIntPtr).AllBitsSet" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryNumber&lt;System.UIntPtr&gt;.AllBitsSet : unativeint" Usage="System.Numerics.IBinaryNumber&lt;System.UIntPtr&gt;.AllBitsSet" />
      <MemberSignature Language="C++ CLI" Value="static property UIntPtr System::Numerics::IBinaryNumber&lt;System::UIntPtr&gt;::AllBitsSet { UIntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IBinaryNumber`1.AllBitsSet</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an instance of the binary type in which all bits are set.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_BitwiseAnd" ExplicitInterfaceMemberName="System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.op_BitwiseAnd">
      <MemberSignature Language="C#" Value="static UIntPtr IBitwiseOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.operator &amp; (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.op_BitwiseAnd(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IBitwiseOperators&lt;nuint,nuint,nuint&gt;#op_BitwiseAnd(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator And (left As UIntPtr, right As UIntPtr) As UIntPtr Implements IBitwiseOperators(Of UIntPtr, UIntPtr, UIntPtr).op_BitwiseAnd" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : unativeint * unativeint -&gt; unativeint" Usage="left &amp;&amp;&amp; right" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.operator &amp;(UIntPtr left, UIntPtr right) = System::Numerics::IBitwiseOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_BitwiseAnd;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_BitwiseAnd(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to <see langword="and" /> with <paramref name="right" />.</param>
        <param name="right">The value to <see langword="and" /> with <paramref name="left" />.</param>
        <summary>Computes the bitwise-and of two values.</summary>
        <returns>The bitwise-and of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_BitwiseOr" ExplicitInterfaceMemberName="System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.op_BitwiseOr">
      <MemberSignature Language="C#" Value="static UIntPtr IBitwiseOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.operator | (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.op_BitwiseOr(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IBitwiseOperators&lt;nuint,nuint,nuint&gt;#op_BitwiseOr(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Or (left As UIntPtr, right As UIntPtr) As UIntPtr Implements IBitwiseOperators(Of UIntPtr, UIntPtr, UIntPtr).op_BitwiseOr" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : unativeint * unativeint -&gt; unativeint" Usage="left ||| right" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.operator |(UIntPtr left, UIntPtr right) = System::Numerics::IBitwiseOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_BitwiseOr;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_BitwiseOr(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to <see langword="or" /> with <paramref name="right" />.</param>
        <param name="right">The value to <see langword="or" /> with <paramref name="left" />.</param>
        <summary>Computes the bitwise-or of two values.</summary>
        <returns>The bitwise-or of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_ExclusiveOr" ExplicitInterfaceMemberName="System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.op_ExclusiveOr">
      <MemberSignature Language="C#" Value="static UIntPtr IBitwiseOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.operator ^ (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.op_ExclusiveOr(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IBitwiseOperators&lt;nuint,nuint,nuint&gt;#op_ExclusiveOr(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Xor (left As UIntPtr, right As UIntPtr) As UIntPtr Implements IBitwiseOperators(Of UIntPtr, UIntPtr, UIntPtr).op_ExclusiveOr" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : unativeint * unativeint -&gt; unativeint" Usage="left ^^^ right" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.operator ^(UIntPtr left, UIntPtr right) = System::Numerics::IBitwiseOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_ExclusiveOr;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_ExclusiveOr(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to xor with <paramref name="right" />.</param>
        <param name="right">The value to xor with <paramref name="left" />.</param>
        <summary>Computes the exclusive-or of two values.</summary>
        <returns>The exclusive-or of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_OnesComplement" ExplicitInterfaceMemberName="System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.op_OnesComplement">
      <MemberSignature Language="C#" Value="static UIntPtr IBitwiseOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.operator ~ (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.op_OnesComplement(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IBitwiseOperators&lt;nuint,nuint,nuint&gt;#op_OnesComplement(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Not (value As UIntPtr) As UIntPtr Implements IBitwiseOperators(Of UIntPtr, UIntPtr, UIntPtr).op_OnesComplement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.op_OnesComplement : unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.op_OnesComplement value" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IBitwiseOperators&lt;nuint,nuint,nuint&gt;.operator ~(UIntPtr value) = System::Numerics::IBitwiseOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_OnesComplement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_OnesComplement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the ones-complement.</param>
        <summary>Computes the ones-complement representation of a given value.</summary>
        <returns>The ones-complement of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.UIntPtr,System.UIntPtr,System.Boolean&gt;.op_GreaterThan" ExplicitInterfaceMemberName="System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.op_GreaterThan">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;UIntPtr,UIntPtr,bool&gt;.operator &gt; (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.op_GreaterThan(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IComparisonOperators&lt;nuint,nuint,System#Boolean&gt;#op_GreaterThan(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt; (left As UIntPtr, right As UIntPtr) As Boolean Implements IComparisonOperators(Of UIntPtr, UIntPtr, Boolean).op_GreaterThan" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : unativeint * unativeint -&gt; bool" Usage="left &gt; right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.operator &gt;(UIntPtr left, UIntPtr right) = System::Numerics::IComparisonOperators&lt;UIntPtr, UIntPtr, bool&gt;::op_GreaterThan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is greater.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.UIntPtr,System.UIntPtr,System.Boolean&gt;.op_GreaterThanOrEqual" ExplicitInterfaceMemberName="System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;UIntPtr,UIntPtr,bool&gt;.operator &gt;= (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.op_GreaterThanOrEqual(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IComparisonOperators&lt;nuint,nuint,System#Boolean&gt;#op_GreaterThanOrEqual(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt;= (left As UIntPtr, right As UIntPtr) As Boolean Implements IComparisonOperators(Of UIntPtr, UIntPtr, Boolean).op_GreaterThanOrEqual" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : unativeint * unativeint -&gt; bool" Usage="left &gt;= right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.operator &gt;=(UIntPtr left, UIntPtr right) = System::Numerics::IComparisonOperators&lt;UIntPtr, UIntPtr, bool&gt;::op_GreaterThanOrEqual;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is greater or equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.UIntPtr,System.UIntPtr,System.Boolean&gt;.op_LessThan" ExplicitInterfaceMemberName="System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.op_LessThan">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;UIntPtr,UIntPtr,bool&gt;.operator &lt; (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.op_LessThan(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IComparisonOperators&lt;nuint,nuint,System#Boolean&gt;#op_LessThan(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt; (left As UIntPtr, right As UIntPtr) As Boolean Implements IComparisonOperators(Of UIntPtr, UIntPtr, Boolean).op_LessThan" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : unativeint * unativeint -&gt; bool" Usage="left &lt; right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.operator &lt;(UIntPtr left, UIntPtr right) = System::Numerics::IComparisonOperators&lt;UIntPtr, UIntPtr, bool&gt;::op_LessThan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is less.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.UIntPtr,System.UIntPtr,System.Boolean&gt;.op_LessThanOrEqual" ExplicitInterfaceMemberName="System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;UIntPtr,UIntPtr,bool&gt;.operator &lt;= (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.op_LessThanOrEqual(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IComparisonOperators&lt;nuint,nuint,System#Boolean&gt;#op_LessThanOrEqual(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt;= (left As UIntPtr, right As UIntPtr) As Boolean Implements IComparisonOperators(Of UIntPtr, UIntPtr, Boolean).op_LessThanOrEqual" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : unativeint * unativeint -&gt; bool" Usage="left &lt;= right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;nuint,nuint,System.Boolean&gt;.operator &lt;=(UIntPtr left, UIntPtr right) = System::Numerics::IComparisonOperators&lt;UIntPtr, UIntPtr, bool&gt;::op_LessThanOrEqual;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is less or equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDecrementOperators&lt;System.UIntPtr&gt;.op_CheckedDecrement" ExplicitInterfaceMemberName="System.Numerics.IDecrementOperators&lt;nuint&gt;.op_CheckedDecrement">
      <MemberSignature Language="C#" Value="static UIntPtr IDecrementOperators&lt;UIntPtr&gt;.op_CheckedDecrement (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IDecrementOperators&lt;nuint&gt;.op_CheckedDecrement(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IDecrementOperators&lt;nuint&gt;#op_CheckedDecrement(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedDecrement (value As UIntPtr) As UIntPtr Implements IDecrementOperators(Of UIntPtr).op_CheckedDecrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IDecrementOperators&lt;nuint&gt;.op_CheckedDecrement : unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.IDecrementOperators&lt;nuint&gt;.op_CheckedDecrement value" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IDecrementOperators&lt;nuint&gt;.op_CheckedDecrement(UIntPtr value) = System::Numerics::IDecrementOperators&lt;UIntPtr&gt;::op_CheckedDecrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_CheckedDecrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to decrement.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDecrementOperators&lt;System.UIntPtr&gt;.op_Decrement" ExplicitInterfaceMemberName="System.Numerics.IDecrementOperators&lt;nuint&gt;.op_Decrement">
      <MemberSignature Language="C#" Value="static UIntPtr IDecrementOperators&lt;UIntPtr&gt;.operator -- (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IDecrementOperators&lt;nuint&gt;.op_Decrement(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IDecrementOperators&lt;nuint&gt;#op_Decrement(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_Decrement (value As UIntPtr) As UIntPtr Implements IDecrementOperators(Of UIntPtr).op_Decrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IDecrementOperators&lt;nuint&gt;.op_Decrement : unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.IDecrementOperators&lt;nuint&gt;.op_Decrement value" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IDecrementOperators&lt;nuint&gt;.operator --(UIntPtr value) = System::Numerics::IDecrementOperators&lt;UIntPtr&gt;::op_Decrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_Decrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to decrement.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDivisionOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_Division" ExplicitInterfaceMemberName="System.Numerics.IDivisionOperators&lt;nuint,nuint,nuint&gt;.op_Division">
      <MemberSignature Language="C#" Value="static UIntPtr IDivisionOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.operator / (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IDivisionOperators&lt;nuint,nuint,nuint&gt;.op_Division(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IDivisionOperators&lt;nuint,nuint,nuint&gt;#op_Division(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator / (left As UIntPtr, right As UIntPtr) As UIntPtr Implements IDivisionOperators(Of UIntPtr, UIntPtr, UIntPtr).op_Division" />
      <MemberSignature Language="F#" Value="static member ( / ) : unativeint * unativeint -&gt; unativeint" Usage="left / right" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IDivisionOperators&lt;nuint,nuint,nuint&gt;.operator /(UIntPtr left, UIntPtr right) = System::Numerics::IDivisionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_Division;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDivisionOperators`3.op_Division(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> divides.</param>
        <param name="right">The value that divides <paramref name="left" />.</param>
        <summary>Divides one value by another to compute their quotient.</summary>
        <returns>The quotient of <paramref name="left" /> divided by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IIncrementOperators&lt;System.UIntPtr&gt;.op_CheckedIncrement" ExplicitInterfaceMemberName="System.Numerics.IIncrementOperators&lt;nuint&gt;.op_CheckedIncrement">
      <MemberSignature Language="C#" Value="static UIntPtr IIncrementOperators&lt;UIntPtr&gt;.op_CheckedIncrement (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IIncrementOperators&lt;nuint&gt;.op_CheckedIncrement(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IIncrementOperators&lt;nuint&gt;#op_CheckedIncrement(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedIncrement (value As UIntPtr) As UIntPtr Implements IIncrementOperators(Of UIntPtr).op_CheckedIncrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IIncrementOperators&lt;nuint&gt;.op_CheckedIncrement : unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.IIncrementOperators&lt;nuint&gt;.op_CheckedIncrement value" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IIncrementOperators&lt;nuint&gt;.op_CheckedIncrement(UIntPtr value) = System::Numerics::IIncrementOperators&lt;UIntPtr&gt;::op_CheckedIncrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_CheckedIncrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to increment.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IIncrementOperators&lt;System.UIntPtr&gt;.op_Increment" ExplicitInterfaceMemberName="System.Numerics.IIncrementOperators&lt;nuint&gt;.op_Increment">
      <MemberSignature Language="C#" Value="static UIntPtr IIncrementOperators&lt;UIntPtr&gt;.operator ++ (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IIncrementOperators&lt;nuint&gt;.op_Increment(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IIncrementOperators&lt;nuint&gt;#op_Increment(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_Increment (value As UIntPtr) As UIntPtr Implements IIncrementOperators(Of UIntPtr).op_Increment" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IIncrementOperators&lt;nuint&gt;.op_Increment : unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.IIncrementOperators&lt;nuint&gt;.op_Increment value" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IIncrementOperators&lt;nuint&gt;.operator ++(UIntPtr value) = System::Numerics::IIncrementOperators&lt;UIntPtr&gt;::op_Increment;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_Increment(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to increment.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMinMaxValue&lt;System.UIntPtr&gt;.MaxValue" ExplicitInterfaceMemberName="System.Numerics.IMinMaxValue&lt;nuint&gt;.MaxValue">
      <MemberSignature Language="C#" Value="static UIntPtr System.Numerics.IMinMaxValue&lt;System.UIntPtr&gt;.MaxValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property native unsigned int System.Numerics.IMinMaxValue&lt;nuint&gt;.MaxValue" />
      <MemberSignature Language="DocId" Value="P:System.UIntPtr.System#Numerics#IMinMaxValue&lt;nuint&gt;#MaxValue" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MaxValue As UIntPtr Implements IMinMaxValue(Of UIntPtr).MaxValue" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMinMaxValue&lt;System.UIntPtr&gt;.MaxValue : unativeint" Usage="System.Numerics.IMinMaxValue&lt;System.UIntPtr&gt;.MaxValue" />
      <MemberSignature Language="C++ CLI" Value="static property UIntPtr System::Numerics::IMinMaxValue&lt;System::UIntPtr&gt;::MaxValue { UIntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMinMaxValue`1.MaxValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum value of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMinMaxValue&lt;System.UIntPtr&gt;.MinValue" ExplicitInterfaceMemberName="System.Numerics.IMinMaxValue&lt;nuint&gt;.MinValue">
      <MemberSignature Language="C#" Value="static UIntPtr System.Numerics.IMinMaxValue&lt;System.UIntPtr&gt;.MinValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property native unsigned int System.Numerics.IMinMaxValue&lt;nuint&gt;.MinValue" />
      <MemberSignature Language="DocId" Value="P:System.UIntPtr.System#Numerics#IMinMaxValue&lt;nuint&gt;#MinValue" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MinValue As UIntPtr Implements IMinMaxValue(Of UIntPtr).MinValue" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMinMaxValue&lt;System.UIntPtr&gt;.MinValue : unativeint" Usage="System.Numerics.IMinMaxValue&lt;System.UIntPtr&gt;.MinValue" />
      <MemberSignature Language="C++ CLI" Value="static property UIntPtr System::Numerics::IMinMaxValue&lt;System::UIntPtr&gt;::MinValue { UIntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMinMaxValue`1.MinValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the minimum value of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IModulusOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_Modulus" ExplicitInterfaceMemberName="System.Numerics.IModulusOperators&lt;nuint,nuint,nuint&gt;.op_Modulus">
      <MemberSignature Language="C#" Value="static UIntPtr IModulusOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.operator % (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IModulusOperators&lt;nuint,nuint,nuint&gt;.op_Modulus(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IModulusOperators&lt;nuint,nuint,nuint&gt;#op_Modulus(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Mod (left As UIntPtr, right As UIntPtr) As UIntPtr Implements IModulusOperators(Of UIntPtr, UIntPtr, UIntPtr).op_Modulus" />
      <MemberSignature Language="F#" Value="static member ( % ) : unativeint * unativeint -&gt; unativeint" Usage="left % right" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IModulusOperators&lt;nuint,nuint,nuint&gt;.operator %(UIntPtr left, UIntPtr right) = System::Numerics::IModulusOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_Modulus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IModulusOperators`3.op_Modulus(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> divides.</param>
        <param name="right">The value that divides <paramref name="left" />.</param>
        <summary>Divides two values together to compute their modulus or remainder.</summary>
        <returns>The modulus or remainder of <paramref name="left" /> divided by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplicativeIdentity&lt;System.UIntPtr,System.UIntPtr&gt;.MultiplicativeIdentity" ExplicitInterfaceMemberName="System.Numerics.IMultiplicativeIdentity&lt;nuint,nuint&gt;.MultiplicativeIdentity">
      <MemberSignature Language="C#" Value="static UIntPtr System.Numerics.IMultiplicativeIdentity&lt;System.UIntPtr,System.UIntPtr&gt;.MultiplicativeIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property native unsigned int System.Numerics.IMultiplicativeIdentity&lt;nuint,nuint&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="DocId" Value="P:System.UIntPtr.System#Numerics#IMultiplicativeIdentity&lt;nuint,nuint&gt;#MultiplicativeIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MultiplicativeIdentity As UIntPtr Implements IMultiplicativeIdentity(Of UIntPtr, UIntPtr).MultiplicativeIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMultiplicativeIdentity&lt;System.UIntPtr,System.UIntPtr&gt;.MultiplicativeIdentity : unativeint" Usage="System.Numerics.IMultiplicativeIdentity&lt;System.UIntPtr,System.UIntPtr&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property UIntPtr System::Numerics::IMultiplicativeIdentity&lt;System::UIntPtr,System::UIntPtr&gt;::MultiplicativeIdentity { UIntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMultiplicativeIdentity`2.MultiplicativeIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the multiplicative identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplyOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_CheckedMultiply" ExplicitInterfaceMemberName="System.Numerics.IMultiplyOperators&lt;nuint,nuint,nuint&gt;.op_CheckedMultiply">
      <MemberSignature Language="C#" Value="static UIntPtr IMultiplyOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.op_CheckedMultiply (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IMultiplyOperators&lt;nuint,nuint,nuint&gt;.op_CheckedMultiply(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IMultiplyOperators&lt;nuint,nuint,nuint&gt;#op_CheckedMultiply(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedMultiply (left As UIntPtr, right As UIntPtr) As UIntPtr Implements IMultiplyOperators(Of UIntPtr, UIntPtr, UIntPtr).op_CheckedMultiply" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMultiplyOperators&lt;nuint,nuint,nuint&gt;.op_CheckedMultiply : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.IMultiplyOperators&lt;nuint,nuint,nuint&gt;.op_CheckedMultiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IMultiplyOperators&lt;nuint,nuint,nuint&gt;.op_CheckedMultiply(UIntPtr left, UIntPtr right) = System::Numerics::IMultiplyOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_CheckedMultiply;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IMultiplyOperators`3.op_CheckedMultiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> multiplies.</param>
        <param name="right">The value that multiplies <paramref name="left" />.</param>
        <summary>Multiplies two values together to compute their product.</summary>
        <returns>The product of <paramref name="left" /> multiplied by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplyOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_Multiply" ExplicitInterfaceMemberName="System.Numerics.IMultiplyOperators&lt;nuint,nuint,nuint&gt;.op_Multiply">
      <MemberSignature Language="C#" Value="static UIntPtr IMultiplyOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.operator * (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IMultiplyOperators&lt;nuint,nuint,nuint&gt;.op_Multiply(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IMultiplyOperators&lt;nuint,nuint,nuint&gt;#op_Multiply(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator * (left As UIntPtr, right As UIntPtr) As UIntPtr Implements IMultiplyOperators(Of UIntPtr, UIntPtr, UIntPtr).op_Multiply" />
      <MemberSignature Language="F#" Value="static member ( * ) : unativeint * unativeint -&gt; unativeint" Usage="left * right" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IMultiplyOperators&lt;nuint,nuint,nuint&gt;.operator *(UIntPtr left, UIntPtr right) = System::Numerics::IMultiplyOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_Multiply;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IMultiplyOperators`3.op_Multiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> multiplies.</param>
        <param name="right">The value that multiplies <paramref name="left" />.</param>
        <summary>Multiplies two values together to compute their product.</summary>
        <returns>The product of <paramref name="left" /> multiplied by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumber&lt;System.UIntPtr&gt;.CopySign" ExplicitInterfaceMemberName="System.Numerics.INumber&lt;nuint&gt;.CopySign">
      <MemberSignature Language="C#" Value="static UIntPtr INumber&lt;UIntPtr&gt;.CopySign (UIntPtr value, UIntPtr sign);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.INumber&lt;nuint&gt;.CopySign(native unsigned int value, native unsigned int sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumber&lt;nuint&gt;#CopySign(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function CopySign (value As UIntPtr, sign As UIntPtr) As UIntPtr Implements INumber(Of UIntPtr).CopySign" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumber&lt;nuint&gt;.CopySign : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.INumber&lt;nuint&gt;.CopySign (value, sign)" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.INumber&lt;nuint&gt;.CopySign(UIntPtr value, UIntPtr sign) = System::Numerics::INumber&lt;UIntPtr&gt;::CopySign;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.CopySign(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="sign" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose magnitude is used in the result.</param>
        <param name="sign">The value whose sign is used in the result.</param>
        <summary>Copies the sign of a value to the sign of another value.</summary>
        <returns>A value with the magnitude of <paramref name="value" /> and the sign of <paramref name="sign" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumber&lt;System.UIntPtr&gt;.MaxNumber" ExplicitInterfaceMemberName="System.Numerics.INumber&lt;nuint&gt;.MaxNumber">
      <MemberSignature Language="C#" Value="static UIntPtr INumber&lt;UIntPtr&gt;.MaxNumber (UIntPtr x, UIntPtr y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.INumber&lt;nuint&gt;.MaxNumber(native unsigned int x, native unsigned int y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumber&lt;nuint&gt;#MaxNumber(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxNumber (x As UIntPtr, y As UIntPtr) As UIntPtr Implements INumber(Of UIntPtr).MaxNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumber&lt;nuint&gt;.MaxNumber : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.INumber&lt;nuint&gt;.MaxNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.INumber&lt;nuint&gt;.MaxNumber(UIntPtr x, UIntPtr y) = System::Numerics::INumber&lt;UIntPtr&gt;::MaxNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.MaxNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumber&lt;System.UIntPtr&gt;.MinNumber" ExplicitInterfaceMemberName="System.Numerics.INumber&lt;nuint&gt;.MinNumber">
      <MemberSignature Language="C#" Value="static UIntPtr INumber&lt;UIntPtr&gt;.MinNumber (UIntPtr x, UIntPtr y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.INumber&lt;nuint&gt;.MinNumber(native unsigned int x, native unsigned int y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumber&lt;nuint&gt;#MinNumber(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinNumber (x As UIntPtr, y As UIntPtr) As UIntPtr Implements INumber(Of UIntPtr).MinNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumber&lt;nuint&gt;.MinNumber : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.INumber&lt;nuint&gt;.MinNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.INumber&lt;nuint&gt;.MinNumber(UIntPtr x, UIntPtr y) = System::Numerics::INumber&lt;UIntPtr&gt;::MinNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.MinNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.Abs" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.Abs">
      <MemberSignature Language="C#" Value="static UIntPtr INumberBase&lt;UIntPtr&gt;.Abs (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.INumberBase&lt;nuint&gt;.Abs(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#Abs(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Abs (value As UIntPtr) As UIntPtr Implements INumberBase(Of UIntPtr).Abs" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.Abs : unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.Abs value" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.INumberBase&lt;nuint&gt;.Abs(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::Abs;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Abs(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to get its absolute.</param>
        <summary>Computes the absolute of a value.</summary>
        <returns>The absolute of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsCanonical" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsCanonical">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsCanonical (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsCanonical(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsCanonical(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsCanonical (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsCanonical" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsCanonical : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsCanonical value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsCanonical(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsCanonical;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsCanonical(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is in its canonical representation.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is in its canonical representation; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsComplexNumber" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsComplexNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsComplexNumber (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsComplexNumber(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsComplexNumber(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsComplexNumber (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsComplexNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsComplexNumber : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsComplexNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsComplexNumber(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsComplexNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsComplexNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a complex number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a complex number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsFinite" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsFinite">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsFinite (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsFinite(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsFinite(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsFinite (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsFinite" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsFinite : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsFinite value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsFinite(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsFinite;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsFinite(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is finite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is finite; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsImaginaryNumber" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsImaginaryNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsImaginaryNumber (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsImaginaryNumber(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsImaginaryNumber(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsImaginaryNumber (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsImaginaryNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsImaginaryNumber : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsImaginaryNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsImaginaryNumber(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsImaginaryNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsImaginaryNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a pure imaginary number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a pure imaginary number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsInfinity" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsInfinity (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsInfinity(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsInfinity(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsInfinity (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsInfinity : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsInfinity(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is infinite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is infinite; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsInteger" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsInteger">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsInteger (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsInteger(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsInteger(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsInteger (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsInteger" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsInteger : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsInteger value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsInteger(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an integer; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsNaN" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsNaN">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsNaN (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsNaN(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsNaN(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNaN (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsNaN" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsNaN : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsNaN value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsNaN(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsNaN;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNaN(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is NaN.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is NaN; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsNegative" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsNegative">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsNegative (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsNegative(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsNegative(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNegative (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsNegative" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsNegative : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsNegative value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsNegative(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsNegative;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegative(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsNegativeInfinity" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsNegativeInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsNegativeInfinity (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsNegativeInfinity(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsNegativeInfinity(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNegativeInfinity (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsNegativeInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsNegativeInfinity : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsNegativeInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsNegativeInfinity(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsNegativeInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegativeInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsNormal" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsNormal">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsNormal (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsNormal(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsNormal(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNormal (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsNormal" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsNormal : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsNormal value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsNormal(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsNormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is normal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is normal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsPositive" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsPositive">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsPositive (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsPositive(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsPositive(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsPositive (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsPositive" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsPositive : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsPositive value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsPositive(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsPositive;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositive(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsPositiveInfinity" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsPositiveInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsPositiveInfinity (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsPositiveInfinity(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsPositiveInfinity(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsPositiveInfinity (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsPositiveInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsPositiveInfinity : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsPositiveInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsPositiveInfinity(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsPositiveInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositiveInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsRealNumber" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsRealNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsRealNumber (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsRealNumber(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsRealNumber(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsRealNumber (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsRealNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsRealNumber : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsRealNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsRealNumber(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsRealNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsRealNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a real number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a real number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsSubnormal" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsSubnormal">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsSubnormal (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsSubnormal(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsSubnormal(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsSubnormal (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsSubnormal" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsSubnormal : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsSubnormal value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsSubnormal(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsSubnormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsSubnormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is subnormal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is subnormal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.IsZero" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.IsZero">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.IsZero (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.IsZero(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#IsZero(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsZero (value As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).IsZero" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.IsZero : unativeint -&gt; bool" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.IsZero value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;nuint&gt;.IsZero(UIntPtr value) = System::Numerics::INumberBase&lt;UIntPtr&gt;::IsZero;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsZero(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is zero.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is zero; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.MaxMagnitude" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.MaxMagnitude">
      <MemberSignature Language="C#" Value="static UIntPtr INumberBase&lt;UIntPtr&gt;.MaxMagnitude (UIntPtr x, UIntPtr y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.INumberBase&lt;nuint&gt;.MaxMagnitude(native unsigned int x, native unsigned int y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#MaxMagnitude(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxMagnitude (x As UIntPtr, y As UIntPtr) As UIntPtr Implements INumberBase(Of UIntPtr).MaxMagnitude" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.MaxMagnitude : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.INumberBase&lt;nuint&gt;.MaxMagnitude(UIntPtr x, UIntPtr y) = System::Numerics::INumberBase&lt;UIntPtr&gt;::MaxMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.MaxMagnitudeNumber" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.MaxMagnitudeNumber">
      <MemberSignature Language="C#" Value="static UIntPtr INumberBase&lt;UIntPtr&gt;.MaxMagnitudeNumber (UIntPtr x, UIntPtr y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.INumberBase&lt;nuint&gt;.MaxMagnitudeNumber(native unsigned int x, native unsigned int y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#MaxMagnitudeNumber(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxMagnitudeNumber (x As UIntPtr, y As UIntPtr) As UIntPtr Implements INumberBase(Of UIntPtr).MaxMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.MaxMagnitudeNumber : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.MaxMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.INumberBase&lt;nuint&gt;.MaxMagnitudeNumber(UIntPtr x, UIntPtr y) = System::Numerics::INumberBase&lt;UIntPtr&gt;::MaxMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the greater magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.MinMagnitude" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.MinMagnitude">
      <MemberSignature Language="C#" Value="static UIntPtr INumberBase&lt;UIntPtr&gt;.MinMagnitude (UIntPtr x, UIntPtr y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.INumberBase&lt;nuint&gt;.MinMagnitude(native unsigned int x, native unsigned int y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#MinMagnitude(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinMagnitude (x As UIntPtr, y As UIntPtr) As UIntPtr Implements INumberBase(Of UIntPtr).MinMagnitude" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.MinMagnitude : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.INumberBase&lt;nuint&gt;.MinMagnitude(UIntPtr x, UIntPtr y) = System::Numerics::INumberBase&lt;UIntPtr&gt;::MinMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.MinMagnitudeNumber" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.MinMagnitudeNumber">
      <MemberSignature Language="C#" Value="static UIntPtr INumberBase&lt;UIntPtr&gt;.MinMagnitudeNumber (UIntPtr x, UIntPtr y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.INumberBase&lt;nuint&gt;.MinMagnitudeNumber(native unsigned int x, native unsigned int y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#MinMagnitudeNumber(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinMagnitudeNumber (x As UIntPtr, y As UIntPtr) As UIntPtr Implements INumberBase(Of UIntPtr).MinMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.MinMagnitudeNumber : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.MinMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.INumberBase&lt;nuint&gt;.MinMagnitudeNumber(UIntPtr x, UIntPtr y) = System::Numerics::INumberBase&lt;UIntPtr&gt;::MinMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the lesser magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.One" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.One">
      <MemberSignature Language="C#" Value="static UIntPtr System.Numerics.INumberBase&lt;System.UIntPtr&gt;.One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property native unsigned int System.Numerics.INumberBase&lt;nuint&gt;.One" />
      <MemberSignature Language="DocId" Value="P:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#One" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property One As UIntPtr Implements INumberBase(Of UIntPtr).One" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UIntPtr&gt;.One : unativeint" Usage="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.One" />
      <MemberSignature Language="C++ CLI" Value="static property UIntPtr System::Numerics::INumberBase&lt;System::UIntPtr&gt;::One { UIntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.One</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>1</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.Radix" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.Radix">
      <MemberSignature Language="C#" Value="static int System.Numerics.INumberBase&lt;System.UIntPtr&gt;.Radix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 System.Numerics.INumberBase&lt;nuint&gt;.Radix" />
      <MemberSignature Language="DocId" Value="P:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#Radix" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property Radix As Integer Implements INumberBase(Of UIntPtr).Radix" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UIntPtr&gt;.Radix : int" Usage="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.Radix" />
      <MemberSignature Language="C++ CLI" Value="static property int System::Numerics::INumberBase&lt;System::UIntPtr&gt;::Radix { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Radix</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the radix, or base, for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.TryConvertToChecked&lt;TOther&gt;" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.TryConvertToChecked&lt;TOther&gt; (UIntPtr value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(native unsigned int value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#TryConvertToChecked``1(System.UIntPtr,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToChecked(Of TOther As INumberBase(Of TOther)) (value As UIntPtr, ByRef result As TOther) As Boolean Implements INumberBase(Of UIntPtr).TryConvertToChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToChecked : unativeint * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToChecked(UIntPtr value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;UIntPtr&gt;::TryConvertToChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToChecked``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.TryConvertToSaturating&lt;TOther&gt;" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.TryConvertToSaturating&lt;TOther&gt; (UIntPtr value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(native unsigned int value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#TryConvertToSaturating``1(System.UIntPtr,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToSaturating(Of TOther As INumberBase(Of TOther)) (value As UIntPtr, ByRef result As TOther) As Boolean Implements INumberBase(Of UIntPtr).TryConvertToSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToSaturating : unativeint * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToSaturating(UIntPtr value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;UIntPtr&gt;::TryConvertToSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToSaturating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.TryConvertToTruncating&lt;TOther&gt;" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.TryConvertToTruncating&lt;TOther&gt; (UIntPtr value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(native unsigned int value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#TryConvertToTruncating``1(System.UIntPtr,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToTruncating(Of TOther As INumberBase(Of TOther)) (value As UIntPtr, ByRef result As TOther) As Boolean Implements INumberBase(Of UIntPtr).TryConvertToTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToTruncating : unativeint * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertToTruncating(UIntPtr value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;UIntPtr&gt;::TryConvertToTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToTruncating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.TryConvertFromChecked&lt;TOther&gt;" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.TryConvertFromChecked&lt;TOther&gt; (TOther value, out UIntPtr result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#TryConvertFromChecked``1(``0,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromChecked(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).TryConvertFromChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromChecked : 'Other * unativeint -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromChecked(TOther value, [Runtime::InteropServices::Out] UIntPtr % result) = System::Numerics::INumberBase&lt;UIntPtr&gt;::TryConvertFromChecked;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.TryConvertFromSaturating&lt;TOther&gt;" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.TryConvertFromSaturating&lt;TOther&gt; (TOther value, out UIntPtr result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#TryConvertFromSaturating``1(``0,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).TryConvertFromSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromSaturating : 'Other * unativeint -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromSaturating(TOther value, [Runtime::InteropServices::Out] UIntPtr % result) = System::Numerics::INumberBase&lt;UIntPtr&gt;::TryConvertFromSaturating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.TryConvertFromTruncating&lt;TOther&gt;" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UIntPtr&gt;.TryConvertFromTruncating&lt;TOther&gt; (TOther value, out UIntPtr result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#TryConvertFromTruncating``1(``0,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As UIntPtr) As Boolean Implements INumberBase(Of UIntPtr).TryConvertFromTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromTruncating : 'Other * unativeint -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.unativeint.System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;nuint&gt;.TryConvertFromTruncating(TOther value, [Runtime::InteropServices::Out] UIntPtr % result) = System::Numerics::INumberBase&lt;UIntPtr&gt;::TryConvertFromTruncating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.Zero" ExplicitInterfaceMemberName="System.Numerics.INumberBase&lt;nuint&gt;.Zero">
      <MemberSignature Language="C#" Value="static UIntPtr System.Numerics.INumberBase&lt;System.UIntPtr&gt;.Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property native unsigned int System.Numerics.INumberBase&lt;nuint&gt;.Zero" />
      <MemberSignature Language="DocId" Value="P:System.UIntPtr.System#Numerics#INumberBase&lt;nuint&gt;#Zero" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property Zero As UIntPtr Implements INumberBase(Of UIntPtr).Zero" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UIntPtr&gt;.Zero : unativeint" Usage="System.Numerics.INumberBase&lt;System.UIntPtr&gt;.Zero" />
      <MemberSignature Language="C++ CLI" Value="static property UIntPtr System::Numerics::INumberBase&lt;System::UIntPtr&gt;::Zero { UIntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Zero</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>0</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.UIntPtr,System.Int32,System.UIntPtr&gt;.op_LeftShift" ExplicitInterfaceMemberName="System.Numerics.IShiftOperators&lt;nuint,System.Int32,nuint&gt;.op_LeftShift">
      <MemberSignature Language="C#" Value="static UIntPtr IShiftOperators&lt;UIntPtr,int,UIntPtr&gt;.operator &lt;&lt; (UIntPtr value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IShiftOperators&lt;nuint,System.Int32,nuint&gt;.op_LeftShift(native unsigned int value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IShiftOperators&lt;nuint,System#Int32,nuint&gt;#op_LeftShift(System.UIntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt;&lt; (value As UIntPtr, shiftAmount As Integer) As UIntPtr Implements IShiftOperators(Of UIntPtr, Integer, UIntPtr).op_LeftShift" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : unativeint * int -&gt; unativeint" Usage="value &lt;&lt;&lt; shiftAmount" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IShiftOperators&lt;nuint,System.Int32,nuint&gt;.operator &lt;&lt;(UIntPtr value, int shiftAmount) = System::Numerics::IShiftOperators&lt;UIntPtr, int, UIntPtr&gt;::op_LeftShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_LeftShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted left by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted left.</param>
        <summary>Shifts a value left by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> left by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.UIntPtr,System.Int32,System.UIntPtr&gt;.op_RightShift" ExplicitInterfaceMemberName="System.Numerics.IShiftOperators&lt;nuint,System.Int32,nuint&gt;.op_RightShift">
      <MemberSignature Language="C#" Value="static UIntPtr IShiftOperators&lt;UIntPtr,int,UIntPtr&gt;.operator &gt;&gt; (UIntPtr value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IShiftOperators&lt;nuint,System.Int32,nuint&gt;.op_RightShift(native unsigned int value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IShiftOperators&lt;nuint,System#Int32,nuint&gt;#op_RightShift(System.UIntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt;&gt; (value As UIntPtr, shiftAmount As Integer) As UIntPtr Implements IShiftOperators(Of UIntPtr, Integer, UIntPtr).op_RightShift" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : unativeint * int -&gt; unativeint" Usage="value &gt;&gt;&gt; shiftAmount" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IShiftOperators&lt;nuint,System.Int32,nuint&gt;.operator &gt;&gt;(UIntPtr value, int shiftAmount) = System::Numerics::IShiftOperators&lt;UIntPtr, int, UIntPtr&gt;::op_RightShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_RightShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted right by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted right.</param>
        <summary>Shifts a value right by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> right by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.UIntPtr,System.Int32,System.UIntPtr&gt;.op_UnsignedRightShift" ExplicitInterfaceMemberName="System.Numerics.IShiftOperators&lt;nuint,System.Int32,nuint&gt;.op_UnsignedRightShift">
      <MemberSignature Language="C#" Value="static UIntPtr IShiftOperators&lt;UIntPtr,int,UIntPtr&gt;.op_UnsignedRightShift (UIntPtr value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IShiftOperators&lt;nuint,System.Int32,nuint&gt;.op_UnsignedRightShift(native unsigned int value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IShiftOperators&lt;nuint,System#Int32,nuint&gt;#op_UnsignedRightShift(System.UIntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_UnsignedRightShift (value As UIntPtr, shiftAmount As Integer) As UIntPtr Implements IShiftOperators(Of UIntPtr, Integer, UIntPtr).op_UnsignedRightShift" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IShiftOperators&lt;nuint,System.Int32,nuint&gt;.op_UnsignedRightShift : unativeint * int -&gt; unativeint" Usage="System.unativeint.System.Numerics.IShiftOperators&lt;nuint,System.Int32,nuint&gt;.op_UnsignedRightShift (value, shiftAmount)" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IShiftOperators&lt;nuint,System.Int32,nuint&gt;.op_UnsignedRightShift(UIntPtr value, int shiftAmount) = System::Numerics::IShiftOperators&lt;UIntPtr, int, UIntPtr&gt;::op_UnsignedRightShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_UnsignedRightShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted right by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted right.</param>
        <summary>Shifts a value right by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> right by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.ISubtractionOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_CheckedSubtraction" ExplicitInterfaceMemberName="System.Numerics.ISubtractionOperators&lt;nuint,nuint,nuint&gt;.op_CheckedSubtraction">
      <MemberSignature Language="C#" Value="static UIntPtr ISubtractionOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.op_CheckedSubtraction (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.ISubtractionOperators&lt;nuint,nuint,nuint&gt;.op_CheckedSubtraction(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#ISubtractionOperators&lt;nuint,nuint,nuint&gt;#op_CheckedSubtraction(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedSubtraction (left As UIntPtr, right As UIntPtr) As UIntPtr Implements ISubtractionOperators(Of UIntPtr, UIntPtr, UIntPtr).op_CheckedSubtraction" />
      <MemberSignature Language="F#" Value="static member System.Numerics.ISubtractionOperators&lt;nuint,nuint,nuint&gt;.op_CheckedSubtraction : unativeint * unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.ISubtractionOperators&lt;nuint,nuint,nuint&gt;.op_CheckedSubtraction (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.ISubtractionOperators&lt;nuint,nuint,nuint&gt;.op_CheckedSubtraction(UIntPtr left, UIntPtr right) = System::Numerics::ISubtractionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_CheckedSubtraction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ISubtractionOperators`3.op_CheckedSubtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value from which <paramref name="right" /> is subtracted.</param>
        <param name="right">The value that's subtracted from <paramref name="left" />.</param>
        <summary>Subtracts two values to compute their difference.</summary>
        <returns>The value of <paramref name="right" /> subtracted from <paramref name="left" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.ISubtractionOperators&lt;System.UIntPtr,System.UIntPtr,System.UIntPtr&gt;.op_Subtraction" ExplicitInterfaceMemberName="System.Numerics.ISubtractionOperators&lt;nuint,nuint,nuint&gt;.op_Subtraction">
      <MemberSignature Language="C#" Value="static UIntPtr ISubtractionOperators&lt;UIntPtr,UIntPtr,UIntPtr&gt;.operator - (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.ISubtractionOperators&lt;nuint,nuint,nuint&gt;.op_Subtraction(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#ISubtractionOperators&lt;nuint,nuint,nuint&gt;#op_Subtraction(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator - (left As UIntPtr, right As UIntPtr) As UIntPtr Implements ISubtractionOperators(Of UIntPtr, UIntPtr, UIntPtr).op_Subtraction" />
      <MemberSignature Language="F#" Value="static member ( - ) : unativeint * unativeint -&gt; unativeint" Usage="left - right" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.ISubtractionOperators&lt;nuint,nuint,nuint&gt;.operator -(UIntPtr left, UIntPtr right) = System::Numerics::ISubtractionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;::op_Subtraction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ISubtractionOperators`3.op_Subtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value from which <paramref name="right" /> is subtracted.</param>
        <param name="right">The value that's subtracted from <paramref name="left" />.</param>
        <summary>Subtracts two values to compute their difference.</summary>
        <returns>The value of <paramref name="right" /> subtracted from <paramref name="left" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryNegationOperators&lt;System.UIntPtr,System.UIntPtr&gt;.op_CheckedUnaryNegation" ExplicitInterfaceMemberName="System.Numerics.IUnaryNegationOperators&lt;nuint,nuint&gt;.op_CheckedUnaryNegation">
      <MemberSignature Language="C#" Value="static UIntPtr IUnaryNegationOperators&lt;UIntPtr,UIntPtr&gt;.op_CheckedUnaryNegation (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IUnaryNegationOperators&lt;nuint,nuint&gt;.op_CheckedUnaryNegation(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IUnaryNegationOperators&lt;nuint,nuint&gt;#op_CheckedUnaryNegation(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedUnaryNegation (value As UIntPtr) As UIntPtr Implements IUnaryNegationOperators(Of UIntPtr, UIntPtr).op_CheckedUnaryNegation" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IUnaryNegationOperators&lt;nuint,nuint&gt;.op_CheckedUnaryNegation : unativeint -&gt; unativeint" Usage="System.unativeint.System.Numerics.IUnaryNegationOperators&lt;nuint,nuint&gt;.op_CheckedUnaryNegation value" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IUnaryNegationOperators&lt;nuint,nuint&gt;.op_CheckedUnaryNegation(UIntPtr value) = System::Numerics::IUnaryNegationOperators&lt;UIntPtr, UIntPtr&gt;::op_CheckedUnaryNegation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryNegationOperators`2.op_CheckedUnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary negation.</param>
        <summary>Computes the checked unary negation of a value.</summary>
        <returns>The unary negation of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryNegationOperators&lt;System.UIntPtr,System.UIntPtr&gt;.op_UnaryNegation" ExplicitInterfaceMemberName="System.Numerics.IUnaryNegationOperators&lt;nuint,nuint&gt;.op_UnaryNegation">
      <MemberSignature Language="C#" Value="static UIntPtr IUnaryNegationOperators&lt;UIntPtr,UIntPtr&gt;.operator - (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IUnaryNegationOperators&lt;nuint,nuint&gt;.op_UnaryNegation(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IUnaryNegationOperators&lt;nuint,nuint&gt;#op_UnaryNegation(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator - (value As UIntPtr) As UIntPtr Implements IUnaryNegationOperators(Of UIntPtr, UIntPtr).op_UnaryNegation" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : unativeint -&gt; unativeint" Usage="- value" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IUnaryNegationOperators&lt;nuint,nuint&gt;.operator -(UIntPtr value) = System::Numerics::IUnaryNegationOperators&lt;UIntPtr, UIntPtr&gt;::op_UnaryNegation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryNegationOperators`2.op_UnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary negation.</param>
        <summary>Computes the unary negation of a value.</summary>
        <returns>The unary negation of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryPlusOperators&lt;System.UIntPtr,System.UIntPtr&gt;.op_UnaryPlus" ExplicitInterfaceMemberName="System.Numerics.IUnaryPlusOperators&lt;nuint,nuint&gt;.op_UnaryPlus">
      <MemberSignature Language="C#" Value="static UIntPtr IUnaryPlusOperators&lt;UIntPtr,UIntPtr&gt;.operator + (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig native unsigned int System.Numerics.IUnaryPlusOperators&lt;nuint,nuint&gt;.op_UnaryPlus(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Numerics#IUnaryPlusOperators&lt;nuint,nuint&gt;#op_UnaryPlus(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator + (value As UIntPtr) As UIntPtr Implements IUnaryPlusOperators(Of UIntPtr, UIntPtr).op_UnaryPlus" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : unativeint -&gt; unativeint" Usage="+ value" />
      <MemberSignature Language="C++ CLI" Value=" static UIntPtr System.Numerics.IUnaryPlusOperators&lt;nuint,nuint&gt;.operator +(UIntPtr value) = System::Numerics::IUnaryPlusOperators&lt;UIntPtr, UIntPtr&gt;::op_UnaryPlus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryPlusOperators`2.op_UnaryPlus(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary plus.</param>
        <summary>Computes the unary plus of a value.</summary>
        <returns>The unary plus of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="unativeint.System.Runtime.Serialization.ISerializable.GetObjectData (info, context)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</param>
        <param name="context">The destination for this serialization. (This parameter is not used; specify <see langword="null" />.)</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data needed to serialize the current <see cref="T:System.UIntPtr" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method populates the `info` parameter with the value of the current <xref:System.UIntPtr> object.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToPointer">
      <MemberSignature Language="C#" Value="public void* ToPointer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void* ToPointer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.ToPointer" />
      <MemberSignature Language="F#" Value="member this.ToPointer : unit -&gt; nativeptr&lt;unit&gt;" Usage="unativeint.ToPointer " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void* ToPointer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the value of this instance to a pointer to an unspecified type.</summary>
        <returns>A pointer to <see cref="T:System.Void" />; that is, a pointer to memory containing data of an unspecified type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="unativeint.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the numeric value of this instance to its equivalent string representation.</summary>
        <returns>The string representation of the value of this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 If the value of the <xref:System.IntPtr.Size%2A> property for this instance is 4, then this method is equivalent to <xref:System.UInt32.ToString%2A>; otherwise, this method is equivalent to <xref:System.UInt64.ToString%2A>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="unativeint.ToString provider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <summary>Converts the numeric value of this instance to its equivalent string representation using the specified format and culture-specific format information.</summary>
        <returns>The string representation of the value of this instance as specified by <paramref name="provider" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string? format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="unativeint.ToString format" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A standard or custom numeric format string.</param>
        <summary>Converts the numeric value of this instance to its equivalent string representation, using the specified format.</summary>
        <returns>The string representation of the value of this instance as specified by <paramref name="format" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid or not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string? format, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="unativeint.ToString (format, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="format">The format to use.
 -or-
 A <see langword="null" /> reference (<see langword="Nothing" /> in Visual Basic) to use the default format defined for the type of the <see cref="T:System.IFormattable" /> implementation.</param>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <summary>Formats the value of the current instance using the specified format.</summary>
        <returns>The value of the current instance in the specified format.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid or not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public uint ToUInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int32 ToUInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.ToUInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUInt32 () As UInteger" />
      <MemberSignature Language="F#" Value="member this.ToUInt32 : unit -&gt; uint32" Usage="unativeint.ToUInt32 " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt32 ToUInt32();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the value of this instance to a 32-bit unsigned integer.</summary>
        <returns>A 32-bit unsigned integer equal to the value of this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 An exception is only thrown if the value of `value` requires more bits than the executing process supports.

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">In a 64-bit process, the value of this instance is too large to represent as a 32-bit unsigned integer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public ulong ToUInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int64 ToUInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.ToUInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUInt64 () As ULong" />
      <MemberSignature Language="F#" Value="member this.ToUInt64 : unit -&gt; uint64" Usage="unativeint.ToUInt64 " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt64 ToUInt64();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the value of this instance to a 64-bit unsigned integer.</summary>
        <returns>A 64-bit unsigned integer equal to the value of this instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount">
      <MemberSignature Language="C#" Value="public static UIntPtr TrailingZeroCount (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int TrailingZeroCount(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TrailingZeroCount(System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrailingZeroCount (value As UIntPtr) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : unativeint -&gt; unativeint" Usage="System.unativeint.TrailingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr TrailingZeroCount(UIntPtr value) = System::Numerics::IBinaryInteger&lt;UIntPtr&gt;::TrailingZeroCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TrailingZeroCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose trailing zeroes are to be counted.</param>
        <summary>Computes the number of trailing zeros in a value.</summary>
        <returns>The number of trailing zeros in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TrailingZeroCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;byte&gt; utf8Destination, out int bytesWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFormat(valuetype System.Span`1&lt;unsigned int8&gt; utf8Destination, [out] int32&amp; bytesWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (utf8Destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="unativeint.TryFormat (utf8Destination, bytesWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.System#IUtf8SpanFormattable#TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
        <InterfaceMember FrameworkAlternate="net-9.0">M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="unativeint.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ISpanFormattable.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span in which to write this instance's value formatted as a span of characters.</param>
        <param name="charsWritten">When this method returns, contains the number of characters that were written in <paramref name="destination" />.</param>
        <param name="format">A span containing the characters that represent a standard or custom format string that defines the acceptable format for <paramref name="destination" />.</param>
        <param name="provider">An optional object that supplies culture-specific formatting information for <paramref name="destination" />.</param>
        <summary>Tries to format the value of the current instance into the provided span of characters.</summary>
        <returns>
          <see langword="true" /> if the formatting was successful; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, out UIntPtr result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TryParse(System.ReadOnlySpan{System.Byte},System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), ByRef result As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * unativeint -&gt; bool" Usage="System.unativeint.TryParse (utf8Text, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, [Runtime::InteropServices::Out] UIntPtr % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">A span containing the UTF-8 characters representing the number to convert.</param>
        <param name="result">When this method returns, contains the unsigned integer value equivalent to the number contained in <paramref name="utf8Text" /> if the conversion succeeded, or zero if the conversion failed. This parameter is passed uninitialized; any value originally supplied in result will be overwritten.</param>
        <summary>Tries to convert a UTF-8 character span containing the string representation of a number to its unsigned integer equivalent.</summary>
        <returns>
          <see langword="true" /> if <paramref name="utf8Text" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out UIntPtr result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TryParse(System.ReadOnlySpan{System.Char},System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * unativeint -&gt; bool" Usage="System.unativeint.TryParse (s, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] UIntPtr % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="1" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A read-only span of characters containing a number to convert.</param>
        <param name="result">When this method returns, contains the unsigned native integer value equivalent of the number contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is empty, is not of the correct format, or represents a number less than <see cref="P:System.UIntPtr.MinValue" /> or greater than <see cref="P:System.UIntPtr.MaxValue" />. This parameter is passed uninitialized; any value originally supplied in result will be overwritten.</param>
        <summary>Converts the read-only span of characters representation of a number to its unsigned native integer equivalent. A return value indicates whether the conversion succeeded.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, out UIntPtr result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TryParse(System.String,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * unativeint -&gt; bool" Usage="System.unativeint.TryParse (s, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] UIntPtr % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="1" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert.</param>
        <param name="result">When this method returns, contains the unsigned native integer value equivalent of the number contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is <see langword="null" /> or empty, is not of the correct format, or represents a number less than <see cref="P:System.UIntPtr.MinValue" /> or greater than <see cref="P:System.UIntPtr.MaxValue" />. This parameter is passed uninitialized; any value originally supplied in result will be overwritten.</param>
        <summary>Converts the string representation of a number to its unsigned native integer equivalent. A return value indicates whether the conversion succeeded.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, IFormatProvider? provider, out UIntPtr result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, class System.IFormatProvider provider, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), provider As IFormatProvider, ByRef result As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * IFormatProvider * unativeint -&gt; bool" Usage="System.unativeint.TryParse (utf8Text, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UIntPtr % result) = IUtf8SpanParsable&lt;UIntPtr&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="2" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanParsable`1.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out UIntPtr result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), provider As IFormatProvider, ByRef result As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IFormatProvider * unativeint -&gt; bool" Usage="System.unativeint.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UIntPtr % result) = ISpanParsable&lt;UIntPtr&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A read-only span of characters containing a number to convert.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, IFormatProvider? provider, out UIntPtr result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, class System.IFormatProvider provider, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TryParse(System.String,System.IFormatProvider,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, provider As IFormatProvider, ByRef result As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IFormatProvider * unativeint -&gt; bool" Usage="System.unativeint.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UIntPtr % result) = IParsable&lt;UIntPtr&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, System.Globalization.NumberStyles style, IFormatProvider? provider, out UIntPtr result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), style As NumberStyles, provider As IFormatProvider, ByRef result As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * System.Globalization.NumberStyles * IFormatProvider * unativeint -&gt; bool" Usage="System.unativeint.TryParse (utf8Text, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UIntPtr % result) = System::Numerics::INumberBase&lt;UIntPtr&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="3" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider, out UIntPtr result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * unativeint -&gt; bool" Usage="System.unativeint.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UIntPtr % result);" FrameworkAlternate="net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UIntPtr % result) = System::Numerics::INumberBase&lt;UIntPtr&gt;::TryParse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="3" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A read-only span of characters containing a number to convert. The span is interpreted using the style specified by <paramref name="style" />.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the unsigned native integer value equivalent of the number contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is empty, is not of the correct format, or represents a number less than <see cref="P:System.UIntPtr.MinValue" /> or greater than <see cref="P:System.UIntPtr.MaxValue" />. This parameter is passed uninitialized; any value originally supplied in result will be overwritten.</param>
        <summary>Converts the read-only span of characters representation of a number in a specified style and culture-specific format to its unsigned native integer equivalent. A return value indicates whether the conversion succeeded.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, System.Globalization.NumberStyles style, IFormatProvider? provider, out UIntPtr result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] native unsigned int&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UIntPtr.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As UIntPtr) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * unativeint -&gt; bool" Usage="System.unativeint.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UIntPtr % result);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UIntPtr % result) = System::Numerics::INumberBase&lt;UIntPtr&gt;::TryParse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.UIntPtr" RefType="out" Index="3" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert. The string is interpreted using the style specified by <paramref name="style" />.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the unsigned native integer value equivalent of the number contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is <see langword="null" /> or empty, is not of the correct format, or represents a number less than <see cref="P:System.UIntPtr.MinValue" /> or greater than <see cref="P:System.UIntPtr.MaxValue" />. This parameter is passed uninitialized; any value originally supplied in result will be overwritten.</param>
        <summary>Converts the string representation of a number in a specified style and culture-specific format to its unsigned native integer equivalent. A return value indicates whether the conversion succeeded.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly UIntPtr Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly native unsigned int Zero" />
      <MemberSignature Language="DocId" Value="F:System.UIntPtr.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As UIntPtr " />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : unativeint" Usage="System.unativeint.Zero" />
      <MemberSignature Language="C++ CLI" Value="public: static initonly UIntPtr Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A read-only field that represents an unsigned integer that has been initialized to zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The value of this field is not equivalent to `null`. Use this field to efficiently determine whether an instance of <xref:System.UIntPtr> has been set to a value other than zero.

 For example, assume the variable, uip, is an instance of <xref:System.UIntPtr>. You can determine if it has been set by comparing it to the value returned by a constructor, for example, `if uip != new UIntPtr(0)...`. However, invoking a constructor to get an uninitialized pointer is inefficient. It is better to code either `if uip != UIntPtr.Zero...` or `if !UIntPtr.Zero.Equals(uip)...`.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
