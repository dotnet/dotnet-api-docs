<Type Name="Math" FullName="System.Math">
  <TypeSignature Language="C#" Value="public static class Math" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Math extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Math" />
  <TypeSignature Language="VB.NET" Value="Public Class Math" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Math = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class Math abstract sealed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public sealed class Math" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Math extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Math" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Math sealed" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.Extensions" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="6.0.0.0" FrameworkAlternate="net-6.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="6.0.0.0" To="System.Runtime" ToVersion="6.0.0.0" FrameworkAlternate="net-6.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example uses several mathematical and trigonometric functions from the <xref:System.Math> class to calculate the inner angles of a trapezoid.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb" id="Snippet1":::  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Abs">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the absolute value of a specified number.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static decimal Abs (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Abs(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Decimal) As Decimal" />
      <MemberSignature Language="F#" Value="static member Abs : decimal -&gt; decimal" Usage="System.Math.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Abs(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than or equal to <see cref="F:System.Decimal.MinValue" />, but less than or equal to <see cref="F:System.Decimal.MaxValue" />.</param>
        <summary>Returns the absolute value of a <see cref="T:System.Decimal" /> number.</summary>
        <returns>A decimal number, x, such that 0 ≤ x ≤ <see cref="F:System.Decimal.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of a <xref:System.Decimal> is its numeric value without its sign. For example, the absolute value of both 1.2 and -1.2 is 1.2.  
  
   
  
## Examples  
 The following example uses the <xref:System.Math.Abs%28System.Decimal%29> method to get the absolute value of a number of <xref:System.Decimal> values.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/Abs1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/Abs1.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Abs : double -&gt; double" Usage="System.Math.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than or equal to <see cref="F:System.Double.MinValue" />, but less than or equal to <see cref="F:System.Double.MaxValue" />.</param>
        <summary>Returns the absolute value of a double-precision floating-point number.</summary>
        <returns>A double-precision floating-point number, x, such that 0 ≤ x ≤ <see cref="F:System.Double.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of a <xref:System.Double> is its numeric value without its sign. For example, the absolute value of both 1.2e03 and -1.2e03 is 1.2e03.  
  
 If `value` is equal to <xref:System.Double.NegativeInfinity> or <xref:System.Double.PositiveInfinity>, the return value is <xref:System.Double.PositiveInfinity>. If `value` is equal to <xref:System.Double.NaN>, the return value is <xref:System.Double.NaN>.  
  
   
  
## Examples  
 The following example uses the <xref:System.Math.Abs%28System.Double%29> method to get the absolute value of a number of <xref:System.Double> values.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs2.vb" id="Snippet2":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static short Abs (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Abs(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Short) As Short" />
      <MemberSignature Language="F#" Value="static member Abs : int16 -&gt; int16" Usage="System.Math.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Abs(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than <see cref="F:System.Int16.MinValue" />, but less than or equal to <see cref="F:System.Int16.MaxValue" />.</param>
        <summary>Returns the absolute value of a 16-bit signed integer.</summary>
        <returns>A 16-bit signed integer, x, such that 0 ≤ x ≤ <see cref="F:System.Int16.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of an <xref:System.Int16> is its numeric value without its sign. For example, the absolute value of both 123 and -123 is 123.  
  
   
  
## Examples  
 The following example uses the <xref:System.Math.Abs%28System.Int16%29> method to get the absolute value of a number of <xref:System.Int16> values.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs3.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs3.vb" id="Snippet3":::  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> equals <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static int Abs (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Abs(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Integer) As Integer" />
      <MemberSignature Language="F#" Value="static member Abs : int -&gt; int" Usage="System.Math.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Abs(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than <see cref="F:System.Int32.MinValue" />, but less than or equal to <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Returns the absolute value of a 32-bit signed integer.</summary>
        <returns>A 32-bit signed integer, x, such that 0 ≤ x ≤ <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of an <xref:System.Int32> is its numeric value without its sign. For example, the absolute value of both 123 and -123 is 123.  
  
   
  
## Examples  
 The following example uses the <xref:System.Math.Abs%28System.Int32%29> method to get the absolute value of a number of <xref:System.Int32> values.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs4.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs4.vb" id="Snippet4":::  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> equals <see cref="F:System.Int32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static long Abs (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Abs(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Long) As Long" />
      <MemberSignature Language="F#" Value="static member Abs : int64 -&gt; int64" Usage="System.Math.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Abs(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than <see cref="F:System.Int64.MinValue" />, but less than or equal to <see cref="F:System.Int64.MaxValue" />.</param>
        <summary>Returns the absolute value of a 64-bit signed integer.</summary>
        <returns>A 64-bit signed integer, x, such that 0 ≤ x ≤ <see cref="F:System.Int64.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of an <xref:System.Int64> is its numeric value without its sign. For example, the absolute value of both 123 and -123 is 123.  
  
   
  
## Examples  
 The following example uses the <xref:System.Math.Abs%28System.Int64%29> method to get the absolute value of a number of <xref:System.Int64> values.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs5.cs" interactive="try-dotnet-method" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs5.vb" id="Snippet5":::  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> equals <see cref="F:System.Int64.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static IntPtr Abs (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Abs(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As IntPtr) As IntPtr" />
      <MemberSignature Language="F#" Value="static member Abs : nativeint -&gt; nativeint" Usage="System.Math.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Abs(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" Index="0" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than <see cref="P:System.IntPtr.MinValue" />, but less than or equal to <see cref="P:System.IntPtr.MaxValue" />.</param>
        <summary>Returns the absolute value of a native signed integer.</summary>
        <returns>A native signed integer, x, such that 0 ≤ x ≤ <see cref="P:System.IntPtr.MaxValue" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static sbyte Abs (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Abs(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As SByte) As SByte" />
      <MemberSignature Language="F#" Value="static member Abs : sbyte -&gt; sbyte" Usage="System.Math.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Abs(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than <see cref="F:System.SByte.MinValue" />, but less than or equal to <see cref="F:System.SByte.MaxValue" />.</param>
        <summary>Returns the absolute value of an 8-bit signed integer.</summary>
        <returns>An 8-bit signed integer, x, such that 0 ≤ x ≤ <see cref="F:System.SByte.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of a signed byte is its numeric value without its sign. For example, the absolute value of both 12 and -12 is 12.  
  
   
  
## Examples  
 The following example uses the <xref:System.Math.Abs%28System.SByte%29> method to get the absolute value of a number of <xref:System.SByte> values.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs6.cs" interactive="try-dotnet-method" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs6.vb" id="Snippet6":::  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> equals <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Single) As Single" />
      <MemberSignature Language="F#" Value="static member Abs : single -&gt; single" Usage="System.Math.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">A number that is greater than or equal to <see cref="F:System.Single.MinValue" />, but less than or equal to <see cref="F:System.Single.MaxValue" />.</param>
        <summary>Returns the absolute value of a single-precision floating-point number.</summary>
        <returns>A single-precision floating-point number, x, such that 0 ≤ x ≤ <see cref="F:System.Single.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The absolute value of a <xref:System.Single> is its numeric value without its sign. For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.  
  
 If `value` is equal to <xref:System.Single.NegativeInfinity> or <xref:System.Single.PositiveInfinity>, the return value is <xref:System.Single.PositiveInfinity>. If `value` is equal to <xref:System.Single.NaN>, the return value is <xref:System.Single.NaN>.  
  
   
  
## Examples  
 The following example uses the <xref:System.Math.Abs%28System.Single%29> method to get the absolute value of a number of <xref:System.Single> values.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs7.cs" interactive="try-dotnet-method" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs7.vb" id="Snippet7":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static double Acos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Acos : double -&gt; double" Usage="System.Math.Acos d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acos(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A number representing a cosine, where <paramref name="d" /> must be greater than or equal to -1, but less than or equal to 1.</param>
        <summary>Returns the angle whose cosine is the specified number.</summary>
        <returns>An angle, θ, measured in radians, such that 0 ≤ θ ≤ π.
  
 -or-  
  
 <see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example uses the <xref:System.Math.Acos%2A> method to assist in the computation of the inner angles of a given trapezoid.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static double Acosh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acosh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Acosh : double -&gt; double" Usage="System.Math.Acosh d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acosh(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="d">A number representing a hyperbolic cosine, where <paramref name="d" /> must be greater than or equal to 1, but less than or equal to <see cref="F:System.Double.PositiveInfinity" />.</param>
        <summary>Returns the angle whose hyperbolic cosine is the specified number.</summary>
        <returns>An angle, θ, measured in radians, such that 0 ≤ θ ≤ ∞.  
  
 -or-  
  
 <see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static double Asin (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asin(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Asin : double -&gt; double" Usage="System.Math.Asin d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asin(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A number representing a sine, where <paramref name="d" /> must be greater than or equal to -1, but less than or equal to 1.</param>
        <summary>Returns the angle whose sine is the specified number.</summary>
        <returns>An angle, θ, measured in radians, such that -π/2 ≤ θ ≤ π/2.
  
 -or-  
  
 <see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.  
  
 Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example uses <xref:System.Math.Asin%2A> to assist in the computation of the inner angles of a given trapezoid.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static double Asinh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asinh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Asinh : double -&gt; double" Usage="System.Math.Asinh d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asinh(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="d">A number representing a hyperbolic sine, where <paramref name="d" /> must be greater than or equal to <see cref="F:System.Double.NegativeInfinity" />, but less than or equal to <see cref="F:System.Double.PositiveInfinity" />.</param>
        <summary>Returns the angle whose hyperbolic sine is the specified number.</summary>
        <returns>An angle, θ, measured in radians, such that -∞ &lt; θ ≤ -1, or 1 ≤ θ &lt; ∞. 
  
 -or-  
  
 <see cref="F:System.Double.NaN" /> if <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static double Atan (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Atan : double -&gt; double" Usage="System.Math.Atan d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A number representing a tangent.</param>
        <summary>Returns the angle whose tangent is the specified number.</summary>
        <returns>An angle, θ, measured in radians, such that -π/2 ≤ θ ≤ π/2.  
  
 -or-  
  
 <see cref="F:System.Double.NaN" /> if <paramref name="d" /> equals <see cref="F:System.Double.NaN" />, -π/2 rounded to double precision (-1.5707963267949) if <paramref name="d" /> equals <see cref="F:System.Double.NegativeInfinity" />, or π/2 rounded to double precision (1.5707963267949) if <paramref name="d" /> equals <see cref="F:System.Double.PositiveInfinity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.  
  
 Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example demonstrates how to calculate the arctangent of a value and display it to the console.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static double Atan2 (double y, double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan2(float64 y, float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan2(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Double, x As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Atan2 : double * double -&gt; double" Usage="System.Math.Atan2 (y, x)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan2(double y, double x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Double" />
        <Parameter Name="x" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="y">The y coordinate of a point.</param>
        <param name="x">The x coordinate of a point.</param>
        <summary>Returns the angle whose tangent is the quotient of two specified numbers.</summary>
        <returns>An angle, θ, measured in radians, such that -π ≤ θ ≤ π, and tan(θ) = <paramref name="y" /> / <paramref name="x" />, where (<paramref name="x" />, <paramref name="y" />) is a point in the Cartesian plane. Observe the following:
  
-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 1, 0 &lt; θ &lt; π/2.  
  
-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 2, π/2 &lt; θ ≤ π.
  
-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 3, -π &lt; θ &lt; -π/2.  
  
-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 4, -π/2 &lt; θ &lt; 0.  
  
 For points on the boundaries of the quadrants, the return value is the following:  
  
-   If y is 0 and x is not negative, θ = 0.  
  
-   If y is 0 and x is negative, θ = π.  
  
-   If y is positive and x is 0, θ = π/2.  
  
-   If y is negative and x is 0, θ = -π/2.  
  
-   If y is 0 and x is 0, θ = 0.  
  
 If <paramref name="x" /> or <paramref name="y" /> is <see cref="F:System.Double.NaN" />, or if <paramref name="x" /> and <paramref name="y" /> are either <see cref="F:System.Double.PositiveInfinity" /> or <see cref="F:System.Double.NegativeInfinity" />, the method returns <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The return value is the angle in the Cartesian plane formed by the x-axis, and a vector starting from the origin, (0,0), and terminating at the point, (x,y).  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example demonstrates how to calculate the arctangent of an angle and a vector. The resulting value is displayed in the console.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static double Atanh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atanh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Atanh : double -&gt; double" Usage="System.Math.Atanh d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atanh(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="d">A number representing a hyperbolic tangent, where <paramref name="d" /> must be greater than or equal to -1, but less than or equal to 1.</param>
        <summary>Returns the angle whose hyperbolic tangent is the specified number.</summary>
        <returns>An angle, θ, measured in radians, such that -∞ &lt; θ &lt; -1, or 1 &lt; θ &lt; ∞. 
  
 -or-  
  
 <see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BigMul">
      <MemberSignature Language="C#" Value="public static long BigMul (int a, int b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 BigMul(int32 a, int32 b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BigMul(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BigMul (a As Integer, b As Integer) As Long" />
      <MemberSignature Language="F#" Value="static member BigMul : int * int -&gt; int64" Usage="System.Math.BigMul (a, b)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long BigMul(int a, int b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="b" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="a">The first number to multiply.</param>
        <param name="b">The second number to multiply.</param>
        <summary>Produces the full product of two 32-bit numbers.</summary>
        <returns>The number containing the product of the specified numbers.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates the use of the <xref:System.Math.BigMul%2A> method to calculate the product of two integer values.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.bigmul/CPP/bigmul.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.bigmul/CS/bigmul.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.bigmul/VB/bigmul.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BigMul">
      <MemberSignature Language="C#" Value="public static long BigMul (long a, long b, out long low);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 BigMul(int64 a, int64 b, [out] int64&amp; low) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BigMul(System.Int64,System.Int64,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BigMul (a As Long, b As Long, ByRef low As Long) As Long" />
      <MemberSignature Language="F#" Value="static member BigMul : int64 * int64 * int64 -&gt; int64" Usage="System.Math.BigMul (a, b, low)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long BigMul(long a, long b, [Runtime::InteropServices::Out] long % low);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int64" Index="0" FrameworkAlternate="net-5.0;net-6.0" />
        <Parameter Name="b" Type="System.Int64" Index="1" FrameworkAlternate="net-5.0;net-6.0" />
        <Parameter Name="low" Type="System.Int64" RefType="out" Index="2" FrameworkAlternate="net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="a">The first number to multiply.</param>
        <param name="b">The second number to multiply.</param>
        <param name="low">The low 64-bit of the product of the specified numbers.</param>
        <summary>Produces the full product of two 64-bit numbers.</summary>
        <returns>The high 64-bit of the product of the specied numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BigMul">
      <MemberSignature Language="C#" Value="public static ulong BigMul (ulong a, ulong b, out ulong low);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 BigMul(unsigned int64 a, unsigned int64 b, [out] unsigned int64&amp; low) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BigMul(System.UInt64,System.UInt64,System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BigMul (a As ULong, b As ULong, ByRef low As ULong) As ULong" />
      <MemberSignature Language="F#" Value="static member BigMul : uint64 * uint64 * uint64 -&gt; uint64" Usage="System.Math.BigMul (a, b, low)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 BigMul(System::UInt64 a, System::UInt64 b, [Runtime::InteropServices::Out] System::UInt64 % low);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;net-6.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.UInt64" Index="0" FrameworkAlternate="net-5.0;net-6.0" />
        <Parameter Name="b" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0;net-6.0" />
        <Parameter Name="low" Type="System.UInt64" RefType="out" Index="2" FrameworkAlternate="net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="a">The first number to multiply.</param>
        <param name="b">The second number to multiply.</param>
        <param name="low">The low 64-bit of the product of the specified numbers.</param>
        <summary>Produces the full product of two unsigned 64-bit numbers.</summary>
        <returns>The high 64-bit of the product of the specied numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitDecrement">
      <MemberSignature Language="C#" Value="public static double BitDecrement (double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 BitDecrement(float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BitDecrement(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitDecrement (x As Double) As Double" />
      <MemberSignature Language="F#" Value="static member BitDecrement : double -&gt; double" Usage="System.Math.BitDecrement x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double BitDecrement(double x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to decrement.</param>
        <summary>Returns the next smallest value that compares less than <paramref name="x" />.</summary>
        <returns>The next smallest value that compares less than <paramref name="x" />.  
  
 -or-  
  
 <see cref="F:System.Double.NegativeInfinity" /> if <paramref name="x" /> equals <see cref="F:System.Double.NegativeInfinity" />.
  
 -or-  
  
 <see cref="F:System.Double.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Double.NaN" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitIncrement">
      <MemberSignature Language="C#" Value="public static double BitIncrement (double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 BitIncrement(float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BitIncrement(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitIncrement (x As Double) As Double" />
      <MemberSignature Language="F#" Value="static member BitIncrement : double -&gt; double" Usage="System.Math.BitIncrement x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double BitIncrement(double x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to increment.</param>
        <summary>Returns the next largest value that compares greater than <paramref name="x" />.</summary>
        <returns>The next largest value that compares greater than <paramref name="x" />.  
  
 -or-  
  
 <see cref="F:System.Double.PositiveInfinity" /> if <paramref name="x" /> equals <see cref="F:System.Double.PositiveInfinity" />.
  
 -or-  
  
 <see cref="F:System.Double.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Double.NaN" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static double Cbrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cbrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cbrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Cbrt : double -&gt; double" Usage="System.Math.Cbrt d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cbrt(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="d">The number whose cube root is to be found.</param>
        <summary>Returns the cube root of a specified number.</summary>
        <returns>The cube root of <paramref name="d" />.  
  
 -or-  
  
 <see cref="F:System.Double.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Ceiling">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the smallest integral value greater than or equal to the specified number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding toward positive infinity.  

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (d As Decimal) As Decimal" />
      <MemberSignature Language="F#" Value="static member Ceiling : decimal -&gt; decimal" Usage="System.Math.Ceiling d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Ceiling(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number.</param>
        <summary>Returns the smallest integral value that is greater than or equal to the specified decimal number.</summary>
        <returns>The smallest integral value that is greater than or equal to <paramref name="d" />. Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding toward positive infinity. In other words, if `d` is positive, the presence of any fractional component causes `d` to be rounded to the next highest integer. If `d` is negative, the rounding operation causes any fractional component of `d` to be discarded. The operation of this method differs from the <xref:System.Math.Floor%28System.Decimal%29> method, which supports rounding toward negative infinity.  
  
## Examples  
 The following example illustrates the <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Floor%28System.Decimal%29> method.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static double Ceiling (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Ceiling(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (a As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Ceiling : double -&gt; double" Usage="System.Math.Ceiling a" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Ceiling(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">A double-precision floating-point number.</param>
        <summary>Returns the smallest integral value that is greater than or equal to the specified double-precision floating-point number.</summary>
        <returns>The smallest integral value that is greater than or equal to <paramref name="a" />. If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, that value is returned. Note that this method returns a <see cref="T:System.Double" /> instead of an integral type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding toward positive infinity. In other words, if `a` is positive, the presence of any fractional component causes `a` to be rounded to the next highest integer. If `a` is negative, the rounding operation causes any fractional component of `a` to be discarded. The operation of this method differs from the <xref:System.Math.Floor%28System.Double%29> method, which supports rounding toward negative infinity.  
  
Starting with Visual Basic 15.8, the performance of Double-to-integer conversion is optimized if you pass the value returned by the `Ceiling` method to the any of the [integral conversion functions](/dotnet/visual-basic/language-reference/functions/conversion-functions), or if the Double value returned by `Ceiling` is automatically converted to an integer with [Option Strict](/dotnet/visual-basic/language-reference/statements/option-strict-statement) set to Off. This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types. The following example illustrates such optimized conversions:
   
```vb
Dim d1 As Double = 1043.75133
Dim i1 As Integer = CInt(Math.Ceiling(d1))        ' Result: 1044

Dim d2 As Double = 7968.4136
Dim i2 As Integer = CInt(Math.Ceiling(d2))        ' Result: 7969
```   

## Examples  
 The following example illustrates the <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Floor%28System.Double%29> method.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb" id="Snippet2":::  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static byte Clamp (byte value, byte min, byte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Clamp(unsigned int8 value, unsigned int8 min, unsigned int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Byte, min As Byte, max As Byte) As Byte" />
      <MemberSignature Language="F#" Value="static member Clamp : byte * byte * byte -&gt; byte" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Clamp(System::Byte value, System::Byte min, System::Byte max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="min" Type="System.Byte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="max" Type="System.Byte" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.  
  
 -or-  
  
 <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
  
 -or-  
  
 <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static decimal Clamp (decimal value, decimal min, decimal max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Clamp(valuetype System.Decimal value, valuetype System.Decimal min, valuetype System.Decimal max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Decimal,System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Decimal, min As Decimal, max As Decimal) As Decimal" />
      <MemberSignature Language="F#" Value="static member Clamp : decimal * decimal * decimal -&gt; decimal" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Clamp(System::Decimal value, System::Decimal min, System::Decimal max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="min" Type="System.Decimal" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="max" Type="System.Decimal" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
  
 -or-  
  
 <paramref name="min" /> if <paramref name="value" /> &lt;<paramref name="min" />.
  
 -or-  
  
 <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static double Clamp (double value, double min, double max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Clamp(float64 value, float64 min, float64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Double, min As Double, max As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Clamp : double * double * double -&gt; double" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Clamp(double value, double min, double max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="min" Type="System.Double" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="max" Type="System.Double" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
  
 -or-  
  
 <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
  
 -or-  
  
 <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
  
 -or-  
  
  <see cref="F:System.Double.NaN" /> if <paramref name="value" /> equals <see cref="F:System.Double.NaN" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static short Clamp (short value, short min, short max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Clamp(int16 value, int16 min, int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int16,System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Short, min As Short, max As Short) As Short" />
      <MemberSignature Language="F#" Value="static member Clamp : int16 * int16 * int16 -&gt; int16" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Clamp(short value, short min, short max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="min" Type="System.Int16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="max" Type="System.Int16" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
  
 -or-  
  
 <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
  
 -or-  
  
 <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static int Clamp (int value, int min, int max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Clamp(int32 value, int32 min, int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Integer, min As Integer, max As Integer) As Integer" />
      <MemberSignature Language="F#" Value="static member Clamp : int * int * int -&gt; int" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Clamp(int value, int min, int max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="min" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="max" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
  
 -or-  
  
 <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
  
 -or-  
  
 <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static long Clamp (long value, long min, long max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Clamp(int64 value, int64 min, int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Long, min As Long, max As Long) As Long" />
      <MemberSignature Language="F#" Value="static member Clamp : int64 * int64 * int64 -&gt; int64" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Clamp(long value, long min, long max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="min" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="max" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
  
 -or-  
  
 <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
  
 -or-  
  
 <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static IntPtr Clamp (IntPtr value, IntPtr min, IntPtr max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Clamp(native int value, native int min, native int max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As IntPtr, min As IntPtr, max As IntPtr) As IntPtr" />
      <MemberSignature Language="F#" Value="static member Clamp : nativeint * nativeint * nativeint -&gt; nativeint" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Clamp(IntPtr value, IntPtr min, IntPtr max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="min" Type="System.IntPtr" Index="1" FrameworkAlternate="net-6.0" />
        <Parameter Name="max" Type="System.IntPtr" Index="2" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
             -or- 
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
             -or- 
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static sbyte Clamp (sbyte value, sbyte min, sbyte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Clamp(int8 value, int8 min, int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.SByte,System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As SByte, min As SByte, max As SByte) As SByte" />
      <MemberSignature Language="F#" Value="static member Clamp : sbyte * sbyte * sbyte -&gt; sbyte" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Clamp(System::SByte value, System::SByte min, System::SByte max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;net-6.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="min" Type="System.SByte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="max" Type="System.SByte" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
  
 -or-  
  
 <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
  
 -or-  
  
 <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static float Clamp (float value, float min, float max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Clamp(float32 value, float32 min, float32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Single, min As Single, max As Single) As Single" />
      <MemberSignature Language="F#" Value="static member Clamp : single * single * single -&gt; single" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Clamp(float value, float min, float max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="min" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="max" Type="System.Single" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.  
  
 -or-  
  
 <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
  
 -or-  
  
 <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
  
 -or-  
  
  <see cref="F:System.Single.NaN" /> if <paramref name="value" /> equals <see cref="F:System.Single.NaN" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ushort Clamp (ushort value, ushort min, ushort max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Clamp(unsigned int16 value, unsigned int16 min, unsigned int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt16,System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UShort, min As UShort, max As UShort) As UShort" />
      <MemberSignature Language="F#" Value="static member Clamp : uint16 * uint16 * uint16 -&gt; uint16" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Clamp(System::UInt16 value, System::UInt16 min, System::UInt16 max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;net-6.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="min" Type="System.UInt16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="max" Type="System.UInt16" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.  
  
 -or-  
  
 <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
  
 -or-  
  
 <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static uint Clamp (uint value, uint min, uint max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Clamp(unsigned int32 value, unsigned int32 min, unsigned int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt32,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UInteger, min As UInteger, max As UInteger) As UInteger" />
      <MemberSignature Language="F#" Value="static member Clamp : uint32 * uint32 * uint32 -&gt; uint32" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Clamp(System::UInt32 value, System::UInt32 min, System::UInt32 max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;net-6.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="min" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="max" Type="System.UInt32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.  
  
 -or-  
  
 <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
  
 -or-  
  
 <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ulong Clamp (ulong value, ulong min, ulong max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Clamp(unsigned int64 value, unsigned int64 min, unsigned int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt64,System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As ULong, min As ULong, max As ULong) As ULong" />
      <MemberSignature Language="F#" Value="static member Clamp : uint64 * uint64 * uint64 -&gt; uint64" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Clamp(System::UInt64 value, System::UInt64 min, System::UInt64 max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;net-6.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="min" Type="System.UInt64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="max" Type="System.UInt64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
  
 -or-  
  
 <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
  
 -or-  
  
 <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static UIntPtr Clamp (UIntPtr value, UIntPtr min, UIntPtr max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Clamp(native unsigned int value, native unsigned int min, native unsigned int max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UIntPtr,System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UIntPtr, min As UIntPtr, max As UIntPtr) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Clamp : unativeint * unativeint * unativeint -&gt; unativeint" Usage="System.Math.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Clamp(UIntPtr value, UIntPtr min, UIntPtr max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="min" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-6.0" />
        <Parameter Name="max" Type="System.UIntPtr" Index="2" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be clamped.</param>
        <param name="min">The lower bound of the result.</param>
        <param name="max">The upper bound of the result.</param>
        <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
        <returns>
          <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
             -or- 
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
             -or- 
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign">
      <MemberSignature Language="C#" Value="public static double CopySign (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CopySign(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.CopySign(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CopySign (x As Double, y As Double) As Double" />
      <MemberSignature Language="F#" Value="static member CopySign : double * double -&gt; double" Usage="System.Math.CopySign (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CopySign(double x, double y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="y" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="x">A number whose magnitude is used in the result.</param>
        <param name="y">A number whose sign is the used in the result.</param>
        <summary>Returns a value with the magnitude of <paramref name="x" /> and the sign of <paramref name="y" />.</summary>
        <returns>A value with the magnitude of <paramref name="x" /> and the sign of <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static double Cos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Cos : double -&gt; double" Usage="System.Math.Cos d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cos(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">An angle, measured in radians.</param>
        <summary>Returns the cosine of the specified angle.</summary>
        <returns>The cosine of <paramref name="d" />. If <paramref name="d" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, `d`, must be in radians. Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example uses <xref:System.Math.Cos%2A> to evaluate certain trigonometric identities for selected angles.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static double Cosh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cosh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Cosh : double -&gt; double" Usage="System.Math.Cosh value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cosh(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">An angle, measured in radians.</param>
        <summary>Returns the hyperbolic cosine of the specified angle.</summary>
        <returns>The hyperbolic cosine of <paramref name="value" />. If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" /> or <see cref="F:System.Double.PositiveInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> is returned. If <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, `value`, must be in radians. Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example uses <xref:System.Math.Cosh%2A> to evaluate certain hyperbolic identities for selected values.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivRem">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calculates the quotient of two numbers and also returns the remainder in an output parameter.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (byte,byte) DivRem (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;unsigned int8, unsigned int8&gt; DivRem(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As Byte, right As Byte) As ValueTuple(Of Byte, Byte)" />
      <MemberSignature Language="F#" Value="static member DivRem : byte * byte -&gt; ValueTuple&lt;byte, byte&gt;" Usage="System.Math.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;System::Byte, System::Byte&gt; DivRem(System::Byte left, System::Byte right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Byte,System.Byte&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="left">The dividend.</param>
        <param name="right">The divisor.</param>
        <summary>Produces the quotient and the remainder of two unsigned 8-bit numbers.</summary>
        <returns>The quotient and the remainder of the specified numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (short,short) DivRem (short left, short right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;int16, int16&gt; DivRem(int16 left, int16 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As Short, right As Short) As ValueTuple(Of Short, Short)" />
      <MemberSignature Language="F#" Value="static member DivRem : int16 * int16 -&gt; ValueTuple&lt;int16, int16&gt;" Usage="System.Math.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;short, short&gt; DivRem(short left, short right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Int16,System.Int16&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int16" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="right" Type="System.Int16" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="left">The dividend.</param>
        <param name="right">The divisor.</param>
        <summary>Produces the quotient and the remainder of two signed 16-bit numbers.</summary>
        <returns>The quotient and the remainder of the specified numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (int,int) DivRem (int left, int right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;int32, int32&gt; DivRem(int32 left, int32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As Integer, right As Integer) As ValueTuple(Of Integer, Integer)" />
      <MemberSignature Language="F#" Value="static member DivRem : int * int -&gt; ValueTuple&lt;int, int&gt;" Usage="System.Math.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;int, int&gt; DivRem(int left, int right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Int32,System.Int32&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="right" Type="System.Int32" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="left">The dividend.</param>
        <param name="right">The divisor.</param>
        <summary>Produces the quotient and the remainder of two signed 32-bit numbers.</summary>
        <returns>The quotient and the remainder of the specified numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (long,long) DivRem (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;int64, int64&gt; DivRem(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As Long, right As Long) As ValueTuple(Of Long, Long)" />
      <MemberSignature Language="F#" Value="static member DivRem : int64 * int64 -&gt; ValueTuple&lt;int64, int64&gt;" Usage="System.Math.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;long, long&gt; DivRem(long left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Int64,System.Int64&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="left">The dividend.</param>
        <param name="right">The divisor.</param>
        <summary>Produces the quotient and the remainder of two signed 64-bit numbers.</summary>
        <returns>The quotient and the remainder of the specified numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (IntPtr,IntPtr) DivRem (IntPtr left, IntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;native int, native int&gt; DivRem(native int left, native int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As IntPtr, right As IntPtr) As ValueTuple(Of IntPtr, IntPtr)" />
      <MemberSignature Language="F#" Value="static member DivRem : nativeint * nativeint -&gt; ValueTuple&lt;nativeint, nativeint&gt;" Usage="System.Math.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;IntPtr, IntPtr&gt; DivRem(IntPtr left, IntPtr right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.IntPtr,System.IntPtr&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.IntPtr" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="right" Type="System.IntPtr" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="left">The dividend.</param>
        <param name="right">The divisor.</param>
        <summary>Produces the quotient and the remainder of two signed native-size numbers.</summary>
        <returns>The quotient and the remainder of the specified numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (sbyte,sbyte) DivRem (sbyte left, sbyte right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;int8, int8&gt; DivRem(int8 left, int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As SByte, right As SByte) As ValueTuple(Of SByte, SByte)" />
      <MemberSignature Language="F#" Value="static member DivRem : sbyte * sbyte -&gt; ValueTuple&lt;sbyte, sbyte&gt;" Usage="System.Math.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;System::SByte, System::SByte&gt; DivRem(System::SByte left, System::SByte right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.SByte,System.SByte&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.SByte" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="right" Type="System.SByte" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="left">The dividend.</param>
        <param name="right">The divisor.</param>
        <summary>Produces the quotient and the remainder of two signed 8-bit numbers.</summary>
        <returns>The quotient and the remainder of the specified numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (ushort,ushort) DivRem (ushort left, ushort right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;unsigned int16, unsigned int16&gt; DivRem(unsigned int16 left, unsigned int16 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As UShort, right As UShort) As ValueTuple(Of UShort, UShort)" />
      <MemberSignature Language="F#" Value="static member DivRem : uint16 * uint16 -&gt; ValueTuple&lt;uint16, uint16&gt;" Usage="System.Math.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;System::UInt16, System::UInt16&gt; DivRem(System::UInt16 left, System::UInt16 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.UInt16,System.UInt16&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt16" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="right" Type="System.UInt16" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="left">The dividend.</param>
        <param name="right">The divisor.</param>
        <summary>Produces the quotient and the remainder of two unsigned 16-bit numbers.</summary>
        <returns>The quotient and the remainder of the specified numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (uint,uint) DivRem (uint left, uint right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;unsigned int32, unsigned int32&gt; DivRem(unsigned int32 left, unsigned int32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As UInteger, right As UInteger) As ValueTuple(Of UInteger, UInteger)" />
      <MemberSignature Language="F#" Value="static member DivRem : uint32 * uint32 -&gt; ValueTuple&lt;uint32, uint32&gt;" Usage="System.Math.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;System::UInt32, System::UInt32&gt; DivRem(System::UInt32 left, System::UInt32 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.UInt32,System.UInt32&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt32" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="right" Type="System.UInt32" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="left">The dividend.</param>
        <param name="right">The divisor.</param>
        <summary>Produces the quotient and the remainder of two unsigned 32-bit numbers.</summary>
        <returns>The quotient and the remainder of the specified numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (ulong,ulong) DivRem (ulong left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;unsigned int64, unsigned int64&gt; DivRem(unsigned int64 left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As ULong, right As ULong) As ValueTuple(Of ULong, ULong)" />
      <MemberSignature Language="F#" Value="static member DivRem : uint64 * uint64 -&gt; ValueTuple&lt;uint64, uint64&gt;" Usage="System.Math.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;System::UInt64, System::UInt64&gt; DivRem(System::UInt64 left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.UInt64,System.UInt64&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="right" Type="System.UInt64" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="left">The dividend.</param>
        <param name="right">The divisor.</param>
        <summary>Produces the quotient and the remainder of two unsigned 64-bit numbers.</summary>
        <returns>The quotient and the remainder of the specified numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (UIntPtr,UIntPtr) DivRem (UIntPtr left, UIntPtr right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;native unsigned int, native unsigned int&gt; DivRem(native unsigned int left, native unsigned int right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As UIntPtr, right As UIntPtr) As ValueTuple(Of UIntPtr, UIntPtr)" />
      <MemberSignature Language="F#" Value="static member DivRem : unativeint * unativeint -&gt; ValueTuple&lt;unativeint, unativeint&gt;" Usage="System.Math.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;UIntPtr, UIntPtr&gt; DivRem(UIntPtr left, UIntPtr right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.UIntPtr,System.UIntPtr&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="right" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="left">The dividend.</param>
        <param name="right">The divisor.</param>
        <summary>Produces the quotient and the remainder of two unsigned native-size numbers.</summary>
        <returns>The quotient and the remainder of the specified numbers.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static int DivRem (int a, int b, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DivRem(int32 a, int32 b, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Integer, b As Integer, ByRef result As Integer) As Integer" />
      <MemberSignature Language="F#" Value="static member DivRem : int * int * int -&gt; int" Usage="System.Math.DivRem (a, b, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int DivRem(int a, int b, [Runtime::InteropServices::Out] int % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="b" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="result" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="a">The dividend.</param>
        <param name="b">The divisor.</param>
        <param name="result">The remainder.</param>
        <summary>Calculates the quotient of two 32-bit signed integers and also returns the remainder in an output parameter.</summary>
        <returns>The quotient of the specified numbers.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The remainder value equals the result of the [remainder operator](/dotnet/csharp/language-reference/operators/remainder-operator).  
   
## Examples  
 The following example demonstrates the <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> method.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem1.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="b" /> is zero.</exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static long DivRem (long a, long b, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 DivRem(int64 a, int64 b, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Long, b As Long, ByRef result As Long) As Long" />
      <MemberSignature Language="F#" Value="static member DivRem : int64 * int64 * int64 -&gt; int64" Usage="System.Math.DivRem (a, b, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long DivRem(long a, long b, [Runtime::InteropServices::Out] long % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="b" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="a">The dividend.</param>
        <param name="b">The divisor.</param>
        <param name="result">The remainder.</param>
        <summary>Calculates the quotient of two 64-bit signed integers and also returns the remainder in an output parameter.</summary>
        <returns>The quotient of the specified numbers.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The remainder value equals the result of the [remainder operator](/dotnet/csharp/language-reference/operators/remainder-operator).  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> method.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem2.vb" id="Snippet2":::  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="b" /> is zero.</exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const double E = 2.7182818284590451;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 E = (2.7182818284590451)" />
      <MemberSignature Language="DocId" Value="F:System.Math.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Double  = 2.7182818284590451" />
      <MemberSignature Language="F#" Value="val mutable E : double" Usage="System.Math.E" />
      <MemberSignature Language="C++ CLI" Value="public: double E = 2.7182818284590451;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>2.7182818284590451</MemberValue>
      <Docs>
        <summary>Represents the natural logarithmic base, specified by the constant, <see langword="e" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The value of this field is 2.7182818284590451.  
  
   
  
## Examples  
 The following example compares <xref:System.Math.E> with the value calculated from a power series.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.E/CPP/efield.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.E/CS/efield.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.E/VB/efield.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static double Exp (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exp(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Exp(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Exp : double -&gt; double" Usage="System.Math.Exp d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exp(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A number specifying a power.</param>
        <summary>Returns <see langword="e" /> raised to the specified power.</summary>
        <returns>The number <see langword="e" /> raised to the power <paramref name="d" />. If <paramref name="d" /> equals <see cref="F:System.Double.NaN" /> or <see cref="F:System.Double.PositiveInfinity" />, that value is returned. If <paramref name="d" /> equals <see cref="F:System.Double.NegativeInfinity" />, 0 is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e` is a mathematical constant whose value is approximately 2.71828.  
  
 Use the <xref:System.Math.Pow%2A> method to calculate powers of other bases.  
  
 <xref:System.Math.Exp%2A> is the inverse of <xref:System.Math.Log%2A>.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example uses <xref:System.Math.Exp%2A> to evaluate certain exponential and logarithmic identities for selected values.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Exp/CPP/exp.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Exp/CS/exp.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Exp/VB/exp.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
        <altmember cref="M:System.Math.Log(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Floor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the largest integral value less than or equal to the specified number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding toward negative infinity.  

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Decimal) As Decimal" />
      <MemberSignature Language="F#" Value="static member Floor : decimal -&gt; decimal" Usage="System.Math.Floor d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Floor(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number.</param>
        <summary>Returns the largest integral value less than or equal to the specified decimal number.</summary>
        <returns>The largest integral value less than or equal to <paramref name="d" />.  Note that the method returns an integral value of type <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding toward negative infinity. In other words, if `d` is positive, any fractional component is truncated. If `d` is negative, the presence of any fractional component causes it to be rounded to the smaller integer. The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.  

## Examples  
 The following example illustrates the <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Ceiling%28System.Decimal%29> method.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static double Floor (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Floor(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Floor : double -&gt; double" Usage="System.Math.Floor d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Floor(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A double-precision floating-point number.</param>
        <summary>Returns the largest integral value less than or equal to the specified double-precision floating-point number.</summary>
        <returns>The largest integral value less than or equal to <paramref name="d" />. If <paramref name="d" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding toward negative infinity. In other words, if `d` is positive, any fractional component is truncated. If `d` is negative, the presence of any fractional component causes it to be rounded to the smaller integer. The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.  

Starting with Visual Basic 15.8, the performance of Double-to-integer conversion is optimized if you pass the value returned by the `Floor` method to the any of the [integral conversion functions](/dotnet/visual-basic/language-reference/functions/conversion-functions), or if the Double value returned by `Floor` is automatically converted to an integer with [Option Strict](/dotnet/visual-basic/language-reference/statements/option-strict-statement) set to Off. This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types. The following example illustrates such optimized conversions:
   
```vb
Dim d1 As Double = 1043.75133
Dim i1 As Integer = CInt(Math.Ceiling(d1))        ' Result: 1043

Dim d2 As Double = 7968.4136
Dim i2 As Integer = CInt(Math.Ceiling(d2))        ' Result: 7968
```

## Examples  
 The following example illustrates the <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Ceiling%28System.Double%29> method.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb" id="Snippet2":::  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd">
      <MemberSignature Language="C#" Value="public static double FusedMultiplyAdd (double x, double y, double z);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 FusedMultiplyAdd(float64 x, float64 y, float64 z) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.FusedMultiplyAdd(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FusedMultiplyAdd (x As Double, y As Double, z As Double) As Double" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : double * double * double -&gt; double" Usage="System.Math.FusedMultiplyAdd (x, y, z)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double FusedMultiplyAdd(double x, double y, double z);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="y" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="z" Type="System.Double" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="x">The number to be multiplied with <paramref name="y" />.</param>
        <param name="y">The number to be multiplied with <paramref name="x" />.</param>
        <param name="z">The number to be added to the result of <paramref name="x" /> multiplied by <paramref name="y" />.</param>
        <summary>Returns (x * y) + z, rounded as one ternary operation.</summary>
        <returns>(x * y) + z, rounded as one ternary operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This computes `(x * y)` as if to infinite precision, adds `z` to that result as if to infinite precision, and finally rounds to the nearest representable value.
  
 This differs from the non-fused sequence which would compute `(x * y)` as if to infinite precision, round the result to the nearest representable value, add `z` to the rounded result as if to infinite precision, and finally round to the nearest representable value.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static double IEEERemainder (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 IEEERemainder(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Double, y As Double) As Double" />
      <MemberSignature Language="F#" Value="static member IEEERemainder : double * double -&gt; double" Usage="System.Math.IEEERemainder (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double IEEERemainder(double x, double y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">A dividend.</param>
        <param name="y">A divisor.</param>
        <summary>Returns the remainder resulting from the division of a specified number by another specified number.</summary>
        <returns>A number equal to <paramref name="x" /> - (<paramref name="y" /> Q), where Q is the quotient of <paramref name="x" /> / <paramref name="y" /> rounded to the nearest integer (if <paramref name="x" /> / <paramref name="y" /> falls halfway between two integers, the even integer is returned).  
  
 If <paramref name="x" /> - (<paramref name="y" /> Q) is zero, the value +0 is returned if <paramref name="x" /> is positive, or -0 if <paramref name="x" /> is negative.  
  
 If <paramref name="y" /> = 0, <see cref="F:System.Double.NaN" /> is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This operation complies with the remainder operation defined in Section 5.1 of ANSI/IEEE Std 754-1985; IEEE Standard for Binary Floating-Point Arithmetic; Institute of Electrical and Electronics Engineers, Inc; 1985.  
  
 The <xref:System.Math.IEEERemainder%2A> method is not the same as the [remainder operator](/dotnet/csharp/language-reference/operators/remainder-operator). Although both return the remainder after division, the formulas they use are different. The formula for the <xref:System.Math.IEEERemainder%2A> method is:  
  
```  
IEEERemainder = dividend - (divisor * Math.Round(dividend / divisor))  
```  
  
 In contrast, the formula for the remainder operator is:  
  
```  
Remainder = (Math.Abs(dividend) - (Math.Abs(divisor) *   
            (Math.Floor(Math.Abs(dividend) / Math.Abs(divisor))))) *   
            Math.Sign(dividend)  
```  
  
   
  
## Examples  
 The following example contrasts the remainder returned by the <xref:System.Math.IEEERemainder%2A> method with the remainder returned by the [remainder operator](/dotnet/csharp/language-reference/operators/remainder-operator).  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.ieeeremainder/cs/ieeeremainder1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.ieeeremainder/vb/ieeeremainder1.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB">
      <MemberSignature Language="C#" Value="public static int ILogB (double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ILogB(float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.ILogB(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ILogB (x As Double) As Integer" />
      <MemberSignature Language="F#" Value="static member ILogB : double -&gt; int" Usage="System.Math.ILogB x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ILogB(double x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="x">The number whose logarithm is to be found.</param>
        <summary>Returns the base 2 integer logarithm of a specified number.</summary>
        <returns>One of the values in the following table.  
  
 <list type="table"><listheader><term><paramref name="x" /> parameter  
  
 </term><description> Return value  
  
 </description></listheader><item><term> Default
  
 </term><description> The base 2 integer log of <paramref name="x" />; that is, (int)log2(<paramref name="x" />).  
  
 </description></item><item><term> Zero  
  
 </term><description><see cref="F:System.Int32.MinValue" /></description></item><item><term> Equal to <see cref="F:System.Double.NaN" /> or <see cref="F:System.Double.PositiveInfinity" /> or <see cref="F:System.Double.NegativeInfinity" /></term><description><see cref="F:System.Int32.MaxValue" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `x` is specified as a base 10 number.   
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the logarithm of a specified number.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Log : double -&gt; double" Usage="System.Math.Log d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">The number whose logarithm is to be found.</param>
        <summary>Returns the natural (base <see langword="e" />) logarithm of a specified number.</summary>
        <returns>One of the values in the following table.  
  
 <list type="table"><listheader><term><paramref name="d" /> parameter  
  
 </term><description> Return value  
  
 </description></listheader><item><term> Positive  
  
 </term><description> The natural logarithm of <paramref name="d" />; that is, ln <paramref name="d" />, or log e <paramref name="d" /></description></item><item><term> Zero  
  
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Negative  
  
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equal to <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equal to <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `d` is specified as a base 10 number.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example illustrates the <xref:System.Math.Log%2A> method.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/log1.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/log1.vb" id="Snippet2":::  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double a, double newBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 a, float64 newBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (a As Double, newBase As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Log : double * double -&gt; double" Usage="System.Math.Log (a, newBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double a, double newBase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
        <Parameter Name="newBase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">The number whose logarithm is to be found.</param>
        <param name="newBase">The base of the logarithm.</param>
        <summary>Returns the logarithm of a specified number in a specified base.</summary>
        <returns>One of the values in the following table. (+Infinity denotes <see cref="F:System.Double.PositiveInfinity" />, -Infinity denotes <see cref="F:System.Double.NegativeInfinity" />, and NaN denotes <see cref="F:System.Double.NaN" />.)  
  
 <list type="table"><listheader><term><paramref name="a" /></term><description><paramref name="newBase" /></description><description> Return value  
  
 </description></listheader><item><term><paramref name="a" />&gt; 0  
  
 </term><description> (0 &lt;<paramref name="newBase" />&lt; 1) -or-(<paramref name="newBase" />&gt; 1)  
  
 </description><description> lognewBase(a)  
  
 </description></item><item><term><paramref name="a" />&lt; 0  
  
 </term><description> (any value)  
  
 </description><description> NaN  
  
 </description></item><item><term> (any value)  
  
 </term><description><paramref name="newBase" />&lt; 0  
  
 </description><description> NaN  
  
 </description></item><item><term><paramref name="a" /> != 1  
  
 </term><description><paramref name="newBase" /> = 0  
  
 </description><description> NaN  
  
 </description></item><item><term><paramref name="a" /> != 1  
  
 </term><description><paramref name="newBase" /> = +Infinity  
  
 </description><description> NaN  
  
 </description></item><item><term><paramref name="a" /> = NaN  
  
 </term><description> (any value)  
  
 </description><description> NaN  
  
 </description></item><item><term> (any value)  
  
 </term><description><paramref name="newBase" /> = NaN  
  
 </description><description> NaN  
  
 </description></item><item><term> (any value)  
  
 </term><description><paramref name="newBase" /> = 1  
  
 </description><description> NaN  
  
 </description></item><item><term><paramref name="a" /> = 0  
  
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1  
  
 </description><description> +Infinity  
  
 </description></item><item><term><paramref name="a" /> = 0  
  
 </term><description><paramref name="newBase" />&gt; 1  
  
 </description><description> -Infinity  
  
 </description></item><item><term><paramref name="a" /> =  +Infinity  
  
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1  
  
 </description><description> -Infinity  
  
 </description></item><item><term><paramref name="a" /> =  +Infinity  
  
 </term><description><paramref name="newBase" />&gt; 1  
  
 </description><description> +Infinity  
  
 </description></item><item><term><paramref name="a" /> = 1  
  
 </term><description><paramref name="newBase" /> = 0  
  
 </description><description> 0  
  
 </description></item><item><term><paramref name="a" /> = 1  
  
 </term><description><paramref name="newBase" /> = +Infinity  
  
 </description><description> 0  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example uses <xref:System.Math.Log%2A> to evaluate certain logarithmic identities for selected values.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CPP/loggen.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/loggen.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/loggen.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log10(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Log10 : double -&gt; double" Usage="System.Math.Log10 d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">A number whose logarithm is to be found.</param>
        <summary>Returns the base 10 logarithm of a specified number.</summary>
        <returns>One of the values in the following table.  
  
 <list type="table"><listheader><term><paramref name="d" /> parameter  
  
 </term><description> Return value  
  
 </description></listheader><item><term> Positive  
  
 </term><description> The base 10 log of <paramref name="d" />; that is, log 10<paramref name="d" />.  
  
 </description></item><item><term> Zero  
  
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Negative  
  
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equal to <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equal to <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `d` is specified as a base 10 number.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example uses the <xref:System.Math.Log10%2A> method to return the base 10 logarithm for selected values.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log10/CS/log10.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log10/VB/log10.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static double Log2 (double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log2(float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log2(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (x As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Log2 : double -&gt; double" Usage="System.Math.Log2 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log2(double x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="x">A number whose logarithm is to be found.</param>
        <summary>Returns the base 2 logarithm of a specified number.</summary>
        <returns>One of the values in the following table.  
  
 <list type="table"><listheader><term><paramref name="x" /> parameter  
  
 </term><description> Return value  
  
 </description></listheader><item><term> Positive  
  
 </term><description> The base 2 log of <paramref name="x" />; that is, log 2<paramref name="x" />.  
  
 </description></item><item><term> Zero  
  
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Negative  
  
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equal to <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equal to <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `x` is specified as a base 10 number.   
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the larger of two specified numbers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples

The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables:

:::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp" id="Snippet1":::
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs" interactive="try-dotnet-method" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static byte Max (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Max(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="F#" Value="static member Max : byte * byte -&gt; byte" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Max(System::Byte val1, System::Byte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 8-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 8-bit unsigned integers to compare.</param>
        <summary>Returns the larger of two 8-bit unsigned integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="F#" Value="static member Max : decimal * decimal -&gt; decimal" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Max(System::Decimal val1, System::Decimal val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two decimal numbers to compare.</param>
        <param name="val2">The second of two decimal numbers to compare.</param>
        <summary>Returns the larger of two decimal numbers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Max : double * double -&gt; double" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Max(double val1, double val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two double-precision floating-point numbers to compare.</param>
        <param name="val2">The second of two double-precision floating-point numbers to compare.</param>
        <summary>Returns the larger of two double-precision floating-point numbers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger. If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static short Max (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Max(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="F#" Value="static member Max : int16 * int16 -&gt; int16" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Max(short val1, short val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 16-bit signed integers to compare.</param>
        <param name="val2">The second of two 16-bit signed integers to compare.</param>
        <summary>Returns the larger of two 16-bit signed integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="F#" Value="static member Max : int * int -&gt; int" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Max(int val1, int val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 32-bit signed integers to compare.</param>
        <param name="val2">The second of two 32-bit signed integers to compare.</param>
        <summary>Returns the larger of two 32-bit signed integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="F#" Value="static member Max : int64 * int64 -&gt; int64" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Max(long val1, long val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 64-bit signed integers to compare.</param>
        <param name="val2">The second of two 64-bit signed integers to compare.</param>
        <summary>Returns the larger of two 64-bit signed integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static IntPtr Max (IntPtr val1, IntPtr val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Max(native int val1, native int val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As IntPtr, val2 As IntPtr) As IntPtr" />
      <MemberSignature Language="F#" Value="static member Max : nativeint * nativeint -&gt; nativeint" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Max(IntPtr val1, IntPtr val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.IntPtr" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="val2" Type="System.IntPtr" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two native signed integers to compare.</param>
        <param name="val2">The second of two native signed integers to compare.</param>
        <summary>Returns the larger of two native signed integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static sbyte Max (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Max(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="F#" Value="static member Max : sbyte * sbyte -&gt; sbyte" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Max(System::SByte val1, System::SByte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 8-bit signed integers to compare.</param>
        <param name="val2">The second of two 8-bit signed integers to compare.</param>
        <summary>Returns the larger of two 8-bit signed integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="F#" Value="static member Max : single * single -&gt; single" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float val1, float val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two single-precision floating-point numbers to compare.</param>
        <param name="val2">The second of two single-precision floating-point numbers to compare.</param>
        <summary>Returns the larger of two single-precision floating-point numbers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger. If <paramref name="val1" />, or <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ushort Max (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Max(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="F#" Value="static member Max : uint16 * uint16 -&gt; uint16" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Max(System::UInt16 val1, System::UInt16 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 16-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 16-bit unsigned integers to compare.</param>
        <summary>Returns the larger of two 16-bit unsigned integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static uint Max (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Max(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="F#" Value="static member Max : uint32 * uint32 -&gt; uint32" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Max(System::UInt32 val1, System::UInt32 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 32-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 32-bit unsigned integers to compare.</param>
        <summary>Returns the larger of two 32-bit unsigned integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ulong Max (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Max(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="F#" Value="static member Max : uint64 * uint64 -&gt; uint64" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Max(System::UInt64 val1, System::UInt64 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 64-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 64-bit unsigned integers to compare.</param>
        <summary>Returns the larger of two 64-bit unsigned integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static UIntPtr Max (UIntPtr val1, UIntPtr val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Max(native unsigned int val1, native unsigned int val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UIntPtr, val2 As UIntPtr) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Max : unativeint * unativeint -&gt; unativeint" Usage="System.Math.Max (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Max(UIntPtr val1, UIntPtr val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="val2" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two native unsigned integers to compare.</param>
        <param name="val2">The second of two native unsigned integers to compare.</param>
        <summary>Returns the larger of two native unsigned integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static double MaxMagnitude (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 MaxMagnitude(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.MaxMagnitude(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As Double, y As Double) As Double" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : double * double -&gt; double" Usage="System.Math.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double MaxMagnitude(double x, double y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="y" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="x">The first of two double-precision floating-point numbers to compare.</param>
        <param name="y">The second of two double-precision floating-point numbers to compare.</param>
        <summary>Returns the larger magnitude of two double-precision floating-point numbers.</summary>
        <returns>Parameter <paramref name="x" /> or <paramref name="y" />, whichever has the larger magnitude. If <paramref name="x" />, or <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the smaller of two numbers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Examples

The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables:

:::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp" id="Snippet1":::
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs" interactive="try-dotnet-method" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static byte Min (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Min(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="F#" Value="static member Min : byte * byte -&gt; byte" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Min(System::Byte val1, System::Byte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 8-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 8-bit unsigned integers to compare.</param>
        <summary>Returns the smaller of two 8-bit unsigned integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="F#" Value="static member Min : decimal * decimal -&gt; decimal" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Min(System::Decimal val1, System::Decimal val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two decimal numbers to compare.</param>
        <param name="val2">The second of two decimal numbers to compare.</param>
        <summary>Returns the smaller of two decimal numbers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Min : double * double -&gt; double" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Min(double val1, double val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two double-precision floating-point numbers to compare.</param>
        <param name="val2">The second of two double-precision floating-point numbers to compare.</param>
        <summary>Returns the smaller of two double-precision floating-point numbers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller. If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static short Min (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Min(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="F#" Value="static member Min : int16 * int16 -&gt; int16" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Min(short val1, short val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 16-bit signed integers to compare.</param>
        <param name="val2">The second of two 16-bit signed integers to compare.</param>
        <summary>Returns the smaller of two 16-bit signed integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="F#" Value="static member Min : int * int -&gt; int" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Min(int val1, int val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 32-bit signed integers to compare.</param>
        <param name="val2">The second of two 32-bit signed integers to compare.</param>
        <summary>Returns the smaller of two 32-bit signed integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="F#" Value="static member Min : int64 * int64 -&gt; int64" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Min(long val1, long val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 64-bit signed integers to compare.</param>
        <param name="val2">The second of two 64-bit signed integers to compare.</param>
        <summary>Returns the smaller of two 64-bit signed integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static IntPtr Min (IntPtr val1, IntPtr val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Min(native int val1, native int val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As IntPtr, val2 As IntPtr) As IntPtr" />
      <MemberSignature Language="F#" Value="static member Min : nativeint * nativeint -&gt; nativeint" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Min(IntPtr val1, IntPtr val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.IntPtr" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="val2" Type="System.IntPtr" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two native signed integers to compare.</param>
        <param name="val2">The second of two native signed integers to compare.</param>
        <summary>Returns the smaller of two native signed integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static sbyte Min (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Min(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="F#" Value="static member Min : sbyte * sbyte -&gt; sbyte" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Min(System::SByte val1, System::SByte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 8-bit signed integers to compare.</param>
        <param name="val2">The second of two 8-bit signed integers to compare.</param>
        <summary>Returns the smaller of two 8-bit signed integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="F#" Value="static member Min : single * single -&gt; single" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float val1, float val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two single-precision floating-point numbers to compare.</param>
        <param name="val2">The second of two single-precision floating-point numbers to compare.</param>
        <summary>Returns the smaller of two single-precision floating-point numbers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller. If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ushort Min (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Min(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="F#" Value="static member Min : uint16 * uint16 -&gt; uint16" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Min(System::UInt16 val1, System::UInt16 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 16-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 16-bit unsigned integers to compare.</param>
        <summary>Returns the smaller of two 16-bit unsigned integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static uint Min (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Min(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="F#" Value="static member Min : uint32 * uint32 -&gt; uint32" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Min(System::UInt32 val1, System::UInt32 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 32-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 32-bit unsigned integers to compare.</param>
        <summary>Returns the smaller of two 32-bit unsigned integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ulong Min (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Min(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="F#" Value="static member Min : uint64 * uint64 -&gt; uint64" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Min(System::UInt64 val1, System::UInt64 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two 64-bit unsigned integers to compare.</param>
        <param name="val2">The second of two 64-bit unsigned integers to compare.</param>
        <summary>Returns the smaller of two 64-bit unsigned integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static UIntPtr Min (UIntPtr val1, UIntPtr val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int Min(native unsigned int val1, native unsigned int val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UIntPtr,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UIntPtr, val2 As UIntPtr) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member Min : unativeint * unativeint -&gt; unativeint" Usage="System.Math.Min (val1, val2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr Min(UIntPtr val1, UIntPtr val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-6.0" />
        <Parameter Name="val2" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="val1">The first of two native unsigned integers to compare.</param>
        <param name="val2">The second of two native unsigned integers to compare.</param>
        <summary>Returns the smaller of two native unsigned integers.</summary>
        <returns>Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static double MinMagnitude (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 MinMagnitude(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.MinMagnitude(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As Double, y As Double) As Double" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : double * double -&gt; double" Usage="System.Math.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double MinMagnitude(double x, double y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="y" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="x">The first of two double-precision floating-point numbers to compare.</param>
        <param name="y">The second of two double-precision floating-point numbers to compare.</param>
        <summary>Returns the smaller magnitude of two double-precision floating-point numbers.</summary>
        <returns>Parameter <paramref name="x" /> or <paramref name="y" />, whichever has the smaller magnitude. If <paramref name="x" />, or <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const double PI = 3.1415926535897931;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PI = (3.1415926535897931)" />
      <MemberSignature Language="DocId" Value="F:System.Math.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Double  = 3.1415926535897931" />
      <MemberSignature Language="F#" Value="val mutable PI : double" Usage="System.Math.PI" />
      <MemberSignature Language="C++ CLI" Value="public: double PI = 3.1415926535897931;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>3.1415926535897931</MemberValue>
      <Docs>
        <summary>Represents the ratio of the circumference of a circle to its diameter, specified by the constant, π.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The value of this field is 3.1415926535897931.  
  
   
  
## Examples  
 The following example uses <xref:System.Math.PI> to assist in the computation of the inner angles of a given trapezoid.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static double Pow (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Pow(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Pow(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Double, y As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Pow : double * double -&gt; double" Usage="System.Math.Pow (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Pow(double x, double y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">A double-precision floating-point number to be raised to a power.</param>
        <param name="y">A double-precision floating-point number that specifies a power.</param>
        <summary>Returns a specified number raised to the specified power.</summary>
        <returns>The number <paramref name="x" /> raised to the power <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The following table indicates the return value when various values or ranges of values are specified for the `x` and `y` parameters. For more information, see <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
|Parameters|Return value|  
|----------------|------------------|  
|`x` or `y` = `NaN`.|`NaN`|  
|`x` = Any value except `NaN`; `y` = 0.|1|  
|`x` = `NegativeInfinity`; `y` < 0.|0|  
|`x` = `NegativeInfinity`; `y` is a positive odd integer.|`NegativeInfinity`|  
|`x` = `NegativeInfinity`; `y` is positive but not an odd integer.|`PositiveInfinity`|  
|`x` < 0 but not `NegativeInfinity`; `y` is not an integer, `NegativeInfinity`, or `PositiveInfinity`.|`NaN`|  
|`x` = -1; `y` = `NegativeInfinity` or `PositiveInfinity`.|`NaN`|  
|-1 < `x` < 1; `y` = `NegativeInfinity`.|`PositiveInfinity`|  
|-1 < `x` < 1; `y` = `PositiveInfinity`.|0|  
|`x` < -1 or `x` > 1; `y` = `NegativeInfinity`.|0|  
|`x` < -1 or `x` > 1; `y` = `PositiveInfinity`.|`PositiveInfinity`|  
|`x` = 0; `y` < 0.|`PositiveInfinity`|  
|`x` = 0; `y` > 0.|0|  
|`x` = 1; `y` is any value except `NaN`.|1|  
|`x` = `PositiveInfinity`; `y` < 0.|0|  
|`x` = `PositiveInfinity`; `y` > 0.|`PositiveInfinity`|  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  

 The following example uses the <xref:System.Math.Pow%2A> method to calculate the value that results from raising 2 to a power ranging from 0 to 32.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.pow/cs/pow1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.pow/vb/pow1.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sqrt(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="ReciprocalEstimate">
      <MemberSignature Language="C#" Value="public static double ReciprocalEstimate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ReciprocalEstimate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.ReciprocalEstimate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReciprocalEstimate (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member ReciprocalEstimate : double -&gt; double" Usage="System.Math.ReciprocalEstimate d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ReciprocalEstimate(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="d">The number whose reciprocal is to be estimated.</param>
        <summary>Returns an estimate of the reciprocal of a specified number.</summary>
        <returns>An estimate of the reciprocal of <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

On ARM64 hardware this may use the `FRECPE` instruction which performs a single Newton-Raphson iteration.

On hardware without specialized support, this may just return `1.0 / d`.



          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReciprocalSqrtEstimate">
      <MemberSignature Language="C#" Value="public static double ReciprocalSqrtEstimate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ReciprocalSqrtEstimate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.ReciprocalSqrtEstimate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReciprocalSqrtEstimate (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member ReciprocalSqrtEstimate : double -&gt; double" Usage="System.Math.ReciprocalSqrtEstimate d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ReciprocalSqrtEstimate(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="d">The number whose reciprocal square root is to be estimated.</param>
        <summary>Returns an estimate of the reciprocal square root of a specified number.</summary>
        <returns>An estimate of the reciprocal square root <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

On ARM64 hardware this may use the `FRSQRTE` instruction which performs a single Newton-Raphson iteration.

On hardware without specialized support, this may just return `1.0 / Sqrt(d)`.



          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Round">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rounds a value to the nearest integer or to the specified number of fractional digits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-round"></a> 
## Remarks 

In this section:

- [Which method do I call?](#which-method-do-i-call)
- [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions)   
- [Rounding and precision](#rounding-and-precision) 
- [Rounding and single-precision floating point values](#rounding-and-single-precision-floating-point-values)
- [Examples of individual overloads](#round-examples)

### Which method do I call?

You can use the following table to select an appropriate rounding method. In addition to the `Math.Round` methods, it also includes <xref:System.Math.Ceiling%2A?displayProperty=nameWithType> and <xref:System.Math.Floor%2A?displayProperty=nameWithType>.

|To|Call|  
|--------|----------|  
|Round a number to an integer by using the rounding-to-nearest convention.|<xref:System.Math.Round%28System.Decimal%29><br /><br /> -or-<br /><br /> <xref:System.Math.Round%28System.Double%29>|  
|Round a number to an integer by using a specified rounding convention.|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> -or-<br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|  
|Round a number to a specified number of fractional digits by using the rounding to nearest convention.|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> -or-<br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|  
|Round a number to a specified number of fractional digits by using a specified rounding convention.|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> -or-<br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|Round a <xref:System.Single> value to a specified number of fractional digits by using a specified rounding convention and minimizing the loss of precision.|Convert the <xref:System.Single> to a <xref:System.Decimal> and call <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>.|  
|Round a number to a specified number of fractional digits while minimizing problems of precision in rounding midpoint values.|Call a rounding method that implements a "greater than or approximately equal to" comparison. See [Rounding and precision](#precision).|  
|Round a fractional value to an integer that is greater than the fractional value. For example, round 3.1 to 4.|<xref:System.Math.Ceiling%2A>|  
|Round a fractional value to an integer that is less than the fractional value. For example, round 3.9 to 3.|<xref:System.Math.Floor%2A>|  

### Midpoint values and rounding conventions 

Rounding involves converting a numeric value with a specified precision to a value with less precision. For example, you can use the <xref:System.Math.Round%28System.Double%29> method to round a value of 3.4 to 3.0, and the <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> method to round a value of 3.579 to 3.58.  
  
In a midpoint value, the value after the least significant digit in the result is precisely half way between two numbers. For example, 3.47500 is a midpoint value if it is to be rounded to two decimal places, and 7.500 is a midpoint value if it is to be rounded to an integer. In these cases, if the round-to-nearest strategy is used, the nearest value can't be easily identified without a rounding convention.

The <xref:System.Math.Round%2A> method supports two rounding conventions for handling midpoint values:  
  
- **Rounding away from zero**  

   Midpoint values are rounded to the next number away from zero. For example, 3.75 rounds to 3.8, 3.85 rounds to 3.9, -3.75 rounds to -3.8, and -3.85 rounds to -3.9. This form of rounding is represented by the <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> enumeration member.

- **Rounding to nearest even, or banker's rounding**  

   Midpoint values are rounded to the nearest even number. For example, both 3.75 and 3.85 round to 3.8, and both -3.75 and -3.85 round to -3.8. This form of rounding is represented by the <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> enumeration member.

> [!NOTE]
> In .NET Core 3.0 and later versions, three additional rounding strategies are availble through the <xref:System.MidpointRounding> enumeration. These strategies are used in all cases, not just for midpoint values as <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> and <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> are.

Rounding away from zero is the most widely known form of rounding, while rounding to nearest even is the standard in financial and statistical operations. It conforms to IEEE Standard 754, section 4. When used in multiple rounding operations, rounding to nearest even reduces the rounding error that is caused by consistently rounding midpoint values in a single direction. In some cases, this rounding error can be significant.  
  
The following example illustrates the bias that can result from consistently rounding midpoint values in a single direction. The example computes the true mean of an array of <xref:System.Decimal> values, and then computes the mean when the values in the array are rounded by using the two conventions. In this example, the true mean and the mean that results when rounding to nearest are the same. However, the mean that results when rounding away from zero differs by .05 (or by 3.6%) from the true mean.  
  
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mean1.cs" interactive="try-dotnet-method" id="Snippet2":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mean1.vb" id="Snippet2":::  
  
By default, the <xref:System.Math.Round%2A> method uses the round to nearest even convention. The following table lists the overloads of the <xref:System.Math.Round%2A> method and the rounding convention that each uses.  
  
|Overload|Rounding convention|  
|--------------|-------------------------|  
|<xref:System.Math.Round%28System.Decimal%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29>|Determined by `mode` parameter.|  
|<xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|Determined by `mode` parameter|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|Determined by `mode` parameter|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|Determined by `mode` parameter|  

<a name="precision"></a>
### Rounding and precision  

In order to determine whether a rounding operation involves a midpoint value, the <xref:System.Math.Round%2A> method multiplies the original value to be rounded by 10<sup>n</sup>, where *n* is the desired number of fractional digits in the return value, and then determines whether the remaining fractional portion of the value is greater than or equal to .5. This is a slight variation on a test for equality, and as discussed in the "Testing for Equality" section of the <xref:System.Double> reference topic, tests for equality with floating-point values are problematic because of the floating-point format's issues with binary representation and precision. This means that any fractional portion of a number that is slightly less than .5 (because of a loss of precision) will not be rounded upward.

The following example illustrates the problem. It repeatedly adds .1 to 11.0 and rounds the result to the nearest integer. 11.5 should round to 12 using either of the midpoint-rounding conventions (`ToEven` or `AwayFromZero`). However, as the output from the example shows, it does not. The example uses the "R" [standard numeric format string](/dotnet/standard/base-types/standard-numeric-format-strings) to display the floating point value's full precision, and shows that the value to be rounded has lost precision during repeated additions, and its value is actually 11.499999999999998. Because .499999999999998 is less than .5, the midpoint-rounding conventions don't come into play and the value is rounded down. As the example also shows, this problem does not occur if you assign the constant value 11.5 to a <xref:System.Double> variable.  
  
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision1.cs" interactive="try-dotnet" id="Snippet7":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision1.vb" id="Snippet7":::
  
Problems of precision in rounding midpoint values are most likely to arise in the following conditions:  
  
- When a fractional value cannot be expressed precisely in the floating-point type's binary format.  
  
- When the value to be rounded is calculated from one or more floating-point operations.  
  
- When the value to be rounded is a <xref:System.Single> rather than a <xref:System.Double> or <xref:System.Decimal>. For more information, see the next section, [Rounding and single-precision floating-point values](#rounding-and-single-precision-floating-point-values).  
  
 In cases where the lack of precision in rounding operations is problematic, you can do the following:  
  
- If the rounding operation calls an overload that rounds a <xref:System.Double> value, you can change the <xref:System.Double> to a <xref:System.Decimal> value and call an overload that rounds a <xref:System.Decimal> value instead. Although the <xref:System.Decimal> data type also has problems of representation and loss of precision, these issues are far less common.  
  
- Define a custom rounding algorithm that performs a "nearly equal" test to determine whether the value to be rounded is acceptably close to a midpoint value. The following example defines a `RoundApproximate` method that examines whether a fractional value is sufficiently near to a midpoint value to be subject to midpoint rounding. As the output from the example shows, it corrects the rounding problem shown in the previous example.  
  
  :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision2.cs" interactive="try-dotnet" id="Snippet8":::
  :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision2.vb" id="Snippet8":::
  
#### Rounding and single-precision floating-point values  

The <xref:System.Math.Round%2A> method includes overloads that accept arguments of type <xref:System.Decimal> and <xref:System.Double>. There are no methods that round values of type <xref:System.Single>. If you pass a <xref:System.Single> value to one of the overloads of the <xref:System.Math.Round%2A> method, it is cast (in C#) or converted (in Visual Basic) to a <xref:System.Double>, and the corresponding <xref:System.Math.Round%2A> overload with a <xref:System.Double> parameter is called. Although this is a widening conversion, it often involves a loss of precision, as the following example illustrates. When a <xref:System.Single> value of 16.325 is passed to the <xref:System.Math.Round%2A> method and rounded to two decimal places using the rounding to nearest convention, the result is 16.33 and not the expected result of 16.32.  

:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/single1.cs" interactive="try-dotnet" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/single1.vb" id="Snippet1":::
 
This unexpected result is due to a loss of precision in the conversion of the <xref:System.Single> value to a <xref:System.Double>. Because the resulting <xref:System.Double> value of 16.325000762939453 is not a midpoint value and is greater than 16.325, it is always rounded upward.  
  
In many cases, as the example illustrates, the loss of precision can be minimized or eliminated by casting or converting the <xref:System.Single> value to a <xref:System.Decimal>. Note that, because this is a narrowing conversion, it requires using a cast operator or calling a conversion method.  

<a name="round-examples"></a>  
## Examples 

In addition to the examples in the [Remarks](#remarks-round) section, this article includes examples that illustrate the following overloads of the `Math.Round` method:

[Math.Round(Decimal)](#Round1_Example)  
[Math.Round(Double)](#Round2_Example)  
[Math.Round(Decimal, Int32)](#Round3_Example)  
[Math.Round(Decimal, MidpointRounding)](#Round4_Example)  
[Math.Round(Double, Int32)](#Round5_Example)  
[Math.Round(Double, MidpointRounding)](#Round6_Example)  
[Math.Round(Decimal, Int32, MidpointRounding)](#Round7_Example)  
[Math.Round(Double, Int32, MidpointRounding)](#Round8_Example)  

       ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
        <altmember cref="M:System.Math.Truncate(System.Decimal)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal) As Decimal" />
      <MemberSignature Language="F#" Value="static member Round : decimal -&gt; decimal" Usage="System.Math.Round d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number to be rounded.</param>
        <summary>Rounds a decimal value to the nearest integral value, and rounds midpoint values to the nearest even number.</summary>
        <returns>The integer nearest the <paramref name="d" /> parameter. If the fractional component of <paramref name="d" /> is halfway between two integers, one of which is even and the other odd, the even number is returned. Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
  
This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>. For information about rounding numbers with midpoint values, see [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions).

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<a name="Round1_Example"></a> 
## Examples

The following example demonstrates the <xref:System.Math.Round%28System.Decimal%29> method. The <xref:System.Decimal> value of 4.5 rounds to 4 rather than 5, because this overload uses the default <xref:System.MidpointRounding.ToEven> convention.  
  
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/rounddecimal1.cs" interactive="try-dotnet-method" id="Snippet6":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/rounddecimal1.vb" id="Snippet6":::  

       ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">The result is outside the range of a <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (a As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Round : double -&gt; double" Usage="System.Math.Round a" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">A double-precision floating-point number to be rounded.</param>
        <summary>Rounds a double-precision floating-point value to the nearest integral value, and rounds midpoint values to the nearest even number.</summary>
        <returns>The integer nearest <paramref name="a" />. If the fractional component of <paramref name="a" /> is halfway between two integers, one of which is even and the other odd, then the even number is returned. Note that this method returns a <see cref="T:System.Double" /> instead of an integral type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>. For information about rounding numbers with midpoint values, see [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions).

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

If the value of the `a` argument is <xref:System.Double.NaN?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>. If `a` is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectively.  

Starting with Visual Basic 15.8, the performance of Double-to-integer conversion is optimized if you pass the value returned by the `Round` method to the any of the [integral conversion functions](/dotnet/visual-basic/language-reference/functions/conversion-functions), or if the Double value returned by `Round` is automatically converted to an integer with [Option Strict](/dotnet/visual-basic/language-reference/statements/option-strict-statement) set to Off. This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types. The following example illustrates such optimized conversions:
   
```vb
Dim d1 As Double = 1043.75133
Dim i1 As Integer = CInt(Math.Ceiling(d1))        ' Result: 1044

Dim d2 As Double = 7968.4136
Dim i2 As Integer = CInt(Math.Ceiling(d2))        ' Result: 7968
```

<a name="Round2_Example"></a>   
## Example  

The following example demonstrates rounding to the nearest integer value.  
  
:::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round Example/CPP/source.cpp" id="Snippet1":::
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round Example/VB/source.vb" id="Snippet1":::  

       ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double)" /> method may not appear to round midpoint values to the nearest even integer. In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <see cref="M:System.Math.Round(System.Double)" /> method with a value of 11.5 returns 11 instead of 12.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round2.vb" id="Snippet1":::
 
          </para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer) As Decimal" />
      <MemberSignature Language="F#" Value="static member Round : decimal * int -&gt; decimal" Usage="System.Math.Round (d, decimals)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number to be rounded.</param>
        <param name="decimals">The number of decimal places in the return value.</param>
        <summary>Rounds a decimal value to a specified number of fractional digits, and rounds midpoint values to the nearest even number.</summary>
        <returns>The number nearest to <paramref name="d" /> that contains a number of fractional digits equal to <paramref name="decimals" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
The value of the `decimals` argument can range from 0 to 28.

This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>. For information about rounding numbers with midpoint values, see [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions).

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<a name="Round3_Example"></a>   
## Example  

The following example rounds decimal values with two fractional digits to values that have a single fractional digit.  
  
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/source.cs" interactive="try-dotnet-method" id="Snippet3":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/source.vb" id="Snippet3":::  
  
      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> is less than 0 or greater than 28.</exception>
        <exception cref="T:System.OverflowException">The result is outside the range of a <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="F#" Value="static member Round : decimal * MidpointRounding -&gt; decimal" Usage="System.Math.Round (d, mode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number to be rounded.</param>
        <param name="mode">One of the enumeration values that specifies which rounding strategy to use.</param>
        <summary>Rounds a decimal value an integer using the specified rounding convention.</summary>
        <returns>The integer that <paramref name="d" /> is rounded to. This method returns a <see cref="T:System.Decimal" /> instead of an integral type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

For information about rounding numbers with midpoint values, see [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions).

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<a name="Round5_Example"></a>   
## Example  

The following example displays values returned by the <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> method with different `mode` values.

:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint1.cs" interactive="try-dotnet" id="Snippet5":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint1.vb" id="Snippet5":::
  
       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">The result is outside the range of a <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer) As Double" />
      <MemberSignature Language="F#" Value="static member Round : double * int -&gt; double" Usage="System.Math.Round (value, digits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A double-precision floating-point number to be rounded.</param>
        <param name="digits">The number of fractional digits in the return value.</param>
        <summary>Rounds a double-precision floating-point value to a specified number of fractional digits, and rounds midpoint values to the nearest even number.</summary>
        <returns>The number nearest to <paramref name="value" /> that contains a number of fractional digits equal to <paramref name="digits" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
The value of the `digits` argument can range from 0 to 15. The maximum number of integral and fractional digits supported by the <xref:System.Double> type is 15.

This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>. See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

If the value of the `value` argument is <xref:System.Double.NaN?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>. If `value` is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectively.  

<a name="Round4_Example"></a>   
## Example  

The following example rounds double values with two fractional digits to doubles that have a single fractional digit.  
  
:::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CPP/source.cpp" id="Snippet1":::
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CS/source.cs" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round2 Example/VB/source.vb" id="Snippet1":::  
  
       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="digits" /> is less than 0 or greater than 15.</exception>
        <block subset="none" type="usage">
          <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.Int32)" /> method may not appear to round midpoint values to the nearest even value in the <paramref name="digits" /> decimal position. This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14. This occurs because internally the method multiplies <paramref name="value" /> by 10<sup>digits</sup>, and the multiplication operation in this case suffers from a loss of precision.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round3.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round3.vb" id="Snippet2":::
  
          </para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, mode As MidpointRounding) As Double" />
      <MemberSignature Language="F#" Value="static member Round : double * MidpointRounding -&gt; double" Usage="System.Math.Round (value, mode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A double-precision floating-point number to be rounded.</param>
        <param name="mode">One of the enumeration values that specifies which rounding strategy to use.</param>
        <summary>Rounds a double-precision floating-point value to an integer using the specified rounding convention.</summary>
        <returns>The integer that <paramref name="value" /> is rounded to. This method returns a <see cref="T:System.Double" /> instead of an integral type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

If the value of the `value` argument is <xref:System.Double.NaN?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>. If `value` is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectively.  

<a name="Round6_Example"></a>   
## Example

The following example displays values returned by the <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> method with different `mode` values.
  
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint2.cs" interactive="try-dotnet" id="Snippet6":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint2.vb" id="Snippet6":::
  
       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</exception>
        <block subset="none" type="usage">
          <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> method may not appear to round midpoint values to the nearest even integer. In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <see cref="M:System.Math.Round(System.Double)" /> method with a value of 11.5 returns 11 instead of 12.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round5.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round5.vb" id="Snippet4":::

          </para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="F#" Value="static member Round : decimal * int * MidpointRounding -&gt; decimal" Usage="System.Math.Round (d, decimals, mode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decimals" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">A decimal number to be rounded.</param>
        <param name="decimals">The number of decimal places in the return value.</param>
        <param name="mode">One of the enumeration values that specifies which rounding strategy to use.</param>
        <summary>Rounds a decimal value to a specified number of fractional digits using the specified rounding convention.</summary>
        <returns>The number with <paramref name="decimals" /> fractional digits that <paramref name="d" /> is rounded to. If <paramref name="d" /> has fewer fractional digits than <paramref name="decimals" />, <paramref name="d" /> is returned unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]  

The value of the `decimals` argument can range from 0 to 28.

<a name="Round7_Example"></a>   
## Example  

The following example demonstrates how to use the <xref:System.Math.Round%2A> method with the <xref:System.MidpointRounding> enumeration.

:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mpr.cs" interactive="try-dotnet-method" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mpr.vb" id="Snippet1":::  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> is less than 0 or greater than 28.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">The result is outside the range of a <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer, mode As MidpointRounding) As Double" />
      <MemberSignature Language="F#" Value="static member Round : double * int * MidpointRounding -&gt; double" Usage="System.Math.Round (value, digits, mode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="digits" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A double-precision floating-point number to be rounded.</param>
        <param name="digits">The number of fractional digits in the return value.</param>
        <param name="mode">One of the enumeration values that specifies which rounding strategy to use.</param>
        <summary>Rounds a double-precision floating-point value to a specified number of fractional digits using the specified rounding convention.</summary>
        <returns>The number that has <paramref name="digits" /> fractional digits that <paramref name="value" /> is rounded to. If <paramref name="value" /> has fewer fractional digits than <paramref name="digits" />, <paramref name="value" /> is returned unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

The value of the `digits` argument can range from 0 to 15. The maximum number of integral and fractional digits supported by the <xref:System.Double> type is 15.

See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

If the value of the `value` argument is <xref:System.Double.NaN?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>. If `value` is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectively.  

<a name="Round8_Example"></a>   
## Example  

The following example demonstrates how to use the <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> method with the <xref:System.MidpointRounding> enumeration.  
  
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mpr.cs" interactive="try-dotnet-method" id="Snippet4":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mpr.vb" id="Snippet4":::
  
       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="digits" /> is less than 0 or greater than 15.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</exception>
        <block subset="none" type="usage">
          <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> method may not appear to round midpoint values as specified by the <paramref name="mode" /> parameter. This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14. This occurs because internally the method multiplies <paramref name="value" /> by 10<sup>digits</sup>, and the multiplication operation in this case suffers from a loss of precision.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round4.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round4.vb" id="Snippet3":::
 
          </para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleB">
      <MemberSignature Language="C#" Value="public static double ScaleB (double x, int n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ScaleB(float64 x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.ScaleB(System.Double,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ScaleB (x As Double, n As Integer) As Double" />
      <MemberSignature Language="F#" Value="static member ScaleB : double * int -&gt; double" Usage="System.Math.ScaleB (x, n)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ScaleB(double x, int n);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0" />
      </Parameters>
      <Docs>
        <param name="x">A double-precision floating-point number that specifies the base value.</param>
        <param name="n">A 32-bit integer that specifies the power.</param>
        <summary>Returns x * 2^n computed efficiently.</summary>
        <returns>x * 2^n computed efficiently.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sign">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns an integer that indicates the sign of a number.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Decimal) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : decimal -&gt; int" Usage="System.Math.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">A signed decimal number.</param>
        <summary>Returns an integer that indicates the sign of a decimal number.</summary>
        <returns>A number that indicates the sign of <paramref name="value" />, as shown in the following table.  
  
 <list type="table"><listheader><term> Return value  
  
 </term><description> Meaning  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> is less than zero.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> is equal to zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> is greater than zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Sign%28System.Decimal%29> method to determine the sign of a <xref:System.Decimal> value and display it to the console.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb" id="Snippet1":::
    
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Double) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : double -&gt; int" Usage="System.Math.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of a double-precision floating-point number.</summary>
        <returns>A number that indicates the sign of <paramref name="value" />, as shown in the following table.  
  
 <list type="table"><listheader><term> Return value  
  
 </term><description> Meaning  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> is less than zero.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> is equal to zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> is greater than zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Sign%28System.Double%29> method to determine the sign of a <xref:System.Double> value and display it to the console.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Short) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : int16 -&gt; int" Usage="System.Math.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of a 16-bit signed integer.</summary>
        <returns>A number that indicates the sign of <paramref name="value" />, as shown in the following table.  
  
 <list type="table"><listheader><term> Return value  
  
 </term><description> Meaning  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> is less than zero.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> is equal to zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> is greater than zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int16%29> method to determine the sign of an <xref:System.Int16> value and display it to the console.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Integer) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : int -&gt; int" Usage="System.Math.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of a 32-bit signed integer.</summary>
        <returns>A number that indicates the sign of <paramref name="value" />, as shown in the following table.  
  
 <list type="table"><listheader><term> Return value  
  
 </term><description> Meaning  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> is less than zero.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> is equal to zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> is greater than zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int32%29> method to determine the sign of an <xref:System.Int32> value and display it to the console.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Long) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : int64 -&gt; int" Usage="System.Math.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of a 64-bit signed integer.</summary>
        <returns>A number that indicates the sign of <paramref name="value" />, as shown in the following table.  
  
 <list type="table"><listheader><term> Return value  
  
 </term><description> Meaning  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> is less than zero.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> is equal to zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> is greater than zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int64%29> method to determine the sign of an <xref:System.Int64> value and display it to the console.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As IntPtr) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : nativeint -&gt; int" Usage="System.Math.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" Index="0" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of a native sized signed integer.</summary>
        <returns>A number that indicates the sign of <paramref name="value" />, as shown in the following table.  
  
 <list type="table"><listheader><term> Return value  
  
 </term><description> Meaning  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> is less than zero.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> is equal to zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> is greater than zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Sign%28System.IntPtr%29> method to determine the sign of an <xref:System.IntPtr> value and display it to the console.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs" interactive="try-dotnet" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As SByte) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : sbyte -&gt; int" Usage="System.Math.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of an 8-bit signed integer.</summary>
        <returns>A number that indicates the sign of <paramref name="value" />, as shown in the following table.  
  
 <list type="table"><listheader><term> Return value  
  
 </term><description> Meaning  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> is less than zero.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> is equal to zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> is greater than zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Sign%28System.SByte%29> method to determine the sign of an <xref:System.SByte> value and display it to the console.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Single) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : single -&gt; int" Usage="System.Math.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">A signed number.</param>
        <summary>Returns an integer that indicates the sign of a single-precision floating-point number.</summary>
        <returns>A number that indicates the sign of <paramref name="value" />, as shown in the following table.  
  
 <list type="table"><listheader><term> Return value  
  
 </term><description> Meaning  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> is less than zero.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> is equal to zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> is greater than zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example demonstrates how to use the <xref:System.Math.Sign%28System.Single%29> method to determine the sign of a <xref:System.Single> value and display it to the console.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <paramref name="value" /> is equal to <see cref="F:System.Single.NaN" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static double Sin (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sin(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (a As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Sin : double -&gt; double" Usage="System.Math.Sin a" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sin(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">An angle, measured in radians.</param>
        <summary>Returns the sine of the specified angle.</summary>
        <returns>The sine of <paramref name="a" />. If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, `a`, must be in radians. Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example uses <xref:System.Math.Sin%2A> to evaluate certain trigonometric identities for selected angles.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SinCos">
      <MemberSignature Language="C#" Value="public static (double,double) SinCos (double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;float64, float64&gt; SinCos(float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.SinCos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SinCos (x As Double) As ValueTuple(Of Double, Double)" />
      <MemberSignature Language="F#" Value="static member SinCos : double -&gt; ValueTuple&lt;double, double&gt;" Usage="System.Math.SinCos x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;double, double&gt; SinCos(double x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Double,System.Double&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Sin", "Cos" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Sin", "Cos" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="net-6.0" />
      </Parameters>
      <Docs>
        <param name="x">An angle, measured in radians.</param>
        <summary>Returns the sine and cosine of the specified angle.</summary>
        <returns>The sine and cosine of <paramref name="x" />. If <paramref name="x" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, `x`, must be in radians. Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example uses <xref:System.Math.SinCos%2A> to evaluate certain trigonometric identities for selected angles.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs" interactive="try-dotnet" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static double Sinh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sinh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Sinh : double -&gt; double" Usage="System.Math.Sinh value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sinh(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">An angle, measured in radians.</param>
        <summary>Returns the hyperbolic sine of the specified angle.</summary>
        <returns>The hyperbolic sine of <paramref name="value" />. If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" />, <see cref="F:System.Double.PositiveInfinity" />, or <see cref="F:System.Double.NaN" />, this method returns a <see cref="T:System.Double" /> equal to <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, `value`, must be in radians. Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example uses <xref:System.Math.Sinh%2A> to evaluate certain hyperbolic identities for selected values.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static double Sqrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sqrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sqrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Sqrt : double -&gt; double" Usage="System.Math.Sqrt d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sqrt(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">The number whose square root is to be found.</param>
        <summary>Returns the square root of a specified number.</summary>
        <returns>One of the values in the following table.  
  
 <list type="table"><listheader><term><paramref name="d" /> parameter  
  
 </term><description> Return value  
  
 </description></listheader><item><term> Zero or positive  
  
 </term><description> The positive square root of <paramref name="d" />.  
  
 </description></item><item><term> Negative  
  
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equals <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equals <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  

  The square root of the area of a square represents the length of any side of the square. The following example displays the area of some cities in the United States and gives an impression of each city's size if it were represented by a square.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.sqrt/cs/sqrt1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.sqrt/vb/sqrt1.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static double Tan (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tan(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (a As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Tan : double -&gt; double" Usage="System.Math.Tan a" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tan(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">An angle, measured in radians.</param>
        <summary>Returns the tangent of the specified angle.</summary>
        <returns>The tangent of <paramref name="a" />. If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, `a`, must be in radians. Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example demonstrates how to calculate the tangent of an angle and display it to the console.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static double Tanh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tanh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Tanh : double -&gt; double" Usage="System.Math.Tanh value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tanh(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">An angle, measured in radians.</param>
        <summary>Returns the hyperbolic tangent of the specified angle.</summary>
        <returns>The hyperbolic tangent of <paramref name="value" />. If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" />, this method returns -1. If value is equal to <see cref="F:System.Double.PositiveInfinity" />, this method returns 1. If <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />, this method returns <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The angle, `value`, must be in radians. Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.  
  
 This method calls into the underlying C runtime, and the exact result or valid input range may differ between different operating systems or architectures.  
  
   
  
## Examples  
 The following example uses <xref:System.Math.Tanh%2A> to evaluate certain hyperbolic tangent identities for selected values.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Tanh/CPP/tanh.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Tanh/CS/tanh.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Tanh/VB/tanh.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tau">
      <MemberSignature Language="C#" Value="public const double Tau = 6.2831853071795862;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Tau = (6.2831853071795862)" />
      <MemberSignature Language="DocId" Value="F:System.Math.Tau" />
      <MemberSignature Language="VB.NET" Value="Public Const Tau As Double  = 6.2831853071795862" />
      <MemberSignature Language="F#" Value="val mutable Tau : double" Usage="System.Math.Tau" />
      <MemberSignature Language="C++ CLI" Value="public: double Tau = 6.2831853071795862;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>6.2831853071795862</MemberValue>
      <Docs>
        <summary>Represents the number of radians in one turn, specified by the constant, τ.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Truncate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calculates the integral part of a number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The number is rounded to the nearest integer towards zero.  
  
  ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Decimal) As Decimal" />
      <MemberSignature Language="F#" Value="static member Truncate : decimal -&gt; decimal" Usage="System.Math.Truncate d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Truncate(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">A number to truncate.</param>
        <summary>Calculates the integral part of a specified decimal number.</summary>
        <returns>The integral part of <paramref name="d" />; that is, the number that remains after any fractional digits have been discarded.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Math.Truncate%2A> rounds `d` to the nearest integer towards zero.  
  
   
  
## Examples  
 The following example calls the <xref:System.Math.Truncate%28System.Decimal%29> method to truncate both a positive and a negative <xref:System.Decimal> value.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb" id="Snippet2":::  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static double Truncate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Truncate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Double) As Double" />
      <MemberSignature Language="F#" Value="static member Truncate : double -&gt; double" Usage="System.Math.Truncate d" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Truncate(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">A number to truncate.</param>
        <summary>Calculates the integral part of a specified double-precision floating-point number.</summary>
        <returns>The integral part of <paramref name="d" />; that is, the number that remains after any fractional digits have been discarded, or one of the values listed in the following table.  
  
 <list type="table"><listheader><term><paramref name="d" /></term><description> Return value  
  
 </description></listheader><item><term><see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term><see cref="F:System.Double.NegativeInfinity" /></term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term><see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Math.Truncate%2A> rounds `d` to the nearest integer towards zero.  
  
Starting with Visual Basic 15.8, the performance of Double-to-integer conversion is optimized if you pass the value returned by the `Truncate` method to the any of the [integral conversion functions](/dotnet/visual-basic/language-reference/functions/conversion-functions), or if the Double value returned by `Truncate` is automatically converted to an integer with [Option Strict](/dotnet/visual-basic/language-reference/statements/option-strict-statement) set to Off. This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types. The following example illustrates such an optimized conversion:
   
```vb
Dim d As Double = 164.7194
Dim i As Integer = CInt(Math.Truncate(d))     ' Result: 164
```

## Examples  
 The following example calls the <xref:System.Math.Truncate%28System.Double%29> method to truncate both a positive and a negative <xref:System.Double> value.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
  </Members>
</Type>
