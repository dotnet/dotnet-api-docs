<Type Name="Half" FullName="System.Half">
  <TypeSignature Language="C#" Value="public readonly struct Half : IComparable, IComparable&lt;Half&gt;, IEquatable&lt;Half&gt;, IFormattable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Half extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Half&gt;, class System.IEquatable`1&lt;valuetype System.Half&gt;, class System.IFormattable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="DocId" Value="T:System.Half" />
  <TypeSignature Language="VB.NET" Value="Public Structure Half&#xA;Implements IComparable, IComparable(Of Half), IEquatable(Of Half), IFormattable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="F#" Value="type Half = struct&#xA;    interface IFormattable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Half : IComparable, IComparable&lt;Half&gt;, IEquatable&lt;Half&gt;, IFormattable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="C#" Value="public readonly struct Half : IComparable, IComparable&lt;Half&gt;, IEquatable&lt;Half&gt;, ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Half extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Half&gt;, class System.IEquatable`1&lt;valuetype System.Half&gt;, class System.IFormattable, class System.ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Half&#xA;Implements IComparable, IComparable(Of Half), IEquatable(Of Half), ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="F#" Value="type Half = struct&#xA;    interface ISpanFormattable&#xA;    interface IFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Half : IComparable, IComparable&lt;Half&gt;, IEquatable&lt;Half&gt;, ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="C#" Value="public readonly struct Half : IComparable&lt;Half&gt;, IEquatable&lt;Half&gt;, IParsable&lt;Half&gt;, ISpanParsable&lt;Half&gt;, System.Numerics.IAdditionOperators&lt;Half,Half,Half&gt;, System.Numerics.IAdditiveIdentity&lt;Half,Half&gt;, System.Numerics.IBinaryFloatingPointIeee754&lt;Half&gt;, System.Numerics.IBinaryNumber&lt;Half&gt;, System.Numerics.IBitwiseOperators&lt;Half,Half,Half&gt;, System.Numerics.IComparisonOperators&lt;Half,Half,bool&gt;, System.Numerics.IDecrementOperators&lt;Half&gt;, System.Numerics.IDivisionOperators&lt;Half,Half,Half&gt;, System.Numerics.IEqualityOperators&lt;Half,Half,bool&gt;, System.Numerics.IExponentialFunctions&lt;Half&gt;, System.Numerics.IFloatingPoint&lt;Half&gt;, System.Numerics.IFloatingPointConstants&lt;Half&gt;, System.Numerics.IFloatingPointIeee754&lt;Half&gt;, System.Numerics.IHyperbolicFunctions&lt;Half&gt;, System.Numerics.IIncrementOperators&lt;Half&gt;, System.Numerics.ILogarithmicFunctions&lt;Half&gt;, System.Numerics.IMinMaxValue&lt;Half&gt;, System.Numerics.IModulusOperators&lt;Half,Half,Half&gt;, System.Numerics.IMultiplicativeIdentity&lt;Half,Half&gt;, System.Numerics.IMultiplyOperators&lt;Half,Half,Half&gt;, System.Numerics.INumber&lt;Half&gt;, System.Numerics.INumberBase&lt;Half&gt;, System.Numerics.IPowerFunctions&lt;Half&gt;, System.Numerics.IRootFunctions&lt;Half&gt;, System.Numerics.ISignedNumber&lt;Half&gt;, System.Numerics.ISubtractionOperators&lt;Half,Half,Half&gt;, System.Numerics.ITrigonometricFunctions&lt;Half&gt;, System.Numerics.IUnaryNegationOperators&lt;Half,Half&gt;, System.Numerics.IUnaryPlusOperators&lt;Half,Half&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Half extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Half&gt;, class System.IEquatable`1&lt;valuetype System.Half&gt;, class System.IFormattable, class System.IParsable`1&lt;valuetype System.Half&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;valuetype System.Half&gt;, class System.Numerics.IAdditionOperators`3&lt;valuetype System.Half, valuetype System.Half, valuetype System.Half&gt;, class System.Numerics.IAdditiveIdentity`2&lt;valuetype System.Half, valuetype System.Half&gt;, class System.Numerics.IBinaryFloatingPointIeee754`1&lt;valuetype System.Half&gt;, class System.Numerics.IBinaryNumber`1&lt;valuetype System.Half&gt;, class System.Numerics.IBitwiseOperators`3&lt;valuetype System.Half, valuetype System.Half, valuetype System.Half&gt;, class System.Numerics.IComparisonOperators`3&lt;valuetype System.Half, valuetype System.Half, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;valuetype System.Half&gt;, class System.Numerics.IDivisionOperators`3&lt;valuetype System.Half, valuetype System.Half, valuetype System.Half&gt;, class System.Numerics.IEqualityOperators`3&lt;valuetype System.Half, valuetype System.Half, bool&gt;, class System.Numerics.IExponentialFunctions`1&lt;valuetype System.Half&gt;, class System.Numerics.IFloatingPoint`1&lt;valuetype System.Half&gt;, class System.Numerics.IFloatingPointConstants`1&lt;valuetype System.Half&gt;, class System.Numerics.IFloatingPointIeee754`1&lt;valuetype System.Half&gt;, class System.Numerics.IHyperbolicFunctions`1&lt;valuetype System.Half&gt;, class System.Numerics.IIncrementOperators`1&lt;valuetype System.Half&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;valuetype System.Half&gt;, class System.Numerics.IMinMaxValue`1&lt;valuetype System.Half&gt;, class System.Numerics.IModulusOperators`3&lt;valuetype System.Half, valuetype System.Half, valuetype System.Half&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;valuetype System.Half, valuetype System.Half&gt;, class System.Numerics.IMultiplyOperators`3&lt;valuetype System.Half, valuetype System.Half, valuetype System.Half&gt;, class System.Numerics.INumber`1&lt;valuetype System.Half&gt;, class System.Numerics.INumberBase`1&lt;valuetype System.Half&gt;, class System.Numerics.IPowerFunctions`1&lt;valuetype System.Half&gt;, class System.Numerics.IRootFunctions`1&lt;valuetype System.Half&gt;, class System.Numerics.ISignedNumber`1&lt;valuetype System.Half&gt;, class System.Numerics.ISubtractionOperators`3&lt;valuetype System.Half, valuetype System.Half, valuetype System.Half&gt;, class System.Numerics.ITrigonometricFunctions`1&lt;valuetype System.Half&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;valuetype System.Half, valuetype System.Half&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;valuetype System.Half, valuetype System.Half&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Half&#xA;Implements IAdditionOperators(Of Half, Half, Half), IAdditiveIdentity(Of Half, Half), IBinaryFloatingPointIeee754(Of Half), IBinaryNumber(Of Half), IBitwiseOperators(Of Half, Half, Half), IComparable(Of Half), IComparisonOperators(Of Half, Half, Boolean), IDecrementOperators(Of Half), IDivisionOperators(Of Half, Half, Half), IEqualityOperators(Of Half, Half, Boolean), IEquatable(Of Half), IExponentialFunctions(Of Half), IFloatingPoint(Of Half), IFloatingPointConstants(Of Half), IFloatingPointIeee754(Of Half), IHyperbolicFunctions(Of Half), IIncrementOperators(Of Half), ILogarithmicFunctions(Of Half), IMinMaxValue(Of Half), IModulusOperators(Of Half, Half, Half), IMultiplicativeIdentity(Of Half, Half), IMultiplyOperators(Of Half, Half, Half), INumber(Of Half), INumberBase(Of Half), IParsable(Of Half), IPowerFunctions(Of Half), IRootFunctions(Of Half), ISignedNumber(Of Half), ISpanParsable(Of Half), ISubtractionOperators(Of Half, Half, Half), ITrigonometricFunctions(Of Half), IUnaryNegationOperators(Of Half, Half), IUnaryPlusOperators(Of Half, Half)" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="F#" Value="type Half = struct&#xA;    interface IFormattable&#xA;    interface IParsable&lt;Half&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;Half&gt;&#xA;    interface IAdditionOperators&lt;Half, Half, Half&gt;&#xA;    interface IAdditiveIdentity&lt;Half, Half&gt;&#xA;    interface IBinaryFloatingPointIeee754&lt;Half&gt;&#xA;    interface IBinaryNumber&lt;Half&gt;&#xA;    interface IBitwiseOperators&lt;Half, Half, Half&gt;&#xA;    interface IComparisonOperators&lt;Half, Half, bool&gt;&#xA;    interface IEqualityOperators&lt;Half, Half, bool&gt;&#xA;    interface IDecrementOperators&lt;Half&gt;&#xA;    interface IDivisionOperators&lt;Half, Half, Half&gt;&#xA;    interface IIncrementOperators&lt;Half&gt;&#xA;    interface IModulusOperators&lt;Half, Half, Half&gt;&#xA;    interface IMultiplicativeIdentity&lt;Half, Half&gt;&#xA;    interface IMultiplyOperators&lt;Half, Half, Half&gt;&#xA;    interface INumber&lt;Half&gt;&#xA;    interface INumberBase&lt;Half&gt;&#xA;    interface ISubtractionOperators&lt;Half, Half, Half&gt;&#xA;    interface IUnaryNegationOperators&lt;Half, Half&gt;&#xA;    interface IUnaryPlusOperators&lt;Half, Half&gt;&#xA;    interface IExponentialFunctions&lt;Half&gt;&#xA;    interface IFloatingPointConstants&lt;Half&gt;&#xA;    interface IFloatingPoint&lt;Half&gt;&#xA;    interface ISignedNumber&lt;Half&gt;&#xA;    interface IFloatingPointIeee754&lt;Half&gt;&#xA;    interface IHyperbolicFunctions&lt;Half&gt;&#xA;    interface ILogarithmicFunctions&lt;Half&gt;&#xA;    interface IPowerFunctions&lt;Half&gt;&#xA;    interface IRootFunctions&lt;Half&gt;&#xA;    interface ITrigonometricFunctions&lt;Half&gt;&#xA;    interface IMinMaxValue&lt;Half&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Half : IComparable&lt;Half&gt;, IEquatable&lt;Half&gt;, IParsable&lt;Half&gt;, ISpanParsable&lt;Half&gt;, System::Numerics::IAdditionOperators&lt;Half, Half, Half&gt;, System::Numerics::IAdditiveIdentity&lt;Half, Half&gt;, System::Numerics::IBinaryFloatingPointIeee754&lt;Half&gt;, System::Numerics::IBinaryNumber&lt;Half&gt;, System::Numerics::IBitwiseOperators&lt;Half, Half, Half&gt;, System::Numerics::IComparisonOperators&lt;Half, Half, bool&gt;, System::Numerics::IDecrementOperators&lt;Half&gt;, System::Numerics::IDivisionOperators&lt;Half, Half, Half&gt;, System::Numerics::IEqualityOperators&lt;Half, Half, bool&gt;, System::Numerics::IExponentialFunctions&lt;Half&gt;, System::Numerics::IFloatingPoint&lt;Half&gt;, System::Numerics::IFloatingPointConstants&lt;Half&gt;, System::Numerics::IFloatingPointIeee754&lt;Half&gt;, System::Numerics::IHyperbolicFunctions&lt;Half&gt;, System::Numerics::IIncrementOperators&lt;Half&gt;, System::Numerics::ILogarithmicFunctions&lt;Half&gt;, System::Numerics::IMinMaxValue&lt;Half&gt;, System::Numerics::IModulusOperators&lt;Half, Half, Half&gt;, System::Numerics::IMultiplicativeIdentity&lt;Half, Half&gt;, System::Numerics::IMultiplyOperators&lt;Half, Half, Half&gt;, System::Numerics::INumber&lt;Half&gt;, System::Numerics::INumberBase&lt;Half&gt;, System::Numerics::IPowerFunctions&lt;Half&gt;, System::Numerics::IRootFunctions&lt;Half&gt;, System::Numerics::ISignedNumber&lt;Half&gt;, System::Numerics::ISubtractionOperators&lt;Half, Half, Half&gt;, System::Numerics::ITrigonometricFunctions&lt;Half&gt;, System::Numerics::IUnaryNegationOperators&lt;Half, Half&gt;, System::Numerics::IUnaryPlusOperators&lt;Half, Half&gt;" FrameworkAlternate="net-7.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-6.0;net-7.0">
      <InterfaceName>System.ISpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.IComparable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.IEquatable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.IParsable&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.IParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.ISpanParsable&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.ISpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;System.Half,System.Half,System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;System.Half,System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IBinaryFloatingPointIeee754&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IBinaryNumber&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IBinaryNumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;System.Half,System.Half,System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IComparisonOperators&lt;System.Half,System.Half,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IComparisonOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;System.Half,System.Half,System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;System.Half,System.Half,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TOther,TResult&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IExponentialFunctions&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IExponentialFunctions&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IFloatingPoint&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IFloatingPoint&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IFloatingPointConstants&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IFloatingPointConstants&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IMinMaxValue&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IModulusOperators&lt;System.Half,System.Half,System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;System.Half,System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;System.Half,System.Half,System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.INumber&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.INumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.INumberBase&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.INumberBase&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IPowerFunctions&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IPowerFunctions&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IRootFunctions&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IRootFunctions&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.ISignedNumber&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.ISignedNumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;System.Half,System.Half,System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;System.Half,System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;System.Half,System.Half&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a half-precision floating-point number.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

The <xref:System.Half> value type represents a half-precision 16-bit number with values ranging from negative 65,504 to positive 65,504, as well as positive or negative zero, <xref:System.Half.PositiveInfinity>, <xref:System.Half.NegativeInfinity>, and not a number (<xref:System.Half.NaN>).

This is an IEEE 754-compliant `float16` type.

]]></format>
    </remarks>
    <seealso cref="T:System.Single" />
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static Half Abs (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Abs(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Abs(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Abs : Half -&gt; Half" Usage="System.Half.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Abs(Half value) = System::Numerics::INumberBase&lt;Half&gt;::Abs;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Abs(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Computes the absolute of a value.</summary>
        <returns>The absolute of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.Abs(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static Half Acos (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Acos(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Acos(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Acos : Half -&gt; Half" Usage="System.Half.Acos x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Acos(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::Acos;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.Acos(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the arc-cosine of a value.</summary>
        <returns>The arc-cosine of <paramref name="x" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `arccos(x)` in the interval `[+0, +π]` radians.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.Acos(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static Half Acosh (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Acosh(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Acosh(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Acosh : Half -&gt; Half" Usage="System.Half.Acosh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Acosh(Half x) = System::Numerics::IHyperbolicFunctions&lt;Half&gt;::Acosh;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IHyperbolicFunctions`1.Acosh(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the hyperbolic arc-cosine of a value.</summary>
        <returns>The hyperbolic arc-cosine of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IHyperbolicFunctions`1.Acosh(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AcosPi">
      <MemberSignature Language="C#" Value="public static Half AcosPi (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half AcosPi(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.AcosPi(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AcosPi (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member AcosPi : Half -&gt; Half" Usage="System.Half.AcosPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half AcosPi(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::AcosPi;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.AcosPi(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the arc-cosine of a value and divides the result by <c>pi</c>.</summary>
        <returns>The arc-cosine of <paramref name="x" />, divided by <c>pi</c>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `arccos(x) / π` in the interval `[-0.5, +0.5]`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.AcosPi(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static Half Asin (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Asin(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Asin(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Asin : Half -&gt; Half" Usage="System.Half.Asin x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Asin(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::Asin;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.Asin(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the arc-sine of a value.</summary>
        <returns>The arc-sine of <paramref name="x" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `arcsin(x)` in the interval `[-π / 2, +π / 2]` radians.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.Asin(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static Half Asinh (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Asinh(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Asinh(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Asinh : Half -&gt; Half" Usage="System.Half.Asinh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Asinh(Half x) = System::Numerics::IHyperbolicFunctions&lt;Half&gt;::Asinh;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IHyperbolicFunctions`1.Asinh(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the hyperbolic arc-sine of a value.</summary>
        <returns>The hyperbolic arc-sine of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IHyperbolicFunctions`1.Asinh(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AsinPi">
      <MemberSignature Language="C#" Value="public static Half AsinPi (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half AsinPi(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.AsinPi(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsinPi (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member AsinPi : Half -&gt; Half" Usage="System.Half.AsinPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half AsinPi(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::AsinPi;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.AsinPi(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the arc-sine of a value and divides the result by <c>pi</c>.</summary>
        <returns>The arc-sine of <paramref name="x" />, divided by <c>pi</c>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `arcsin(x) / π` in the interval `[-0.5, +0.5]`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.AsinPi(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static Half Atan (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Atan(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Atan(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Atan : Half -&gt; Half" Usage="System.Half.Atan x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Atan(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::Atan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.Atan(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the arc-tangent of a value.</summary>
        <returns>The arc-tangent of <paramref name="x" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `arctan(x)` in the interval `[-π / 2, +π / 2]` radians.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.Atan(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static Half Atan2 (Half y, Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Atan2(valuetype System.Half y, valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Atan2(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Half, x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Atan2 : Half * Half -&gt; Half" Usage="System.Half.Atan2 (y, x)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Atan2(Half y, Half x) = System::Numerics::IFloatingPointIeee754&lt;Half&gt;::Atan2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPointIeee754`1.Atan2(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="x" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="y">To be added.</param>
        <param name="x">To be added.</param>
        <summary>Computes the arc-tangent of the quotient of two values.</summary>
        <returns>The arc-tangent of <paramref name="y" /> divided-by <paramref name="x" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `arctan(y / x)` in the interval `[-π, +π]` radians.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPointIeee754`1.Atan2(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi">
      <MemberSignature Language="C#" Value="public static Half Atan2Pi (Half y, Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Atan2Pi(valuetype System.Half y, valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Atan2Pi(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2Pi (y As Half, x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : Half * Half -&gt; Half" Usage="System.Half.Atan2Pi (y, x)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Atan2Pi(Half y, Half x) = System::Numerics::IFloatingPointIeee754&lt;Half&gt;::Atan2Pi;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPointIeee754`1.Atan2Pi(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="x" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="y">To be added.</param>
        <param name="x">To be added.</param>
        <summary>Computes the arc-tangent for the quotient of two values and divides the result by <c>pi</c>.</summary>
        <returns>The arc-tangent of <paramref name="y" /> divided-by <paramref name="x" />, divided by <c>pi</c>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `arctan(y / x) / π` in the interval `[-1, +1]`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPointIeee754`1.Atan2Pi(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static Half Atanh (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Atanh(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Atanh(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Atanh : Half -&gt; Half" Usage="System.Half.Atanh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Atanh(Half x) = System::Numerics::IHyperbolicFunctions&lt;Half&gt;::Atanh;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IHyperbolicFunctions`1.Atanh(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the hyperbolic arc-tangent of a value.</summary>
        <returns>The hyperbolic arc-tangent of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IHyperbolicFunctions`1.Atanh(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AtanPi">
      <MemberSignature Language="C#" Value="public static Half AtanPi (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half AtanPi(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.AtanPi(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AtanPi (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member AtanPi : Half -&gt; Half" Usage="System.Half.AtanPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half AtanPi(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::AtanPi;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.AtanPi(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the arc-tangent of a value and divides the result by pi.</summary>
        <returns>The arc-tangent of <paramref name="x" />, divided by <c>pi</c>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `arctan(x) / π` in the interval `[-0.5, +0.5]`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.AtanPi(`0)" />
      </Docs>
    </Member>
    <Member MemberName="BitDecrement">
      <MemberSignature Language="C#" Value="public static Half BitDecrement (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half BitDecrement(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.BitDecrement(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitDecrement (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member BitDecrement : Half -&gt; Half" Usage="System.Half.BitDecrement x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half BitDecrement(Half x) = System::Numerics::IFloatingPointIeee754&lt;Half&gt;::BitDecrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPointIeee754`1.BitDecrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Decrements a value to the smallest value that compares less than a given value.</summary>
        <returns>The smallest value that compares less than <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPointIeee754`1.BitDecrement(`0)" />
      </Docs>
    </Member>
    <Member MemberName="BitIncrement">
      <MemberSignature Language="C#" Value="public static Half BitIncrement (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half BitIncrement(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.BitIncrement(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitIncrement (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member BitIncrement : Half -&gt; Half" Usage="System.Half.BitIncrement x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half BitIncrement(Half x) = System::Numerics::IFloatingPointIeee754&lt;Half&gt;::BitIncrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPointIeee754`1.BitIncrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Increments a value to the smallest value that compares greater than a given value.</summary>
        <returns>The smallest value that compares greater than <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPointIeee754`1.BitIncrement(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static Half Cbrt (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Cbrt(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Cbrt(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Cbrt : Half -&gt; Half" Usage="System.Half.Cbrt x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Cbrt(Half x) = System::Numerics::IRootFunctions&lt;Half&gt;::Cbrt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IRootFunctions`1.Cbrt(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the cube-root of a value.</summary>
        <returns>The cube-root of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IRootFunctions`1.Cbrt(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static Half Ceiling (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Ceiling(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Ceiling(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Ceiling : Half -&gt; Half" Usage="System.Half.Ceiling x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Ceiling(Half x) = System::Numerics::IFloatingPoint&lt;Half&gt;::Ceiling;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.Ceiling(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the ceiling of a value.</summary>
        <returns>The ceiling of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.Ceiling(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static Half Clamp (Half value, Half min, Half max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Clamp(valuetype System.Half value, valuetype System.Half min, valuetype System.Half max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Clamp(System.Half,System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Half, min As Half, max As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Clamp : Half * Half * Half -&gt; Half" Usage="System.Half.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Clamp(Half value, Half min, Half max) = System::Numerics::INumber&lt;Half&gt;::Clamp;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Clamp(`0,`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="min" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
        <Parameter Name="max" Type="System.Half" Index="2" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>Clamps a value to an inclusive minimum and maximum value.</summary>
        <returns>The result of clamping <paramref name="value" /> to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Clamp(`0,`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (Half other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Half other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.CompareTo(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Half) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : Half -&gt; int&#xA;override this.CompareTo : Half -&gt; int" Usage="half.CompareTo other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(Half other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="other">A half-precision floating-point number to compare.</param>
        <summary>Compares this instance to a specified half-precision floating-point number and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified half-precision floating-point number.</summary>
        <returns>A value less than zero if this is less than <paramref name="other" />, zero if this is equal to <paramref name="other" />, or a value greater than zero if this is greater than <paramref name="other" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object? obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="half.CompareTo obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">An object to compare, or <see langword="null" />.</param>
        <summary>Compares this instance to a specified object and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</summary>
        <returns>
        A value less than zero if this instance is less than <paramref name="obj" />, or this instance is not a number (NaN) and <paramref name="obj" /> is a number.

        -or-

        Zero if this instance is equal to <paramref name="obj" />, or this instance and <paramref name="obj" /> are both not a number (NaN), <see cref="P:System.Half.PositiveInfinity" />, or <see cref="P:System.Half.NegativeInfinity" />.

        -or-

        A value greater than zero if this instance is greater than <paramref name="obj" />, or this instance is a number and <paramref name="obj" /> is not a number (NaN), or <paramref name="obj" /> is <see langword="null" />.
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> is not of type <see cref="T:System.Half" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopySign">
      <MemberSignature Language="C#" Value="public static Half CopySign (Half value, Half sign);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half CopySign(valuetype System.Half value, valuetype System.Half sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.CopySign(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CopySign (value As Half, sign As Half) As Half" />
      <MemberSignature Language="F#" Value="static member CopySign : Half * Half -&gt; Half" Usage="System.Half.CopySign (value, sign)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half CopySign(Half value, Half sign) = System::Numerics::INumber&lt;Half&gt;::CopySign;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.CopySign(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="sign" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="sign">To be added.</param>
        <summary>Copies the sign of a value to the sign of another value.</summary>
        <returns>A value with the magnitude of <paramref name="value" /> and the sign of <paramref name="sign" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.CopySign(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static Half Cos (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Cos(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Cos(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Cos : Half -&gt; Half" Usage="System.Half.Cos x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Cos(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::Cos;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.Cos(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the cosine of a value.</summary>
        <returns>The cosine of <paramref name="x" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `cos(x)`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.Cos(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static Half Cosh (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Cosh(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Cosh(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Cosh : Half -&gt; Half" Usage="System.Half.Cosh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Cosh(Half x) = System::Numerics::IHyperbolicFunctions&lt;Half&gt;::Cosh;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IHyperbolicFunctions`1.Cosh(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the hyperbolic cosine of a value.</summary>
        <returns>The hyperbolic cosine of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IHyperbolicFunctions`1.Cosh(`0)" />
      </Docs>
    </Member>
    <Member MemberName="CosPi">
      <MemberSignature Language="C#" Value="public static Half CosPi (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half CosPi(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.CosPi(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CosPi (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member CosPi : Half -&gt; Half" Usage="System.Half.CosPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half CosPi(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::CosPi;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.CosPi(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the cosine of a value that has been multipled by <c>pi</c>.</summary>
        <returns>The cosine of <paramref name="x" /> multiplied-by <c>pi</c>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `cos(x * π)`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.CosPi(`0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static Half CreateChecked&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half CreateChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.CreateChecked``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateChecked(Of TOther As INumberBase(Of TOther)) (value As TOther) As Half" />
      <MemberSignature Language="F#" Value="static member CreateChecked : 'Other -&gt; Half (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Half.CreateChecked value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static Half CreateChecked(TOther value) = System::Numerics::INumberBase&lt;Half&gt;::CreateChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateChecked``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <summary>Creates an instance of the current type from a value, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateChecked``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static Half CreateSaturating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half CreateSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.CreateSaturating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther) As Half" />
      <MemberSignature Language="F#" Value="static member CreateSaturating : 'Other -&gt; Half (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Half.CreateSaturating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static Half CreateSaturating(TOther value) = System::Numerics::INumberBase&lt;Half&gt;::CreateSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <summary>Creates an instance of the current type from a value, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, saturating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static Half CreateTruncating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half CreateTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.CreateTruncating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther) As Half" />
      <MemberSignature Language="F#" Value="static member CreateTruncating : 'Other -&gt; Half (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Half.CreateTruncating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static Half CreateTruncating(TOther value) = System::Numerics::INumberBase&lt;Half&gt;::CreateTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <summary>Creates an instance of the current type from a value, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, truncating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public static Half E { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half E" />
      <MemberSignature Language="DocId" Value="P:System.Half.E" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property E As Half" />
      <MemberSignature Language="F#" Value="static member E : Half" Usage="E" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half E { Half get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IFloatingPointConstants`1.E</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the mathematical constant <c>e</c>.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.IFloatingPointConstants`1.E" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public static Half Epsilon { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half Epsilon" />
      <MemberSignature Language="DocId" Value="P:System.Half.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Epsilon As Half" />
      <MemberSignature Language="F#" Value="static member Epsilon : Half" Usage="System.Half.Epsilon" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half Epsilon { Half get(); };" />
      <MemberSignature Language="F#" Value="static member Epsilon : Half" Usage="Epsilon" FrameworkAlternate="net-7.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">P:System.Numerics.IFloatingPointIeee754`1.Epsilon</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the smallest positive <see cref="T:System.Half" /> value that is greater than zero.</summary>
        <value>5.9604645E-08</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (Half other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Half other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Equals(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Half) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : Half -&gt; bool" Usage="half.Equals other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Half other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="other">A half-precision floating point number to compare to this instance.</param>
        <summary>Compares this instance for equality with <paramref name="other" />.</summary>
        <returns>
          <see langword="true" /> if the current object is equal to <paramref name="other" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object? obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="half.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0;net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="obj">The object to compare to this instance.</param>
        <summary>Returns a value that indicates whether this instance is equal to the specified <paramref name="obj" />.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> is an instance of <see cref="T:System.Half" /> and equals the value of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static Half Exp (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Exp(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Exp(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Exp : Half -&gt; Half" Usage="System.Half.Exp x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Exp(Half x) = System::Numerics::IExponentialFunctions&lt;Half&gt;::Exp;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IExponentialFunctions`1.Exp(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes <c>E</c> raised to a given power.</summary>
        <returns>
          <c>E</c> raised to the power of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IExponentialFunctions`1.Exp(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Exp10">
      <MemberSignature Language="C#" Value="public static Half Exp10 (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Exp10(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Exp10(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp10 (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Exp10 : Half -&gt; Half" Usage="System.Half.Exp10 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Exp10(Half x) = System::Numerics::IExponentialFunctions&lt;Half&gt;::Exp10;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IExponentialFunctions`1.Exp10(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes <c>10</c> raised to a given power.</summary>
        <returns>
          <c>10<sup><paramref name="x" /></sup></c>
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IExponentialFunctions`1.Exp10(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Exp10M1">
      <MemberSignature Language="C#" Value="public static Half Exp10M1 (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Exp10M1(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Exp10M1(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp10M1 (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Exp10M1 : Half -&gt; Half" Usage="System.Half.Exp10M1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Exp10M1(Half x) = System::Numerics::IExponentialFunctions&lt;Half&gt;::Exp10M1;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IExponentialFunctions`1.Exp10M1(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes <c>10</c> raised to a given power and subtracts one.</summary>
        <returns>
          <c>10<sup><paramref name="x" /></sup> - 1</c>
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IExponentialFunctions`1.Exp10M1(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Exp2">
      <MemberSignature Language="C#" Value="public static Half Exp2 (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Exp2(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Exp2(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp2 (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Exp2 : Half -&gt; Half" Usage="System.Half.Exp2 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Exp2(Half x) = System::Numerics::IExponentialFunctions&lt;Half&gt;::Exp2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IExponentialFunctions`1.Exp2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes <c>2</c> raised to a given power.</summary>
        <returns>
          <c>2<sup><paramref name="x" /></sup></c>
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IExponentialFunctions`1.Exp2(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Exp2M1">
      <MemberSignature Language="C#" Value="public static Half Exp2M1 (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Exp2M1(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Exp2M1(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp2M1 (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Exp2M1 : Half -&gt; Half" Usage="System.Half.Exp2M1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Exp2M1(Half x) = System::Numerics::IExponentialFunctions&lt;Half&gt;::Exp2M1;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IExponentialFunctions`1.Exp2M1(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes <c>2</c> raised to a given power and subtracts one.</summary>
        <returns>
          <c>2<sup><paramref name="x" /></sup> - 1</c>
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IExponentialFunctions`1.Exp2M1(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ExpM1">
      <MemberSignature Language="C#" Value="public static Half ExpM1 (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half ExpM1(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.ExpM1(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpM1 (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member ExpM1 : Half -&gt; Half" Usage="System.Half.ExpM1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half ExpM1(Half x) = System::Numerics::IExponentialFunctions&lt;Half&gt;::ExpM1;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IExponentialFunctions`1.ExpM1(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes <c>E</c> raised to a given power and subtracts one.</summary>
        <returns>
          <c>E<sup><paramref name="x" /></sup> - 1</c>
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IExponentialFunctions`1.ExpM1(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static Half Floor (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Floor(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Floor(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Floor : Half -&gt; Half" Usage="System.Half.Floor x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Floor(Half x) = System::Numerics::IFloatingPoint&lt;Half&gt;::Floor;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.Floor(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the floor of a value.</summary>
        <returns>The floor of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.Floor(`0)" />
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd">
      <MemberSignature Language="C#" Value="public static Half FusedMultiplyAdd (Half left, Half right, Half addend);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half FusedMultiplyAdd(valuetype System.Half left, valuetype System.Half right, valuetype System.Half addend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.FusedMultiplyAdd(System.Half,System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FusedMultiplyAdd (left As Half, right As Half, addend As Half) As Half" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : Half * Half * Half -&gt; Half" Usage="System.Half.FusedMultiplyAdd (left, right, addend)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half FusedMultiplyAdd(Half left, Half right, Half addend) = System::Numerics::IFloatingPointIeee754&lt;Half&gt;::FusedMultiplyAdd;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPointIeee754`1.FusedMultiplyAdd(`0,`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="right" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
        <Parameter Name="addend" Type="System.Half" Index="2" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="addend">To be added.</param>
        <summary>Computes the fused multiply-add of three values.</summary>
        <returns>The result of <paramref name="left" /> times <paramref name="right" /> plus <paramref name="addend" /> computed as one ternary operation.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPointIeee754`1.FusedMultiplyAdd(`0,`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="half.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this instance.</summary>
        <returns>A 32-bit signed integer hash code.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hypot">
      <MemberSignature Language="C#" Value="public static Half Hypot (Half x, Half y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Hypot(valuetype System.Half x, valuetype System.Half y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Hypot(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Hypot (x As Half, y As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Hypot : Half * Half -&gt; Half" Usage="System.Half.Hypot (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Hypot(Half x, Half y) = System::Numerics::IRootFunctions&lt;Half&gt;::Hypot;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IRootFunctions`1.Hypot(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="y" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>Computes the hypotenuse given two values representing the lengths of the shorter sides in a right-angled triangle.</summary>
        <returns>The square root of <paramref name="x" />-squared plus <paramref name="y" />-squared.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IRootFunctions`1.Hypot(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder">
      <MemberSignature Language="C#" Value="public static Half Ieee754Remainder (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Ieee754Remainder(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Ieee754Remainder(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ieee754Remainder (left As Half, right As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : Half * Half -&gt; Half" Usage="System.Half.Ieee754Remainder (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Ieee754Remainder(Half left, Half right) = System::Numerics::IFloatingPointIeee754&lt;Half&gt;::Ieee754Remainder;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPointIeee754`1.Ieee754Remainder(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="right" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Computes the remainder of two values as specified by IEEE 754.</summary>
        <returns>The remainder of <paramref name="left" /> divided-by <paramref name="right" /> as specified by IEEE 754.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPointIeee754`1.Ieee754Remainder(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="ILogB">
      <MemberSignature Language="C#" Value="public static int ILogB (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ILogB(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.ILogB(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ILogB (x As Half) As Integer" />
      <MemberSignature Language="F#" Value="static member ILogB : Half -&gt; int" Usage="System.Half.ILogB x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ILogB(Half x) = System::Numerics::IFloatingPointIeee754&lt;Half&gt;::ILogB;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPointIeee754`1.ILogB(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the integer logarithm of a value.</summary>
        <returns>The integer logarithm of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPointIeee754`1.ILogB(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsEvenInteger">
      <MemberSignature Language="C#" Value="public static bool IsEvenInteger (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEvenInteger(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsEvenInteger(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEvenInteger (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsEvenInteger : Half -&gt; bool" Usage="System.Half.IsEvenInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEvenInteger(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsEvenInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsEvenInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Determines if a value represents an even integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an even integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `2.0` will return `true` while `2.2` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsOddInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsEvenInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsFinite(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsFinite : Half -&gt; bool" Usage="System.Half.IsFinite value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(Half value);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsFinite;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.INumberBase`1.IsFinite(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Half" /> floating-point number.</param>
        <summary>Determines whether the specified value is finite (zero, subnormal, or normal).</summary>
        <returns>
          <see langword="true" /> if the specified value is finite (zero, subnormal or normal); otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsInfinity(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsInfinity : Half -&gt; bool" Usage="System.Half.IsInfinity value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(Half value);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsInfinity;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.INumberBase`1.IsInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Half" /> floating-point number.</param>
        <summary>Returns a value indicating whether the specified number evaluates to positive infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> evaluates to <see cref="P:System.Half.PositiveInfinity" />; otherwise <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInteger">
      <MemberSignature Language="C#" Value="public static bool IsInteger (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInteger(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsInteger(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInteger (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsInteger : Half -&gt; bool" Usage="System.Half.IsInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInteger(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Determines if a value represents an integral value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `2.0` and `3.0` will return `true` while `2.2` and `3.3` will return `false`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsNaN(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNaN : Half -&gt; bool" Usage="System.Half.IsNaN value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(Half value);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsNaN;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.INumberBase`1.IsNaN(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Half" /> floating-point number.</param>
        <summary>Determines whether the specified value is not a number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> evaluates to not a number <see cref="P:System.Half.NaN" />; otherwise <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsNegative(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegative : Half -&gt; bool" Usage="System.Half.IsNegative value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(Half value);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsNegative;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.INumberBase`1.IsNegative(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Half" /> floating-point number.</param>
        <summary>Determines whether the specified value is negative.</summary>
        <returns>
          <see langword="true" /> if negative; <see langword="false" /> otherwise.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsNegativeInfinity(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : Half -&gt; bool" Usage="System.Half.IsNegativeInfinity value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(Half value);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsNegativeInfinity;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.INumberBase`1.IsNegativeInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Half" /> floating-point number.</param>
        <summary>Determines whether the specified value is negative infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> evaluates to <see cref="P:System.Half.NegativeInfinity" />; otherwise <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsNormal(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNormal : Half -&gt; bool" Usage="System.Half.IsNormal value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(Half value);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsNormal;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.INumberBase`1.IsNormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Half" /> floating-point number.</param>
        <summary>Determines whether the specified value is normal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is normal; <see langword="false" /> otherwise.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOddInteger">
      <MemberSignature Language="C#" Value="public static bool IsOddInteger (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOddInteger(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsOddInteger(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOddInteger (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsOddInteger : Half -&gt; bool" Usage="System.Half.IsOddInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOddInteger(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsOddInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsOddInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Determines if a value represents an odd integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an odd integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `3.0` will return `true` while `3.3` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsEvenInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsOddInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsPositive">
      <MemberSignature Language="C#" Value="public static bool IsPositive (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositive(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsPositive(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositive (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPositive : Half -&gt; bool" Usage="System.Half.IsPositive value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositive(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsPositive;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositive(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Determines if a value is positive.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsNegative(%600)> will return `true`. A complex number, `a + bi` for non-zero `b`, is not positive or negative

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsPositive(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsPositiveInfinity(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : Half -&gt; bool" Usage="System.Half.IsPositiveInfinity value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(Half value);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsPositiveInfinity;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.INumberBase`1.IsPositiveInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Half" /> floating-point number.</param>
        <summary>Determines whether the specified value is positive infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> evaluates to <see cref="P:System.Half.PositiveInfinity" />; otherwise <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPow2">
      <MemberSignature Language="C#" Value="public static bool IsPow2 (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPow2(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsPow2(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPow2 (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPow2 : Half -&gt; bool" Usage="System.Half.IsPow2 value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPow2(Half value) = System::Numerics::IBinaryNumber&lt;Half&gt;::IsPow2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.IsPow2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Determines if a value is a power of two.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a power of two; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryNumber`1.IsPow2(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsRealNumber">
      <MemberSignature Language="C#" Value="public static bool IsRealNumber (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsRealNumber(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsRealNumber(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRealNumber (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsRealNumber : Half -&gt; bool" Usage="System.Half.IsRealNumber value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsRealNumber(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsRealNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsRealNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Determines if a value represents a real number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a real number; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This function returns `true` for a complex number `a + bi` where `b` is zero.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsRealNumber(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.IsSubnormal(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (value As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : Half -&gt; bool" Usage="System.Half.IsSubnormal value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(Half value);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(Half value) = System::Numerics::INumberBase&lt;Half&gt;::IsSubnormal;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.INumberBase`1.IsSubnormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Half" /> floating-point number.</param>
        <summary>Determines whether the specified value is subnormal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is subnormal; <see langword="false" /><see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static Half Log (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Log(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Log(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Log : Half -&gt; Half" Usage="System.Half.Log x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Log(Half x) = System::Numerics::ILogarithmicFunctions&lt;Half&gt;::Log;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ILogarithmicFunctions`1.Log(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the natural (<c>base-E</c> logarithm of a value.</summary>
        <returns>The natural logarithm of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.ILogarithmicFunctions`1.Log(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static Half Log (Half x, Half newBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Log(valuetype System.Half x, valuetype System.Half newBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Log(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Half, newBase As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Log : Half * Half -&gt; Half" Usage="System.Half.Log (x, newBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Log(Half x, Half newBase) = System::Numerics::ILogarithmicFunctions&lt;Half&gt;::Log;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ILogarithmicFunctions`1.Log(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="newBase" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="newBase">To be added.</param>
        <summary>Computes the logarithm of a value in the specified base.</summary>
        <returns>The base-<paramref name="newBase" /> logarithm of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.ILogarithmicFunctions`1.Log(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static Half Log10 (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Log10(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Log10(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Log10 : Half -&gt; Half" Usage="System.Half.Log10 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Log10(Half x) = System::Numerics::ILogarithmicFunctions&lt;Half&gt;::Log10;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ILogarithmicFunctions`1.Log10(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the base-10 logarithm of a value.</summary>
        <returns>The base-10 logarithm of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.ILogarithmicFunctions`1.Log10(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Log10P1">
      <MemberSignature Language="C#" Value="public static Half Log10P1 (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Log10P1(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Log10P1(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10P1 (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Log10P1 : Half -&gt; Half" Usage="System.Half.Log10P1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Log10P1(Half x) = System::Numerics::ILogarithmicFunctions&lt;Half&gt;::Log10P1;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ILogarithmicFunctions`1.Log10P1(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the base-10 logarithm of a value plus one.</summary>
        <returns>
          <c>log<sub>10</sub>(<paramref name="x" /> + 1)</c>
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.ILogarithmicFunctions`1.Log10P1(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static Half Log2 (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Log2(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Log2(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (value As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Log2 : Half -&gt; Half" Usage="System.Half.Log2 value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Log2(Half value) = System::Numerics::IBinaryNumber&lt;Half&gt;::Log2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.Log2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Computes the log2 of a value.</summary>
        <returns>The log2 of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryNumber`1.Log2(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Log2P1">
      <MemberSignature Language="C#" Value="public static Half Log2P1 (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Log2P1(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Log2P1(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2P1 (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Log2P1 : Half -&gt; Half" Usage="System.Half.Log2P1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Log2P1(Half x) = System::Numerics::ILogarithmicFunctions&lt;Half&gt;::Log2P1;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ILogarithmicFunctions`1.Log2P1(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the base-2 logarithm of a value plus one.</summary>
        <returns>
          <c>log<sub>2</sub>(<paramref name="x" /> + 1)</c>
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.ILogarithmicFunctions`1.Log2P1(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LogP1">
      <MemberSignature Language="C#" Value="public static Half LogP1 (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half LogP1(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.LogP1(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogP1 (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member LogP1 : Half -&gt; Half" Usage="System.Half.LogP1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half LogP1(Half x) = System::Numerics::ILogarithmicFunctions&lt;Half&gt;::LogP1;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ILogarithmicFunctions`1.LogP1(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the natural (<c>base-E</c>) logarithm of a value plus one.</summary>
        <returns>
          <c>log<sub>e</sub>(<paramref name="x" /> + 1)</c>
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.ILogarithmicFunctions`1.LogP1(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Half Max (Half x, Half y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Max(valuetype System.Half x, valuetype System.Half y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Max(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As Half, y As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Max : Half * Half -&gt; Half" Usage="System.Half.Max (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Max(Half x, Half y) = System::Numerics::INumber&lt;Half&gt;::Max;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Max(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="y" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `maximum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Max(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static Half MaxMagnitude (Half x, Half y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half MaxMagnitude(valuetype System.Half x, valuetype System.Half y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.MaxMagnitude(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As Half, y As Half) As Half" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : Half * Half -&gt; Half" Usage="System.Half.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half MaxMagnitude(Half x, Half y) = System::Numerics::INumberBase&lt;Half&gt;::MaxMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="y" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `maximumMagnitude` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.MaxMagnitude(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber">
      <MemberSignature Language="C#" Value="public static Half MaxMagnitudeNumber (Half x, Half y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half MaxMagnitudeNumber(valuetype System.Half x, valuetype System.Half y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.MaxMagnitudeNumber(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitudeNumber (x As Half, y As Half) As Half" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : Half * Half -&gt; Half" Usage="System.Half.MaxMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half MaxMagnitudeNumber(Half x, Half y) = System::Numerics::INumberBase&lt;Half&gt;::MaxMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="y" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>Compares two values to compute which has the greater magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `maximumMagnitudeNumber` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.MaxMagnitudeNumber(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MaxNumber">
      <MemberSignature Language="C#" Value="public static Half MaxNumber (Half x, Half y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half MaxNumber(valuetype System.Half x, valuetype System.Half y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.MaxNumber(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxNumber (x As Half, y As Half) As Half" />
      <MemberSignature Language="F#" Value="static member MaxNumber : Half * Half -&gt; Half" Usage="System.Half.MaxNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half MaxNumber(Half x, Half y) = System::Numerics::INumber&lt;Half&gt;::MaxNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.MaxNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="y" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>Compares two values to compute which is greater and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `maximumNumber` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.MaxNumber(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public static Half MaxValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half MaxValue" />
      <MemberSignature Language="DocId" Value="P:System.Half.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxValue As Half" />
      <MemberSignature Language="F#" Value="static member MaxValue : Half" Usage="System.Half.MaxValue" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half MaxValue { Half get(); };" />
      <MemberSignature Language="F#" Value="static member MaxValue : Half" Usage="MaxValue" FrameworkAlternate="net-7.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">P:System.Numerics.IMinMaxValue`1.MaxValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the largest possible value of <see cref="T:System.Half" />.</summary>
        <value>65504</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.IMinMaxValue`1.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Half Min (Half x, Half y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Min(valuetype System.Half x, valuetype System.Half y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Min(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As Half, y As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Min : Half * Half -&gt; Half" Usage="System.Half.Min (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Min(Half x, Half y) = System::Numerics::INumber&lt;Half&gt;::Min;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Min(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="y" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `minimum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Min(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static Half MinMagnitude (Half x, Half y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half MinMagnitude(valuetype System.Half x, valuetype System.Half y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.MinMagnitude(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As Half, y As Half) As Half" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : Half * Half -&gt; Half" Usage="System.Half.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half MinMagnitude(Half x, Half y) = System::Numerics::INumberBase&lt;Half&gt;::MinMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="y" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `minimumMagnitude` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.MinMagnitude(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber">
      <MemberSignature Language="C#" Value="public static Half MinMagnitudeNumber (Half x, Half y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half MinMagnitudeNumber(valuetype System.Half x, valuetype System.Half y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.MinMagnitudeNumber(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitudeNumber (x As Half, y As Half) As Half" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : Half * Half -&gt; Half" Usage="System.Half.MinMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half MinMagnitudeNumber(Half x, Half y) = System::Numerics::INumberBase&lt;Half&gt;::MinMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="y" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>Compares two values to compute which has the lesser magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `minimumMagnitudeNumber` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.MinMagnitudeNumber(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MinNumber">
      <MemberSignature Language="C#" Value="public static Half MinNumber (Half x, Half y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half MinNumber(valuetype System.Half x, valuetype System.Half y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.MinNumber(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinNumber (x As Half, y As Half) As Half" />
      <MemberSignature Language="F#" Value="static member MinNumber : Half * Half -&gt; Half" Usage="System.Half.MinNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half MinNumber(Half x, Half y) = System::Numerics::INumber&lt;Half&gt;::MinNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.MinNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="y" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>Compares two values to compute which is lesser and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `minimumNumber` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.MinNumber(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public static Half MinValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half MinValue" />
      <MemberSignature Language="DocId" Value="P:System.Half.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinValue As Half" />
      <MemberSignature Language="F#" Value="static member MinValue : Half" Usage="System.Half.MinValue" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half MinValue { Half get(); };" />
      <MemberSignature Language="F#" Value="static member MinValue : Half" Usage="MinValue" FrameworkAlternate="net-7.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">P:System.Numerics.IMinMaxValue`1.MinValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the smallest possible value of <see cref="T:System.Half" />.</summary>
        <value>-65504</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.IMinMaxValue`1.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MultiplicativeIdentity">
      <MemberSignature Language="C#" Value="public static Half MultiplicativeIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half MultiplicativeIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Half.MultiplicativeIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MultiplicativeIdentity As Half" />
      <MemberSignature Language="F#" Value="static member MultiplicativeIdentity : Half" Usage="MultiplicativeIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half MultiplicativeIdentity { Half get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMultiplicativeIdentity`2.MultiplicativeIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the multiplicative identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.IMultiplicativeIdentity`2.MultiplicativeIdentity" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public static Half NaN { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half NaN" />
      <MemberSignature Language="DocId" Value="P:System.Half.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NaN As Half" />
      <MemberSignature Language="F#" Value="static member NaN : Half" Usage="System.Half.NaN" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half NaN { Half get(); };" />
      <MemberSignature Language="F#" Value="static member NaN : Half" Usage="NaN" FrameworkAlternate="net-7.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">P:System.Numerics.IFloatingPointIeee754`1.NaN</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents not a number.</summary>
        <value>NaN.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public static Half NegativeInfinity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half NegativeInfinity" />
      <MemberSignature Language="DocId" Value="P:System.Half.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NegativeInfinity As Half" />
      <MemberSignature Language="F#" Value="static member NegativeInfinity : Half" Usage="System.Half.NegativeInfinity" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half NegativeInfinity { Half get(); };" />
      <MemberSignature Language="F#" Value="static member NegativeInfinity : Half" Usage="NegativeInfinity" FrameworkAlternate="net-7.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents negative infinity.</summary>
        <value>-Infinity.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NegativeOne">
      <MemberSignature Language="C#" Value="public static Half NegativeOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half NegativeOne" />
      <MemberSignature Language="DocId" Value="P:System.Half.NegativeOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NegativeOne As Half" />
      <MemberSignature Language="F#" Value="static member NegativeOne : Half" Usage="NegativeOne" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half NegativeOne { Half get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.ISignedNumber`1.NegativeOne</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>-1</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.ISignedNumber`1.NegativeOne" />
      </Docs>
    </Member>
    <Member MemberName="NegativeZero">
      <MemberSignature Language="C#" Value="public static Half NegativeZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half NegativeZero" />
      <MemberSignature Language="DocId" Value="P:System.Half.NegativeZero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NegativeZero As Half" />
      <MemberSignature Language="F#" Value="static member NegativeZero : Half" Usage="NegativeZero" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half NegativeZero { Half get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IFloatingPointIeee754`1.NegativeZero</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that represents negative <c>zero</c>.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeZero" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static Half One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half One" />
      <MemberSignature Language="DocId" Value="P:System.Half.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As Half" />
      <MemberSignature Language="F#" Value="static member One : Half" Usage="One" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half One { Half get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.One</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>1</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.INumberBase`1.One" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static Half operator + (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Addition(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Addition(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Half, right As Half) As Half" />
      <MemberSignature Language="F#" Value="static member ( + ) : Half * Half -&gt; Half" Usage="left + right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half operator +(Half left, Half right) = System::Numerics::IAdditionOperators&lt;Half, Half, Half&gt;::op_Addition;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IAdditionOperators`3.op_Addition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="right" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Adds two values together to compute their sum.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IAdditionOperators`3.op_Addition(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_CheckedExplicit">
      <MemberSignature Language="C#" Value="public static byte op_CheckedExplicit (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_CheckedExplicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_CheckedExplicit(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedExplicit (value As Half) As Byte" />
      <MemberSignature Language="F#" Value="static member op_CheckedExplicit : Half -&gt; byte" Usage="System.Half.op_CheckedExplicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte op_CheckedExplicit(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static Half operator -- (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Decrement(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Decrement(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As Half) As Half" />
      <MemberSignature Language="F#" Value="static member op_Decrement : Half -&gt; Half" Usage="System.Half.op_Decrement value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half operator --(Half value) = System::Numerics::IDecrementOperators&lt;Half&gt;::op_Decrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_Decrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IDecrementOperators`1.op_Decrement(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static Half operator / (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Division(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Division(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Half, right As Half) As Half" />
      <MemberSignature Language="F#" Value="static member ( / ) : Half * Half -&gt; Half" Usage="left / right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half operator /(Half left, Half right) = System::Numerics::IDivisionOperators&lt;Half, Half, Half&gt;::op_Division;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDivisionOperators`3.op_Division(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="right" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Divides two values together to compute their quotient.</summary>
        <returns>The quotient of <paramref name="left" /> divided-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IDivisionOperators`3.op_Division(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Equality(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Half, right As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( = ) : Half * Half -&gt; bool" Usage="left = right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Half left, Half right);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Half left, Half right) = System::Numerics::IEqualityOperators&lt;Half, Half, bool&gt;::op_Equality;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" />
        <Parameter Name="right" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="left">The first value to compare.</param>
        <param name="right">The second value to compare.</param>
        <summary>Returns a value that indicates whether two specified <see cref="T:System.Half" /> values are equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Char)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Char) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : char -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Char" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Decimal)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Decimal" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Double)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">The double-precision floating point value to convert to <see cref="T:System.Half" />.</param>
        <summary>An explicit operator to convert a <see cref="T:System.Double" /> value to a <see cref="T:System.Half" />.</summary>
        <returns>The <see cref="T:System.Half" /> representation of the specified double-precision floating point <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As Byte" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; byte" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.Byte" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.Byte" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator char (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname char op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.Char" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As Char" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; char" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator char(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.Char" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.Char" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As Decimal" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; decimal" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.Decimal" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.Decimal" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As Double" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; double" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="value">The half-precision floating point value to convert to <see cref="T:System.Double" />.</param>
        <summary>An explicit operator to convert a <see cref="T:System.Half" /> value to a <see cref="T:System.Double" />.</summary>
        <returns>The <see cref="T:System.Double" /> representation of the specified half-precision floating point <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Int128 (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Int128 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.Int128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As Int128" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; Int128" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Int128(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.Int128" />.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit signed integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As Short" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; int16" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.Int16" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.Int16" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As Integer" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; int" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.Int32" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.Int32" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As Long" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; int64" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.Int64" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.Int64" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As IntPtr" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; nativeint" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.IntPtr" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.IntPtr" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As SByte" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; sbyte" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.SByte" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.SByte" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As Single" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; single" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="value">The half-precision floating point value to convert to <see cref="T:System.Single" />.</param>
        <summary>An explicit operator to convert a <see cref="T:System.Half" /> value to a <see cref="T:System.Single" />.</summary>
        <returns>The <see cref="T:System.Single" /> representation of the specified half-precision floating point <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UInt128 (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; UInt128" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UInt128(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.UInt128" />.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As UShort" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; uint16" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.UInt16" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.UInt16" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As UInteger" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; uint32" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.UInt32" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.UInt32" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As ULong" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; uint64" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.UInt64" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.UInt64" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UIntPtr (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native unsigned int op_Explicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Half)~System.UIntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Half) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Half -&gt; unativeint" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UIntPtr(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a half-precision floating-point value to its nearest representable <see cref="T:System.UIntPtr" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable <see cref="T:System.UIntPtr" /> value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Int16)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Short) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int16 -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Int16" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Int32)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Int32" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Int64)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Long) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int64 -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Int64" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.IntPtr)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeint -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.IntPtr" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.Single)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">The single-precision floating point value to convert to <see cref="T:System.Half" />.</param>
        <summary>An explicit operator to convert a <see cref="T:System.Single" /> value to a <see cref="T:System.Half" />.</summary>
        <returns>The <see cref="T:System.Half" /> representation of the specified single-precision floating point <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.UInt16)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UShort) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : uint16 -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.UInt16" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.UInt32)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInteger) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : uint32 -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.UInt32" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.UInt64)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As ULong) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : uint64 -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.UInt64" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Explicit(System.UIntPtr)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UIntPtr) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : unativeint -&gt; Half" Usage="System.Half.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(UIntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.UIntPtr" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_GreaterThan(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Half, right As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : Half * Half -&gt; bool" Usage="left &gt; right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(Half left, Half right);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(Half left, Half right) = System::Numerics::IComparisonOperators&lt;Half, Half, bool&gt;::op_GreaterThan;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" />
        <Parameter Name="right" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="left">The first value to compare.</param>
        <param name="right">The second value to compare.</param>
        <summary>Returns a value that indicates whether a specified <see cref="T:System.Half" /> value is greater than another specified <see cref="T:System.Half" /> value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_GreaterThanOrEqual(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Half, right As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : Half * Half -&gt; bool" Usage="left &gt;= right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(Half left, Half right);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(Half left, Half right) = System::Numerics::IComparisonOperators&lt;Half, Half, bool&gt;::op_GreaterThanOrEqual;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" />
        <Parameter Name="right" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="left">The first value to compare.</param>
        <param name="right">The second value to compare.</param>
        <summary>Returns a value that indicates whether <paramref name="left" /> is greater than or equal to <paramref name="right" />.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Half (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Implicit(System.Byte)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Half" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; Half" Usage="System.Half.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Half(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.Byte" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Half (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Implicit(System.SByte)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Half" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; Half" Usage="System.Half.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Half(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.SByte" /> value to its nearest representable half-precision floating-point value.</summary>
        <returns>
          <paramref name="value" /> converted to its nearest representable half-precision floating-point value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static Half operator ++ (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Increment(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Increment(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As Half) As Half" />
      <MemberSignature Language="F#" Value="static member op_Increment : Half -&gt; Half" Usage="System.Half.op_Increment value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half operator ++(Half value) = System::Numerics::IIncrementOperators&lt;Half&gt;::op_Increment;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_Increment(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IIncrementOperators`1.op_Increment(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Inequality(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Half, right As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Half * Half -&gt; bool" Usage="System.Half.op_Inequality (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Half left, Half right);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Half left, Half right) = System::Numerics::IEqualityOperators&lt;Half, Half, bool&gt;::op_Inequality;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" />
        <Parameter Name="right" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="left">The first value to compare.</param>
        <param name="right">The second value to compare.</param>
        <summary>Returns a value that indicates whether two specified <see cref="T:System.Half" /> values are not equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_LessThan(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Half, right As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : Half * Half -&gt; bool" Usage="left &lt; right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(Half left, Half right);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(Half left, Half right) = System::Numerics::IComparisonOperators&lt;Half, Half, bool&gt;::op_LessThan;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" />
        <Parameter Name="right" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="left">The first value to compare.</param>
        <param name="right">The second value to compare.</param>
        <summary>Returns a value that indicates whether a specified <see cref="T:System.Half" /> value is less than another specified <see cref="T:System.Half" /> value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_LessThanOrEqual(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Half, right As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : Half * Half -&gt; bool" Usage="left &lt;= right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(Half left, Half right);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(Half left, Half right) = System::Numerics::IComparisonOperators&lt;Half, Half, bool&gt;::op_LessThanOrEqual;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" />
        <Parameter Name="right" Type="System.Half" />
      </Parameters>
      <Docs>
        <param name="left">The first value to compare.</param>
        <param name="right">The second value to compare.</param>
        <summary>Returns a value that indicates whether a specified <see cref="T:System.Half" /> value is less than or equal to another specified <see cref="T:System.Half" /> value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static Half operator % (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Modulus(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Modulus(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (left As Half, right As Half) As Half" />
      <MemberSignature Language="F#" Value="static member ( % ) : Half * Half -&gt; Half" Usage="left % right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half operator %(Half left, Half right) = System::Numerics::IModulusOperators&lt;Half, Half, Half&gt;::op_Modulus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IModulusOperators`3.op_Modulus(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="right" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Divides two values together to compute their modulus or remainder.</summary>
        <returns>The modulus or remainder of <paramref name="left" /> divided-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IModulusOperators`3.op_Modulus(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static Half operator * (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Multiply(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Multiply(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Half, right As Half) As Half" />
      <MemberSignature Language="F#" Value="static member ( * ) : Half * Half -&gt; Half" Usage="left * right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half operator *(Half left, Half right) = System::Numerics::IMultiplyOperators&lt;Half, Half, Half&gt;::op_Multiply;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IMultiplyOperators`3.op_Multiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="right" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Multiplies two values together to compute their product.</summary>
        <returns>The product of <paramref name="left" /> divided-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IMultiplyOperators`3.op_Multiply(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static Half operator - (Half left, Half right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Subtraction(valuetype System.Half left, valuetype System.Half right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_Subtraction(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Half, right As Half) As Half" />
      <MemberSignature Language="F#" Value="static member ( - ) : Half * Half -&gt; Half" Usage="left - right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half operator -(Half left, Half right) = System::Numerics::ISubtractionOperators&lt;Half, Half, Half&gt;::op_Subtraction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ISubtractionOperators`3.op_Subtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="right" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Subtracts two values to compute their difference.</summary>
        <returns>The difference of <paramref name="right" /> subtracted from <paramref name="left" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.ISubtractionOperators`3.op_Subtraction(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static Half operator - (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_UnaryNegation(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_UnaryNegation(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Half) As Half" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : Half -&gt; Half" Usage="- value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half operator -(Half value) = System::Numerics::IUnaryNegationOperators&lt;Half, Half&gt;::op_UnaryNegation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryNegationOperators`2.op_UnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Computes the unary negation of a value.</summary>
        <returns>The unary negation of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IUnaryNegationOperators`2.op_UnaryNegation(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static Half operator + (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_UnaryPlus(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.op_UnaryPlus(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As Half) As Half" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : Half -&gt; Half" Usage="+ value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half operator +(Half value) = System::Numerics::IUnaryPlusOperators&lt;Half, Half&gt;::op_UnaryPlus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryPlusOperators`2.op_UnaryPlus(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Computes the unary plus of a value.</summary>
        <returns>The unary plus of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IUnaryPlusOperators`2.op_UnaryPlus(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static Half Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Half" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; Half" Usage="System.Half.Parse s" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a number to convert.</param>
        <summary>Converts the string representation of a number to its half-precision floating-point number equivalent.</summary>
        <returns>A half-precision floating-point number equivalent to the numeric value or symbol specified in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> does not represent a number in a valid format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="P:System.Half.MinValue" /> or greater than <see cref="P:System.Half.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static Half Parse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), provider As IFormatProvider) As Half" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; Half" Usage="System.Half.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider) = ISpanParsable&lt;Half&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static Half Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Half" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; Half" Usage="System.Half.Parse (s, style)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a number to convert.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />.</param>
        <summary>Converts the string representation of a number in a specified style to its single-precision floating-point number equivalent.</summary>
        <returns>A half-precision floating-point number equivalent to the numeric value or symbol specified in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> does not represent a number in a valid format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="P:System.Half.MinValue" /> or greater than <see cref="P:System.Half.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.

           -or-

           <see cref="T:System.Globalization.NumberStyles" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> value.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static Half Parse (string s, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Half" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; Half" Usage="System.Half.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Parse(System::String ^ s, IFormatProvider ^ provider);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Parse(System::String ^ s, IFormatProvider ^ provider) = IParsable&lt;Half&gt;::Parse;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.IParsable`1.Parse(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a number to convert.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Converts the string representation of a number in a specified culture-specific format to its single-precision floating-point number equivalent.</summary>
        <returns>A half-precision floating-point number equivalent to the numeric value or symbol specified in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> does not represent a number in a valid format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="P:System.Half.MinValue" /> or greater than <see cref="P:System.Half.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static Half Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.Float, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.Float, Optional provider As IFormatProvider = Nothing) As Half" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; Half" Usage="System.Half.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Converts the string representation of a number to its half-precision floating-point number equivalent. A return value indicates whether the conversion succeeded or failed.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Converts the string representation of a number in a specified style and culture-specific format to its single-precision floating-point number equivalent.</summary>
        <returns>A half-precision floating-point number equivalent to the numeric value or symbol specified in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> does not represent a number in a valid format.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.

          -or-

          <see cref="T:System.Globalization.NumberStyles" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> value.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static Half Parse (string s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.Float, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, Optional style As NumberStyles = System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.Float, Optional provider As IFormatProvider = Nothing) As Half" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; Half" Usage="System.Half.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">M:System.Numerics.INumberBase`1.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a number to convert.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Converts the string representation of a number in a specified style and culture-specific format to its single-precision floating-point number equivalent.</summary>
        <returns>A half-precision floating-point number equivalent to the numeric value or symbol specified in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> does not represent a number in a valid format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="P:System.Half.MinValue" /> or greater than <see cref="P:System.Half.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.

          -or-

          <see cref="T:System.Globalization.NumberStyles" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> value.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Pi">
      <MemberSignature Language="C#" Value="public static Half Pi { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half Pi" />
      <MemberSignature Language="DocId" Value="P:System.Half.Pi" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Pi As Half" />
      <MemberSignature Language="F#" Value="static member Pi : Half" Usage="Pi" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half Pi { Half get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IFloatingPointConstants`1.Pi</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the mathematical constant <c>pi</c>.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.IFloatingPointConstants`1.Pi" />
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public static Half PositiveInfinity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half PositiveInfinity" />
      <MemberSignature Language="DocId" Value="P:System.Half.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PositiveInfinity As Half" />
      <MemberSignature Language="F#" Value="static member PositiveInfinity : Half" Usage="System.Half.PositiveInfinity" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half PositiveInfinity { Half get(); };" />
      <MemberSignature Language="F#" Value="static member PositiveInfinity : Half" Usage="PositiveInfinity" FrameworkAlternate="net-7.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0">P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents positive infinity.</summary>
        <value>Infinity.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static Half Pow (Half x, Half y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Pow(valuetype System.Half x, valuetype System.Half y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Pow(System.Half,System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Half, y As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Pow : Half * Half -&gt; Half" Usage="System.Half.Pow (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Pow(Half x, Half y) = System::Numerics::IPowerFunctions&lt;Half&gt;::Pow;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IPowerFunctions`1.Pow(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="y" Type="System.Half" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>Computes a value raised to a given power.</summary>
        <returns>
          <paramref name="x" /> raised to the power of <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IPowerFunctions`1.Pow(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="ReciprocalEstimate">
      <MemberSignature Language="C#" Value="public static Half ReciprocalEstimate (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half ReciprocalEstimate(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.ReciprocalEstimate(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReciprocalEstimate (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member ReciprocalEstimate : Half -&gt; Half" Usage="System.Half.ReciprocalEstimate x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half ReciprocalEstimate(Half x) = System::Numerics::IFloatingPointIeee754&lt;Half&gt;::ReciprocalEstimate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPointIeee754`1.ReciprocalEstimate(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes an estimate of the reciprocal of a value.</summary>
        <returns>An estimate of the reciprocal of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPointIeee754`1.ReciprocalEstimate(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ReciprocalSqrtEstimate">
      <MemberSignature Language="C#" Value="public static Half ReciprocalSqrtEstimate (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half ReciprocalSqrtEstimate(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.ReciprocalSqrtEstimate(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReciprocalSqrtEstimate (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member ReciprocalSqrtEstimate : Half -&gt; Half" Usage="System.Half.ReciprocalSqrtEstimate x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half ReciprocalSqrtEstimate(Half x) = System::Numerics::IFloatingPointIeee754&lt;Half&gt;::ReciprocalSqrtEstimate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPointIeee754`1.ReciprocalSqrtEstimate(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes an estimate of the reciprocal square root of a value.</summary>
        <returns>An estimate of the reciprocal square root of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPointIeee754`1.ReciprocalSqrtEstimate(`0)" />
      </Docs>
    </Member>
    <Member MemberName="RootN">
      <MemberSignature Language="C#" Value="public static Half RootN (Half x, int n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half RootN(valuetype System.Half x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.RootN(System.Half,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RootN (x As Half, n As Integer) As Half" />
      <MemberSignature Language="F#" Value="static member RootN : Half * int -&gt; Half" Usage="System.Half.RootN (x, n)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half RootN(Half x, int n) = System::Numerics::IRootFunctions&lt;Half&gt;::RootN;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IRootFunctions`1.RootN(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="n">To be added.</param>
        <summary>Computes the n-th root of a value.</summary>
        <returns>The <paramref name="n" />-th root of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IRootFunctions`1.RootN(`0,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static Half Round (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Round(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Round(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Round : Half -&gt; Half" Usage="System.Half.Round x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Round(Half x) = System::Numerics::IFloatingPoint&lt;Half&gt;::Round;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.Round(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Rounds a value to the nearest integer using the default rounding mode (<see cref="F:System.MidpointRounding.ToEven" />).</summary>
        <returns>The result of rounding <paramref name="x" /> to the nearest integer using the default rounding mode.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.Round(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static Half Round (Half x, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Round(valuetype System.Half x, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Round(System.Half,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Half, digits As Integer) As Half" />
      <MemberSignature Language="F#" Value="static member Round : Half * int -&gt; Half" Usage="System.Half.Round (x, digits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Round(Half x, int digits) = System::Numerics::IFloatingPoint&lt;Half&gt;::Round;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.Round(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="digits" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="digits">To be added.</param>
        <summary>Rounds a value to a specified number of fractional-digits using the default rounding mode (<see cref="F:System.MidpointRounding.ToEven" />).</summary>
        <returns>The result of rounding <paramref name="x" /> to <paramref name="digits" /> fractional-digits using the default rounding mode.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.Round(`0,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static Half Round (Half x, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Round(valuetype System.Half x, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Round(System.Half,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Half, mode As MidpointRounding) As Half" />
      <MemberSignature Language="F#" Value="static member Round : Half * MidpointRounding -&gt; Half" Usage="System.Half.Round (x, mode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Round(Half x, MidpointRounding mode) = System::Numerics::IFloatingPoint&lt;Half&gt;::Round;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.Round(`0,System.MidpointRounding)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="mode">To be added.</param>
        <summary>Rounds a value to the nearest integer using the specified rounding mode.</summary>
        <returns>The result of rounding <paramref name="x" /> to the nearest integer using <paramref name="mode" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.Round(`0,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static Half Round (Half x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Round(valuetype System.Half x, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Round(System.Half,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Half, digits As Integer, mode As MidpointRounding) As Half" />
      <MemberSignature Language="F#" Value="static member Round : Half * int * MidpointRounding -&gt; Half" Usage="System.Half.Round (x, digits, mode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Round(Half x, int digits, MidpointRounding mode) = System::Numerics::IFloatingPoint&lt;Half&gt;::Round;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.Round(`0,System.Int32,System.MidpointRounding)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="digits" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="2" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="digits">To be added.</param>
        <param name="mode">To be added.</param>
        <summary>Rounds a value to a specified number of fractional-digits using the default rounding mode (<see cref="F:System.MidpointRounding.ToEven" />).</summary>
        <returns>The result of rounding <paramref name="x" /> to <paramref name="digits" /> fractional-digits using <paramref name="mode" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.Round(`0,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleB">
      <MemberSignature Language="C#" Value="public static Half ScaleB (Half x, int n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half ScaleB(valuetype System.Half x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.ScaleB(System.Half,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ScaleB (x As Half, n As Integer) As Half" />
      <MemberSignature Language="F#" Value="static member ScaleB : Half * int -&gt; Half" Usage="System.Half.ScaleB (x, n)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half ScaleB(Half x, int n) = System::Numerics::IFloatingPointIeee754&lt;Half&gt;::ScaleB;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPointIeee754`1.ScaleB(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="n">To be added.</param>
        <summary>Computes the product of a value and its base-radix raised to the specified power.</summary>
        <returns>The product of <paramref name="x" /> and base-radix raised to the power of <paramref name="n" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPointIeee754`1.ScaleB(`0,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Sign(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Half) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : Half -&gt; int" Usage="System.Half.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(Half value) = System::Numerics::INumber&lt;Half&gt;::Sign;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Sign(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Computes the sign of a value.</summary>
        <returns>A positive value if <paramref name="value" /> is positive, <see cref="P:System.Numerics.INumberBase`1.Zero" /> if <paramref name="value" /> is zero, and a negative value if <paramref name="value" /> is negative.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

It is recommended that a function return `1`, `0`, and `-1`, respectively.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Sign(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static Half Sin (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Sin(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Sin(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Sin : Half -&gt; Half" Usage="System.Half.Sin x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Sin(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::Sin;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.Sin(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the sine of a value.</summary>
        <returns>The sine of <paramref name="x" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `sin(x)`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.Sin(`0)" />
      </Docs>
    </Member>
    <Member MemberName="SinCos">
      <MemberSignature Language="C#" Value="public static (Half Sin, Half Cos) SinCos (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;valuetype System.Half, valuetype System.Half&gt; SinCos(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.SinCos(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SinCos (x As Half) As ValueTuple(Of Half, Half)" />
      <MemberSignature Language="F#" Value="static member SinCos : Half -&gt; ValueTuple&lt;Half, Half&gt;" Usage="System.Half.SinCos x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;Half, Half&gt; SinCos(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::SinCos;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.SinCos(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Half,System.Half&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Sin", "Cos" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Sin", "Cos" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the sine and cosine of a value.</summary>
        <returns>The sine and cosine of <paramref name="x" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `(sin(x), cos(x))`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.SinCos(`0)" />
      </Docs>
    </Member>
    <Member MemberName="SinCosPi">
      <MemberSignature Language="C#" Value="public static (Half SinPi, Half CosPi) SinCosPi (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;valuetype System.Half, valuetype System.Half&gt; SinCosPi(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.SinCosPi(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SinCosPi (x As Half) As ValueTuple(Of Half, Half)" />
      <MemberSignature Language="F#" Value="static member SinCosPi : Half -&gt; ValueTuple&lt;Half, Half&gt;" Usage="System.Half.SinCosPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;Half, Half&gt; SinCosPi(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::SinCosPi;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.SinCosPi(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Half,System.Half&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "SinPi", "CosPi" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "SinPi", "CosPi" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the sine and cosine of a value that has been multiplied by <c>pi</c>.</summary>
        <returns>The sine and cosine of<paramref name="x" /> multiplied-by <c>pi</c>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `(sin(x * π), cos(x * π))`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.SinCosPi(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static Half Sinh (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Sinh(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Sinh(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Sinh : Half -&gt; Half" Usage="System.Half.Sinh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Sinh(Half x) = System::Numerics::IHyperbolicFunctions&lt;Half&gt;::Sinh;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IHyperbolicFunctions`1.Sinh(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the hyperbolic sine of a value.</summary>
        <returns>The hyperbolic sine of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IHyperbolicFunctions`1.Sinh(`0)" />
      </Docs>
    </Member>
    <Member MemberName="SinPi">
      <MemberSignature Language="C#" Value="public static Half SinPi (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half SinPi(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.SinPi(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SinPi (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member SinPi : Half -&gt; Half" Usage="System.Half.SinPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half SinPi(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::SinPi;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.SinPi(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the sine of a value that has been multiplied by <c>pi</c>.</summary>
        <returns>The sine of <paramref name="x" /> multiplied-by <c>pi</c>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `sin(x * π)`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.SinPi(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static Half Sqrt (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Sqrt(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Sqrt(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Sqrt : Half -&gt; Half" Usage="System.Half.Sqrt x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Sqrt(Half x) = System::Numerics::IRootFunctions&lt;Half&gt;::Sqrt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IRootFunctions`1.Sqrt(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the square-root of a value.</summary>
        <returns>The square-root of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IRootFunctions`1.Sqrt(`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentByteCount">
      <MemberSignature Language="C#" Value="int IFloatingPoint&lt;Half&gt;.GetExponentByteCount ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentByteCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.System#Numerics#IFloatingPoint&lt;System#Half&gt;#GetExponentByteCount" />
      <MemberSignature Language="VB.NET" Value="Function GetExponentByteCount () As Integer Implements IFloatingPoint(Of Half).GetExponentByteCount" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentByteCount : unit -&gt; int&#xA;override this.System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentByteCount : unit -&gt; int" Usage="half.System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentByteCount " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentByteCount() = System::Numerics::IFloatingPoint&lt;Half&gt;::GetExponentByteCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.GetExponentByteCount</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the number of bytes that will be written as part of <see cref="M:System.Numerics.IFloatingPoint`1.TryWriteExponentLittleEndian(System.Span{System.Byte},System.Int32@)" />.</summary>
        <returns>The number of bytes that will be written as part of <see cref="M:System.Numerics.IFloatingPoint`1.TryWriteExponentLittleEndian(System.Span{System.Byte},System.Int32@)" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.GetExponentByteCount" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentShortestBitLength">
      <MemberSignature Language="C#" Value="int IFloatingPoint&lt;Half&gt;.GetExponentShortestBitLength ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentShortestBitLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.System#Numerics#IFloatingPoint&lt;System#Half&gt;#GetExponentShortestBitLength" />
      <MemberSignature Language="VB.NET" Value="Function GetExponentShortestBitLength () As Integer Implements IFloatingPoint(Of Half).GetExponentShortestBitLength" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentShortestBitLength : unit -&gt; int&#xA;override this.System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentShortestBitLength : unit -&gt; int" Usage="half.System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentShortestBitLength " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetExponentShortestBitLength() = System::Numerics::IFloatingPoint&lt;Half&gt;::GetExponentShortestBitLength;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.GetExponentShortestBitLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the length, in bits, of the shortest two's complement representation of the current exponent.</summary>
        <returns>The length, in bits, of the shortest two's complement representation of the current exponent.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.GetExponentShortestBitLength" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandBitLength">
      <MemberSignature Language="C#" Value="int IFloatingPoint&lt;Half&gt;.GetSignificandBitLength ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandBitLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.System#Numerics#IFloatingPoint&lt;System#Half&gt;#GetSignificandBitLength" />
      <MemberSignature Language="VB.NET" Value="Function GetSignificandBitLength () As Integer Implements IFloatingPoint(Of Half).GetSignificandBitLength" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandBitLength : unit -&gt; int&#xA;override this.System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandBitLength : unit -&gt; int" Usage="half.System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandBitLength " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandBitLength() = System::Numerics::IFloatingPoint&lt;Half&gt;::GetSignificandBitLength;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.GetSignificandBitLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the length, in bits, of the current significand.</summary>
        <returns>The length, in bits, of the current significand.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.GetSignificandBitLength" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandByteCount">
      <MemberSignature Language="C#" Value="int IFloatingPoint&lt;Half&gt;.GetSignificandByteCount ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandByteCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.System#Numerics#IFloatingPoint&lt;System#Half&gt;#GetSignificandByteCount" />
      <MemberSignature Language="VB.NET" Value="Function GetSignificandByteCount () As Integer Implements IFloatingPoint(Of Half).GetSignificandByteCount" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandByteCount : unit -&gt; int&#xA;override this.System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandByteCount : unit -&gt; int" Usage="half.System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandByteCount " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IFloatingPoint&lt;System.Half&gt;.GetSignificandByteCount() = System::Numerics::IFloatingPoint&lt;Half&gt;::GetSignificandByteCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.GetSignificandByteCount</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the number of bytes that will be written as part of <see cref="M:System.Numerics.IFloatingPoint`1.TryWriteSignificandLittleEndian(System.Span{System.Byte},System.Int32@)" />.</summary>
        <returns>The number of bytes that will be written as part of <see cref="M:System.Numerics.IFloatingPoint`1.TryWriteSignificandLittleEndian(System.Span{System.Byte},System.Int32@)" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.GetSignificandByteCount" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentBigEndian">
      <MemberSignature Language="C#" Value="bool IFloatingPoint&lt;Half&gt;.TryWriteExponentBigEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.System#Numerics#IFloatingPoint&lt;System#Half&gt;#TryWriteExponentBigEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteExponentBigEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IFloatingPoint(Of Half).TryWriteExponentBigEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentBigEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentBigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="half.System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentBigEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentBigEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IFloatingPoint&lt;Half&gt;::TryWriteExponentBigEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.TryWriteExponentBigEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current exponent should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current exponent, in big-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the exponent was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.TryWriteExponentBigEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentLittleEndian">
      <MemberSignature Language="C#" Value="bool IFloatingPoint&lt;Half&gt;.TryWriteExponentLittleEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.System#Numerics#IFloatingPoint&lt;System#Half&gt;#TryWriteExponentLittleEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteExponentLittleEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IFloatingPoint(Of Half).TryWriteExponentLittleEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentLittleEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentLittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="half.System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentLittleEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteExponentLittleEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IFloatingPoint&lt;Half&gt;::TryWriteExponentLittleEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.TryWriteExponentLittleEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current exponent should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current exponent, in little-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the exponent was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.TryWriteExponentLittleEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandBigEndian">
      <MemberSignature Language="C#" Value="bool IFloatingPoint&lt;Half&gt;.TryWriteSignificandBigEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.System#Numerics#IFloatingPoint&lt;System#Half&gt;#TryWriteSignificandBigEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteSignificandBigEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IFloatingPoint(Of Half).TryWriteSignificandBigEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandBigEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandBigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="half.System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandBigEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandBigEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IFloatingPoint&lt;Half&gt;::TryWriteSignificandBigEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.TryWriteSignificandBigEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current significand should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current significand, in big-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the significand was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.TryWriteSignificandBigEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandLittleEndian">
      <MemberSignature Language="C#" Value="bool IFloatingPoint&lt;Half&gt;.TryWriteSignificandLittleEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.System#Numerics#IFloatingPoint&lt;System#Half&gt;#TryWriteSignificandLittleEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteSignificandLittleEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IFloatingPoint(Of Half).TryWriteSignificandLittleEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandLittleEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandLittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="half.System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandLittleEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IFloatingPoint&lt;System.Half&gt;.TryWriteSignificandLittleEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IFloatingPoint&lt;Half&gt;::TryWriteSignificandLittleEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.TryWriteSignificandLittleEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current significand should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current significand, in little-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the significand was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.TryWriteSignificandLittleEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static Half Tan (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Tan(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Tan(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Tan : Half -&gt; Half" Usage="System.Half.Tan x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Tan(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::Tan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.Tan(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the tangent of a value.</summary>
        <returns>The tangent of <paramref name="x" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `tan(x)`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.Tan(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static Half Tanh (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Tanh(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Tanh(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Tanh : Half -&gt; Half" Usage="System.Half.Tanh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Tanh(Half x) = System::Numerics::IHyperbolicFunctions&lt;Half&gt;::Tanh;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IHyperbolicFunctions`1.Tanh(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the hyperbolic tangent of a value.</summary>
        <returns>The hyperbolic tangent of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IHyperbolicFunctions`1.Tanh(`0)" />
      </Docs>
    </Member>
    <Member MemberName="TanPi">
      <MemberSignature Language="C#" Value="public static Half TanPi (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half TanPi(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.TanPi(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TanPi (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member TanPi : Half -&gt; Half" Usage="System.Half.TanPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half TanPi(Half x) = System::Numerics::ITrigonometricFunctions&lt;Half&gt;::TanPi;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ITrigonometricFunctions`1.TanPi(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Computes the tangent of a value that has been multipled by <c>pi</c>.</summary>
        <returns>The tangent of <paramref name="x" /> multiplied-by <c>pi</c>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This computes `tan(x * π)`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.ITrigonometricFunctions`1.TanPi(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Tau">
      <MemberSignature Language="C#" Value="public static Half Tau { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half Tau" />
      <MemberSignature Language="DocId" Value="P:System.Half.Tau" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Tau As Half" />
      <MemberSignature Language="F#" Value="static member Tau : Half" Usage="Tau" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half Tau { Half get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IFloatingPointConstants`1.Tau</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the mathematical constant <c>tau</c>.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.IFloatingPointConstants`1.Tau" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="half.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the numeric value of this instance to its equivalent string representation.</summary>
        <returns>The string representation of the value of this instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="half.ToString provider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <summary>Converts the numeric value of this instance to its equivalent string representation using the specified culture-specific format information.</summary>
        <returns>The string representation of the value of this instance as specified by <paramref name="provider" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string? format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="half.ToString format" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A numeric format string.</param>
        <summary>Converts the numeric value of this instance to its equivalent string representation, using the specified format.</summary>
        <returns>The string representation of the value of this instance as specified by <paramref name="format" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.</exception>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard numeric format strings</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom numeric format strings</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string? format, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="half.ToString (format, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">A numeric format string.</param>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <summary>Converts the numeric value of this instance to its equivalent string representation using the specified format and culture-specific format information.</summary>
        <returns>The string representation of the value of this instance as specified by <paramref name="provider" />.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard numeric format strings</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom numeric format strings</related>
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static Half Truncate (Half x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Half Truncate(valuetype System.Half x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.Truncate(System.Half)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (x As Half) As Half" />
      <MemberSignature Language="F#" Value="static member Truncate : Half -&gt; Half" Usage="System.Half.Truncate x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Half Truncate(Half x) = System::Numerics::IFloatingPoint&lt;Half&gt;::Truncate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IFloatingPoint`1.Truncate(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Half" Index="0" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <summary>Truncates a value.</summary>
        <returns>The truncation of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IFloatingPoint`1.Truncate(`0)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="DocId" Value="M:System.Half.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="half.TryFormat (destination, charsWritten, format, provider)" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="F#" Value="abstract member TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="half.TryFormat (destination, charsWritten, format, provider)" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-6.0;net-7.0">M:System.ISpanFormattable.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">The span in which to write this instance's value formatted as a span of characters.</param>
        <param name="charsWritten">When this method returns, contains the number of characters that were written in <paramref name="destination" />.</param>
        <param name="format">A span containing the characters that represent a standard or custom format string that defines the acceptable format for <paramref name="destination" />.</param>
        <param name="provider">An optional object that supplies culture-specific formatting information for <paramref name="destination" />.</param>
        <summary>Tries to format the value of the current <see cref="System.Half" /> instance into the provided span of characters.</summary>
        <returns>
          <see langword="true" /> if the formatting was successful, otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard numeric format strings</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom numeric format strings</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out Half result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] valuetype System.Half&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.TryParse(System.ReadOnlySpan{System.Char},System.Half@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * Half -&gt; bool" Usage="System.Half.TryParse (s, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] Half % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Half" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">A read-only span that contains a number to convert.</param>
        <param name="result">When this method returns, contains the half-precision floating-point number equivalent to the numeric value or symbol contained in <paramref name="s" />, if the conversion succeeded, or a default <see cref="T:System.Half" /> value if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" /> or is not a number in a valid format. If <paramref name="s" /> is a valid number less than <see cref="P:System.Half.MinValue" />, <paramref name="result" /> contains <see cref="P:System.Half.NegativeInfinity" />. If <paramref name="s" /> is a valid number greater than <see cref="P:System.Half.MaxValue" />, <paramref name="result" /> contains <see cref="P:System.Half.PositiveInfinity" />. This parameter is treated as uninitialized.</param>
        <summary>Converts the span representation of a number to its half-precision floating-point number equivalent. A return value indicates whether the conversion succeeded or failed.
      </summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully, <see langword="false" /> otherwise.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, out Half result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] valuetype System.Half&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.TryParse(System.String,System.Half@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * Half -&gt; bool" Usage="System.Half.TryParse (s, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] Half % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Half" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a number to convert.</param>
        <param name="result">When this method returns, contains the half-precision floating-point number equivalent to the numeric value or symbol contained in <paramref name="s" />, if the conversion succeeded, or a default <see cref="T:System.Half" /> value if the conversion failed. The conversion fails if <paramref name="s" /> is <see langword="null" /> or <see cref="F:System.String.Empty" /> or is not a number in a valid format. If <paramref name="s" /> is a valid number less than <see cref="P:System.Half.MinValue" />, <paramref name="result" /> contains <see cref="P:System.Half.NegativeInfinity" />. If <paramref name="s" /> is a valid number greater than <see cref="P:System.Half.MaxValue" />, <paramref name="result" /> contains <see cref="P:System.Half.PositiveInfinity" />. This parameter is treated as uninitialized.</param>
        <summary>Converts the string representation of a number to its half-precision floating-point number equivalent. A return value indicates whether the conversion succeeded or failed.</summary>
        <returns>
          <see langword="true" /> if the conversion was successful; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out Half result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, [out] valuetype System.Half&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Half@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), provider As IFormatProvider, ByRef result As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IFormatProvider * Half -&gt; bool" Usage="System.Half.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] Half % result) = ISpanParsable&lt;Half&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0" />
        <Parameter Name="result" Type="System.Half" RefType="out" Index="2" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>Tries to parse a span of characters into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.ISpanParsable`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, IFormatProvider? provider, out Half result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, class System.IFormatProvider provider, [out] valuetype System.Half&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.TryParse(System.String,System.IFormatProvider,System.Half@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, provider As IFormatProvider, ByRef result As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IFormatProvider * Half -&gt; bool" Usage="System.Half.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] Half % result) = IParsable&lt;Half&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0" />
        <Parameter Name="result" Type="System.Half" RefType="out" Index="2" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider, out Half result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Half&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Half@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * Half -&gt; bool" Usage="System.Half.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] Half % result);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] Half % result) = System::Numerics::INumberBase&lt;Half&gt;::TryParse;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Half" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">A read-only span that contains a number to convert.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the permitted format of <paramref name="s" />.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the half-precision floating-point number equivalent to the numeric value or symbol contained in <paramref name="s" />, if the conversion succeeded, or a default <see cref="T:System.Half" /> value if the conversion failed. The conversion fails if <paramref name="s" /> is not a number in a valid format. If <paramref name="s" /> is a valid number less than <see cref="P:System.Half.MinValue" />, <paramref name="result" /> contains <see cref="P:System.Half.NegativeInfinity" />. If <paramref name="s" /> is a valid number greater than <see cref="P:System.Half.MaxValue" />, <paramref name="result" /> contains <see cref="P:System.Half.PositiveInfinity" />. This parameter is treated as uninitialized.</param>
        <summary>Converts the span representation of a number to its half-precision floating-point number equivalent. A return value indicates whether the conversion succeeded or failed.</summary>
        <returns>
          <see langword="true" /> if the conversion was successful; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.

          -or-

          <see cref="T:System.Globalization.NumberStyles" /> is the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> value.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, System.Globalization.NumberStyles style, IFormatProvider? provider, out Half result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Half&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Half.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Half@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Half) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * Half -&gt; bool" Usage="System.Half.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] Half % result);" FrameworkAlternate="net-5.0;net-6.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] Half % result) = System::Numerics::INumberBase&lt;Half&gt;::TryParse;" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Half" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a number to convert.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the permitted format of <paramref name="s" />.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the half-precision floating-point number equivalent to the numeric value or symbol contained in <paramref name="s" />, if the conversion succeeded, or a default <see cref="T:System.Half" /> value if the conversion failed. The conversion fails if <paramref name="s" /> is <see langword="null" /> or <see cref="F:System.String.Empty" /> or is not a number in a valid format. If <paramref name="s" /> is a valid number less than <see cref="P:System.Half.MinValue" />, <paramref name="result" /> contains <see cref="P:System.Half.NegativeInfinity" />. If <paramref name="s" /> is a valid number greater than <see cref="P:System.Half.MaxValue" />, <paramref name="result" /> contains <see cref="P:System.Half.PositiveInfinity" />. This parameter is treated as uninitialized.</param>
        <summary>Converts the string representation of a number to its half-precision floating-point number equivalent. A return value indicates whether the conversion succeeded or failed.</summary>
        <returns>
          <see langword="true" /> if the conversion was successful; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.

          -or-

          <see cref="T:System.Globalization.NumberStyles" /> is the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> value.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static Half Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Half Zero" />
      <MemberSignature Language="DocId" Value="P:System.Half.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As Half" />
      <MemberSignature Language="F#" Value="static member Zero : Half" Usage="Zero" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Half Zero { Half get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Zero</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>0</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.INumberBase`1.Zero" />
      </Docs>
    </Member>
  </Members>
</Type>
