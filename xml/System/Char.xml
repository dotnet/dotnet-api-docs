<Type Name="Char" FullName="System.Char">
  <TypeSignature Language="C#" Value="public struct Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;char&gt;, class System.IConvertible, class System.IEquatable`1&lt;char&gt;" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Char" />
  <TypeSignature Language="VB.NET" Value="Public Structure Char&#xA;Implements IComparable, IComparable(Of Char), IConvertible, IEquatable(Of Char)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type char = struct&#xA;    interface IConvertible" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C++ CLI" Value="public value class char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public readonly struct Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public readonly struct Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;, ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;char&gt;, class System.IConvertible, class System.IEquatable`1&lt;char&gt;, class System.IFormattable, class System.ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Char&#xA;Implements IComparable, IComparable(Of Char), IConvertible, IEquatable(Of Char), ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="F#" Value="type char = struct&#xA;    interface IConvertible&#xA;    interface ISpanFormattable&#xA;    interface IFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="C++ CLI" Value="public value class char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;, ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="C#" Value="public readonly struct Char : IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;, IParsable&lt;char&gt;, ISpanParsable&lt;char&gt;, System.Numerics.IAdditionOperators&lt;char,char,char&gt;, System.Numerics.IAdditiveIdentity&lt;char,char&gt;, System.Numerics.IBinaryInteger&lt;char&gt;, System.Numerics.IBinaryNumber&lt;char&gt;, System.Numerics.IBitwiseOperators&lt;char,char,char&gt;, System.Numerics.IComparisonOperators&lt;char,char,bool&gt;, System.Numerics.IDecrementOperators&lt;char&gt;, System.Numerics.IDivisionOperators&lt;char,char,char&gt;, System.Numerics.IEqualityOperators&lt;char,char,bool&gt;, System.Numerics.IIncrementOperators&lt;char&gt;, System.Numerics.IMinMaxValue&lt;char&gt;, System.Numerics.IModulusOperators&lt;char,char,char&gt;, System.Numerics.IMultiplicativeIdentity&lt;char,char&gt;, System.Numerics.IMultiplyOperators&lt;char,char,char&gt;, System.Numerics.INumber&lt;char&gt;, System.Numerics.INumberBase&lt;char&gt;, System.Numerics.IShiftOperators&lt;char,int,char&gt;, System.Numerics.ISubtractionOperators&lt;char,char,char&gt;, System.Numerics.IUnaryNegationOperators&lt;char,char&gt;, System.Numerics.IUnaryPlusOperators&lt;char,char&gt;, System.Numerics.IUnsignedNumber&lt;char&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;char&gt;, class System.IConvertible, class System.IEquatable`1&lt;char&gt;, class System.IFormattable, class System.IParsable`1&lt;char&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;char&gt;, class System.Numerics.IAdditionOperators`3&lt;char, char, char&gt;, class System.Numerics.IAdditiveIdentity`2&lt;char, char&gt;, class System.Numerics.IBinaryInteger`1&lt;char&gt;, class System.Numerics.IBinaryNumber`1&lt;char&gt;, class System.Numerics.IBitwiseOperators`3&lt;char, char, char&gt;, class System.Numerics.IComparisonOperators`3&lt;char, char, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;char&gt;, class System.Numerics.IDivisionOperators`3&lt;char, char, char&gt;, class System.Numerics.IEqualityOperators`3&lt;char, char, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;char&gt;, class System.Numerics.IMinMaxValue`1&lt;char&gt;, class System.Numerics.IModulusOperators`3&lt;char, char, char&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;char, char&gt;, class System.Numerics.IMultiplyOperators`3&lt;char, char, char&gt;, class System.Numerics.INumber`1&lt;char&gt;, class System.Numerics.INumberBase`1&lt;char&gt;, class System.Numerics.IShiftOperators`3&lt;char, int32, char&gt;, class System.Numerics.ISubtractionOperators`3&lt;char, char, char&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;char, char&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;char, char&gt;, class System.Numerics.IUnsignedNumber`1&lt;char&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Char&#xA;Implements IAdditionOperators(Of Char, Char, Char), IAdditiveIdentity(Of Char, Char), IBinaryInteger(Of Char), IBinaryNumber(Of Char), IBitwiseOperators(Of Char, Char, Char), IComparable(Of Char), IComparisonOperators(Of Char, Char, Boolean), IConvertible, IDecrementOperators(Of Char), IDivisionOperators(Of Char, Char, Char), IEqualityOperators(Of Char, Char, Boolean), IEquatable(Of Char), IIncrementOperators(Of Char), IMinMaxValue(Of Char), IModulusOperators(Of Char, Char, Char), IMultiplicativeIdentity(Of Char, Char), IMultiplyOperators(Of Char, Char, Char), INumber(Of Char), INumberBase(Of Char), IParsable(Of Char), IShiftOperators(Of Char, Integer, Char), ISpanParsable(Of Char), ISubtractionOperators(Of Char, Char, Char), IUnaryNegationOperators(Of Char, Char), IUnaryPlusOperators(Of Char, Char), IUnsignedNumber(Of Char)" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="F#" Value="type char = struct&#xA;    interface IConvertible&#xA;    interface IFormattable&#xA;    interface IParsable&lt;char&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;char&gt;&#xA;    interface IAdditionOperators&lt;char, char, char&gt;&#xA;    interface IAdditiveIdentity&lt;char, char&gt;&#xA;    interface IBinaryInteger&lt;char&gt;&#xA;    interface IBinaryNumber&lt;char&gt;&#xA;    interface IBitwiseOperators&lt;char, char, char&gt;&#xA;    interface IComparisonOperators&lt;char, char, bool&gt;&#xA;    interface IEqualityOperators&lt;char, char, bool&gt;&#xA;    interface IDecrementOperators&lt;char&gt;&#xA;    interface IDivisionOperators&lt;char, char, char&gt;&#xA;    interface IIncrementOperators&lt;char&gt;&#xA;    interface IModulusOperators&lt;char, char, char&gt;&#xA;    interface IMultiplicativeIdentity&lt;char, char&gt;&#xA;    interface IMultiplyOperators&lt;char, char, char&gt;&#xA;    interface INumber&lt;char&gt;&#xA;    interface INumberBase&lt;char&gt;&#xA;    interface ISubtractionOperators&lt;char, char, char&gt;&#xA;    interface IUnaryNegationOperators&lt;char, char&gt;&#xA;    interface IUnaryPlusOperators&lt;char, char&gt;&#xA;    interface IShiftOperators&lt;char, int, char&gt;&#xA;    interface IMinMaxValue&lt;char&gt;&#xA;    interface IUnsignedNumber&lt;char&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C++ CLI" Value="public value class char : IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;, IParsable&lt;char&gt;, ISpanParsable&lt;char&gt;, System::Numerics::IAdditionOperators&lt;char, char, char&gt;, System::Numerics::IAdditiveIdentity&lt;char, char&gt;, System::Numerics::IBinaryInteger&lt;char&gt;, System::Numerics::IBinaryNumber&lt;char&gt;, System::Numerics::IBitwiseOperators&lt;char, char, char&gt;, System::Numerics::IComparisonOperators&lt;char, char, bool&gt;, System::Numerics::IDecrementOperators&lt;char&gt;, System::Numerics::IDivisionOperators&lt;char, char, char&gt;, System::Numerics::IEqualityOperators&lt;char, char, bool&gt;, System::Numerics::IIncrementOperators&lt;char&gt;, System::Numerics::IMinMaxValue&lt;char&gt;, System::Numerics::IModulusOperators&lt;char, char, char&gt;, System::Numerics::IMultiplicativeIdentity&lt;char, char&gt;, System::Numerics::IMultiplyOperators&lt;char, char, char&gt;, System::Numerics::INumber&lt;char&gt;, System::Numerics::INumberBase&lt;char&gt;, System::Numerics::IShiftOperators&lt;char, int, char&gt;, System::Numerics::ISubtractionOperators&lt;char, char, char&gt;, System::Numerics::IUnaryNegationOperators&lt;char, char&gt;, System::Numerics::IUnaryPlusOperators&lt;char, char&gt;, System::Numerics::IUnsignedNumber&lt;char&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C#" Value="public readonly struct Char : IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;, IParsable&lt;char&gt;, ISpanParsable&lt;char&gt;, IUtf8SpanParsable&lt;char&gt;, System.Numerics.IAdditionOperators&lt;char,char,char&gt;, System.Numerics.IAdditiveIdentity&lt;char,char&gt;, System.Numerics.IBinaryInteger&lt;char&gt;, System.Numerics.IBinaryNumber&lt;char&gt;, System.Numerics.IBitwiseOperators&lt;char,char,char&gt;, System.Numerics.IComparisonOperators&lt;char,char,bool&gt;, System.Numerics.IDecrementOperators&lt;char&gt;, System.Numerics.IDivisionOperators&lt;char,char,char&gt;, System.Numerics.IEqualityOperators&lt;char,char,bool&gt;, System.Numerics.IIncrementOperators&lt;char&gt;, System.Numerics.IMinMaxValue&lt;char&gt;, System.Numerics.IModulusOperators&lt;char,char,char&gt;, System.Numerics.IMultiplicativeIdentity&lt;char,char&gt;, System.Numerics.IMultiplyOperators&lt;char,char,char&gt;, System.Numerics.INumber&lt;char&gt;, System.Numerics.INumberBase&lt;char&gt;, System.Numerics.IShiftOperators&lt;char,int,char&gt;, System.Numerics.ISubtractionOperators&lt;char,char,char&gt;, System.Numerics.IUnaryNegationOperators&lt;char,char&gt;, System.Numerics.IUnaryPlusOperators&lt;char,char&gt;, System.Numerics.IUnsignedNumber&lt;char&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;char&gt;, class System.IConvertible, class System.IEquatable`1&lt;char&gt;, class System.IFormattable, class System.IParsable`1&lt;char&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;char&gt;, class System.IUtf8SpanFormattable, class System.IUtf8SpanParsable`1&lt;char&gt;, class System.Numerics.IAdditionOperators`3&lt;char, char, char&gt;, class System.Numerics.IAdditiveIdentity`2&lt;char, char&gt;, class System.Numerics.IBinaryInteger`1&lt;char&gt;, class System.Numerics.IBinaryNumber`1&lt;char&gt;, class System.Numerics.IBitwiseOperators`3&lt;char, char, char&gt;, class System.Numerics.IComparisonOperators`3&lt;char, char, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;char&gt;, class System.Numerics.IDivisionOperators`3&lt;char, char, char&gt;, class System.Numerics.IEqualityOperators`3&lt;char, char, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;char&gt;, class System.Numerics.IMinMaxValue`1&lt;char&gt;, class System.Numerics.IModulusOperators`3&lt;char, char, char&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;char, char&gt;, class System.Numerics.IMultiplyOperators`3&lt;char, char, char&gt;, class System.Numerics.INumber`1&lt;char&gt;, class System.Numerics.INumberBase`1&lt;char&gt;, class System.Numerics.IShiftOperators`3&lt;char, int32, char&gt;, class System.Numerics.ISubtractionOperators`3&lt;char, char, char&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;char, char&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;char, char&gt;, class System.Numerics.IUnsignedNumber`1&lt;char&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Char&#xA;Implements IAdditionOperators(Of Char, Char, Char), IAdditiveIdentity(Of Char, Char), IBinaryInteger(Of Char), IBinaryNumber(Of Char), IBitwiseOperators(Of Char, Char, Char), IComparable(Of Char), IComparisonOperators(Of Char, Char, Boolean), IConvertible, IDecrementOperators(Of Char), IDivisionOperators(Of Char, Char, Char), IEqualityOperators(Of Char, Char, Boolean), IEquatable(Of Char), IIncrementOperators(Of Char), IMinMaxValue(Of Char), IModulusOperators(Of Char, Char, Char), IMultiplicativeIdentity(Of Char, Char), IMultiplyOperators(Of Char, Char, Char), INumber(Of Char), INumberBase(Of Char), IParsable(Of Char), IShiftOperators(Of Char, Integer, Char), ISpanParsable(Of Char), ISubtractionOperators(Of Char, Char, Char), IUnaryNegationOperators(Of Char, Char), IUnaryPlusOperators(Of Char, Char), IUnsignedNumber(Of Char), IUtf8SpanParsable(Of Char)" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type char = struct&#xA;    interface IConvertible&#xA;    interface IFormattable&#xA;    interface IParsable&lt;char&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;char&gt;&#xA;    interface IAdditionOperators&lt;char, char, char&gt;&#xA;    interface IAdditiveIdentity&lt;char, char&gt;&#xA;    interface IBinaryInteger&lt;char&gt;&#xA;    interface IBinaryNumber&lt;char&gt;&#xA;    interface IBitwiseOperators&lt;char, char, char&gt;&#xA;    interface IComparisonOperators&lt;char, char, bool&gt;&#xA;    interface IEqualityOperators&lt;char, char, bool&gt;&#xA;    interface IDecrementOperators&lt;char&gt;&#xA;    interface IDivisionOperators&lt;char, char, char&gt;&#xA;    interface IIncrementOperators&lt;char&gt;&#xA;    interface IModulusOperators&lt;char, char, char&gt;&#xA;    interface IMultiplicativeIdentity&lt;char, char&gt;&#xA;    interface IMultiplyOperators&lt;char, char, char&gt;&#xA;    interface INumber&lt;char&gt;&#xA;    interface INumberBase&lt;char&gt;&#xA;    interface ISubtractionOperators&lt;char, char, char&gt;&#xA;    interface IUnaryNegationOperators&lt;char, char&gt;&#xA;    interface IUnaryPlusOperators&lt;char, char&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;char&gt;&#xA;    interface IShiftOperators&lt;char, int, char&gt;&#xA;    interface IMinMaxValue&lt;char&gt;&#xA;    interface IUnsignedNumber&lt;char&gt;" FrameworkAlternate="net-8.0" />
  <TypeSignature Language="C++ CLI" Value="public value class char : IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;, IParsable&lt;char&gt;, ISpanParsable&lt;char&gt;, IUtf8SpanParsable&lt;char&gt;, System::Numerics::IAdditionOperators&lt;char, char, char&gt;, System::Numerics::IAdditiveIdentity&lt;char, char&gt;, System::Numerics::IBinaryInteger&lt;char&gt;, System::Numerics::IBinaryNumber&lt;char&gt;, System::Numerics::IBitwiseOperators&lt;char, char, char&gt;, System::Numerics::IComparisonOperators&lt;char, char, bool&gt;, System::Numerics::IDecrementOperators&lt;char&gt;, System::Numerics::IDivisionOperators&lt;char, char, char&gt;, System::Numerics::IEqualityOperators&lt;char, char, bool&gt;, System::Numerics::IIncrementOperators&lt;char&gt;, System::Numerics::IMinMaxValue&lt;char&gt;, System::Numerics::IModulusOperators&lt;char, char, char&gt;, System::Numerics::IMultiplicativeIdentity&lt;char, char&gt;, System::Numerics::IMultiplyOperators&lt;char, char, char&gt;, System::Numerics::INumber&lt;char&gt;, System::Numerics::INumberBase&lt;char&gt;, System::Numerics::IShiftOperators&lt;char, int, char&gt;, System::Numerics::ISubtractionOperators&lt;char, char, char&gt;, System::Numerics::IUnaryNegationOperators&lt;char, char&gt;, System::Numerics::IUnaryPlusOperators&lt;char, char&gt;, System::Numerics::IUnsignedNumber&lt;char&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type char = struct&#xA;    interface IConvertible&#xA;    interface IFormattable&#xA;    interface IParsable&lt;char&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;char&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;char&gt;&#xA;    interface IAdditionOperators&lt;char, char, char&gt;&#xA;    interface IAdditiveIdentity&lt;char, char&gt;&#xA;    interface IBinaryInteger&lt;char&gt;&#xA;    interface IBinaryNumber&lt;char&gt;&#xA;    interface IBitwiseOperators&lt;char, char, char&gt;&#xA;    interface IComparisonOperators&lt;char, char, bool&gt;&#xA;    interface IEqualityOperators&lt;char, char, bool&gt;&#xA;    interface IDecrementOperators&lt;char&gt;&#xA;    interface IDivisionOperators&lt;char, char, char&gt;&#xA;    interface IIncrementOperators&lt;char&gt;&#xA;    interface IModulusOperators&lt;char, char, char&gt;&#xA;    interface IMultiplicativeIdentity&lt;char, char&gt;&#xA;    interface IMultiplyOperators&lt;char, char, char&gt;&#xA;    interface INumber&lt;char&gt;&#xA;    interface INumberBase&lt;char&gt;&#xA;    interface ISubtractionOperators&lt;char, char, char&gt;&#xA;    interface IUnaryNegationOperators&lt;char, char&gt;&#xA;    interface IUnaryPlusOperators&lt;char, char&gt;&#xA;    interface IShiftOperators&lt;char, int, char&gt;&#xA;    interface IMinMaxValue&lt;char&gt;&#xA;    interface IUnsignedNumber&lt;char&gt;" FrameworkAlternate="net-9.0" />
  <TypeSignature Language="C#" Value="public struct Char : IComparable, IConvertible" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IConvertible" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Char&#xA;Implements IComparable, IConvertible" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public value class char : IComparable, IConvertible" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;char&gt;, class System.IConvertible, class System.IEquatable`1&lt;char&gt;" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1" />
  <TypeSignature Language="C#" Value="public struct Char : IComparable, IComparable&lt;char&gt;, IEquatable&lt;char&gt;" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;char&gt;, class System.IEquatable`1&lt;char&gt;" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public Structure Char&#xA;Implements IComparable, IComparable(Of Char), IEquatable(Of Char)" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type char = struct" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public value class char : IComparable, IComparable&lt;char&gt;, IEquatable&lt;char&gt;" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="6.0.0.0" FrameworkAlternate="net-6.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="7.0.0.0" FrameworkAlternate="net-7.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="8.0.0.0" FrameworkAlternate="net-8.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="9.0.0.0" FrameworkAlternate="net-9.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
      <InterfaceName>System.IComparable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
      <InterfaceName>System.IEquatable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IComparable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IEquatable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IParsable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanParsable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;System.Char,System.Char,System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;System.Char,System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryInteger&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryNumber&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryNumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IComparisonOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;System.Char,System.Char,System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;System.Char,System.Char,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TOther,TResult&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMinMaxValue&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IModulusOperators&lt;System.Char,System.Char,System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;System.Char,System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;System.Char,System.Char,System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumber&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumberBase&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumberBase&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IShiftOperators&lt;TSelf,System.Int32,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;System.Char,System.Char,System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;System.Char,System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;System.Char,System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnsignedNumber&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1;netstandard-2.1">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a character as a UTF-16 code unit.</summary>
    <remarks>For more information about this API, see <see href="/dotnet/fundamentals/runtime-libraries/system-char">Supplemental API remarks for Char</see>.</remarks>
    <example>
      <format type="text/markdown"><![CDATA[
The following code example demonstrates some of the methods in <xref:System.Char>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char [Type Level]/CPP/charstructure.cpp" id="Snippet23":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/Overview/charstructure.cs" interactive="try-dotnet" id="Snippet23":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char/FS/charstructure.fs" id="Snippet23":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char [Type Level]/VB/charstructure.vb" id="Snippet23":::
      ]]></format>
    </example>
    <threadsafe>All members of this type are thread safe. Members that appear to modify instance state actually return a new instance initialized with the new value. As with any other type, reading and writing to a shared variable that contains an instance of this type must be protected by a lock to guarantee thread safety.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compares this instance to a specified object or value type, and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or value type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Char) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : char -&gt; int&#xA;override this.CompareTo : char -&gt; int" Usage="char.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(char value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Char" /> object to compare.</param>
        <summary>Compares this instance to a specified <see cref="T:System.Char" /> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Char" /> object.</summary>
        <returns>A signed number indicating the position of this instance in the sort order in relation to the <paramref name="value" /> parameter.

 <list type="table"><listheader><term> Return Value

 </term><description> Description

 </description></listheader><item><term> Less than zero

 </term><description> This instance precedes <paramref name="value" />.

 </description></item><item><term> Zero

 </term><description> This instance has the same position in the sort order as <paramref name="value" />.

 </description></item><item><term> Greater than zero

 </term><description> This instance follows <paramref name="value" />.

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method implements the <xref:System.IComparable%601?displayProperty=nameWithType> interface and performs slightly better than the <xref:System.Char.CompareTo%2A?displayProperty=nameWithType> method because it does not have to convert the `value` parameter to an object.

 The comparison performed by this method is based on the encoded values of this instance and `value`, not their lexicographical characteristics.

 If the <xref:System.Char.CompareTo%2A> method parameter type has fewer bits (is narrower) than the instance type, some programming languages perform an implicit widening conversion that transforms the value of the parameter into a value with more bits.

 For example, suppose the instance type is <xref:System.Int32> and the parameter type is <xref:System.Byte>. The Microsoft C# compiler generates instructions to represent the value of the parameter as an <xref:System.Int32> object, then generates a <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> method that compares the values of the <xref:System.Int32> instance and the <xref:System.Int32> parameter representation.

 Typically, implicit widening conversions are performed on numeric types. Consult your programming language's documentation to determine if its compiler performs widening conversions. If the instance and parameter types mismatch and a suitable conversion is not available, the compiler generates instructions to box the parameter and invoke the <xref:System.Char.CompareTo%2A> overload that takes an <xref:System.Object> parameter.



## Examples
 The following code example demonstrates generic and non-generic versions of the `CompareTo` method for several value and reference types.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Boolean/CompareTo/cat.cs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object? value);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="char.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-2.0;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">An object to compare this instance to, or <see langword="null" />.</param>
        <summary>Compares this instance to a specified object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</summary>
        <returns>A signed number indicating the position of this instance in the sort order in relation to the <paramref name="value" /> parameter.

 <list type="table"><listheader><term> Return Value

 </term><description> Description

 </description></listheader><item><term> Less than zero

 </term><description> This instance precedes <paramref name="value" />.

 </description></item><item><term> Zero

 </term><description> This instance has the same position in the sort order as <paramref name="value" />.

 </description></item><item><term> Greater than zero

 </term><description> This instance follows <paramref name="value" />.

 -or-

 <paramref name="value" /> is <see langword="null" />.

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Char.CompareTo%2A> method implements the <xref:System.IComparable> interface.

 The `value` parameter must be `null` or an instance of <xref:System.Char>; otherwise, an exception is thrown.

 The comparison performed by this method is based on the encoded values of this instance and `value`, not necessarily their lexicographical characteristics. Any instance of <xref:System.Char>, regardless of its value, is considered greater than `null`.



## Examples
 The following code example demonstrates <xref:System.Char.CompareTo%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.CompareTo/CPP/compareto.cpp" id="Snippet19":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/CompareTo/compareto.cs" interactive="try-dotnet" id="Snippet19":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.CompareTo/FS/compareto.fs" id="Snippet19":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.CompareTo/VB/compareto.vb" id="Snippet19":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> is not a <see cref="T:System.Char" /> object.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertFromUtf32">
      <MemberSignature Language="C#" Value="public static string ConvertFromUtf32 (int utf32);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ConvertFromUtf32(int32 utf32) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertFromUtf32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertFromUtf32 (utf32 As Integer) As String" />
      <MemberSignature Language="F#" Value="static member ConvertFromUtf32 : int -&gt; string" Usage="System.char.ConvertFromUtf32 utf32" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ConvertFromUtf32(int utf32);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf32" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="utf32">A 21-bit Unicode code point.</param>
        <summary>Converts the specified Unicode code point into a UTF-16 encoded string.</summary>
        <returns>A string consisting of one <see cref="T:System.Char" /> object or a surrogate pair of <see cref="T:System.Char" /> objects equivalent to the code point specified by the <paramref name="utf32" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Use this method to convert a 21-bit Unicode code point to a UTF-16 encoded string before testing the string with methods such as <xref:System.Char.IsLowSurrogate%28System.Char%29> and <xref:System.Char.IsHighSurrogate%28System.Char%29>.

 A valid code point outside the Basic Multilingual Plane (BMP) always yields a valid surrogate pair. However, a valid code point within the BMP might not yield a valid result according to the Unicode standard because no linguistic processing is used in the conversion. For that reason, use the <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> class to convert bulk UTF-32 data into bulk UTF-16 data.



## Examples
 The following code example demonstrates the <xref:System.Char.ConvertToUtf32%2A> and <xref:System.Char.ConvertFromUtf32%2A> methods.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/ConvertFromUtf32/utf.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR/char.cvtutf32/FS/utf.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="utf32" /> is not a valid 21-bit Unicode code point ranging from U+0 through U+10FFFF, excluding the surrogate pair range from U+D800 through U+DFFF.</exception>
        <altmember cref="T:System.Text.Rune" />
        <altmember cref="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertToUtf32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the value of a UTF-16 encoded surrogate pair into a Unicode code point.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following code example demonstrates the <xref:System.Char.ConvertToUtf32%2A> and <xref:System.Char.ConvertFromUtf32%2A> methods.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/ConvertFromUtf32/utf.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR/char.cvtutf32/FS/utf.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (highSurrogate As Char, lowSurrogate As Char) As Integer" />
      <MemberSignature Language="F#" Value="static member ConvertToUtf32 : char * char -&gt; int" Usage="System.char.ConvertToUtf32 (highSurrogate, lowSurrogate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(char highSurrogate, char lowSurrogate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="lowSurrogate" Type="System.Char" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">A high surrogate code unit (that is, a code unit ranging from U+D800 through U+DBFF).</param>
        <param name="lowSurrogate">A low surrogate code unit (that is, a code unit ranging from U+DC00 through U+DFFF).</param>
        <summary>Converts the value of a UTF-16 encoded surrogate pair into a Unicode code point.</summary>
        <returns>The 21-bit Unicode code point represented by the <paramref name="highSurrogate" /> and <paramref name="lowSurrogate" /> parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Use this method to convert a surrogate pair into a 21-bit Unicode code point. To convert UTF-16 data into UTF-32 data, use the <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> class.

 Ordinarily, UTF-16 encoding represents a single Unicode character as a 16-bit code unit. However, it also supports surrogate pairs, which allow a single abstract character to be represented as two 16-bit code units. These two <xref:System.Char> objects must have code units that range from U+D800 to U+DBFF for the first (high) surrogate and from U+DC00 to U+DFFF for the second (low) surrogate. Surrogate pairs are supported only by UTF-16 encoding. This method allows a character represented by a UTF-16 surrogate pair to be converted to a character using UTF-32 encoding.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="highSurrogate" /> is not in the range U+D800 through U+DBFF, or <paramref name="lowSurrogate" /> is not in the range U+DC00 through U+DFFF.</exception>
        <altmember cref="T:System.Text.Rune" />
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (s As String, index As Integer) As Integer" />
      <MemberSignature Language="F#" Value="static member ConvertToUtf32 : string * int -&gt; int" Usage="System.char.ConvertToUtf32 (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a character or surrogate pair.</param>
        <param name="index">The index position of the character or surrogate pair in <paramref name="s" />.</param>
        <summary>Converts the value of a UTF-16 encoded character or surrogate pair at a specified position in a string into a Unicode code point.</summary>
        <returns>The 21-bit Unicode code point represented by the character or surrogate pair at the position in the <paramref name="s" /> parameter specified by the <paramref name="index" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Use this method to convert a character or surrogate pair into a 21-bit Unicode code point. To convert UTF-16 data into UTF-32 data, use the <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> class.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is not a position within <paramref name="s" />.</exception>
        <exception cref="T:System.ArgumentException">The specified index position contains a surrogate pair, and either the first character in the pair is not a valid high surrogate or the second character in the pair is not a valid low surrogate.</exception>
        <altmember cref="T:System.Text.Rune" />
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a value that indicates whether this instance is equal to a specified object or <see cref="T:System.Char" /> value.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (char obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(char obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Char) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : char -&gt; bool" Usage="char.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(char obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Char" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">An object to compare to this instance.</param>
        <summary>Returns a value that indicates whether this instance is equal to the specified <see cref="T:System.Char" /> object.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="obj" /> parameter equals the value of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method implements the <xref:System.IEquatable%601?displayProperty=nameWithType> interface, and performs slightly better than <xref:System.Char.Equals%28System.Object%29?displayProperty=nameWithType> because it does not need to unbox the `obj` parameter.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="char.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="C#" Value="public override bool Equals (object? obj);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="obj">An object to compare with this instance or <see langword="null" />.</param>
        <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> is an instance of <see cref="T:System.Char" /> and equals the value of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The comparison performed by this method is based on the encoded values of this instance and `obj`, not necessarily their lexicographical characteristics.



## Examples
 The following code example demonstrates <xref:System.Char.Equals%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.Equals/CPP/equals.cpp" id="Snippet20":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/Equals/equals.cs" interactive="try-dotnet" id="Snippet20":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.Equals/FS/equals.fs" id="Snippet20":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Equals/VB/equals.vb" id="Snippet20":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="char.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this instance.</summary>
        <returns>A 32-bit signed integer hash code.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNumericValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts a specified numeric Unicode character to a double-precision floating-point number.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (c As Char) As Double" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : char -&gt; double" Usage="System.char.GetNumericValue c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to convert.</param>
        <summary>Converts the specified numeric Unicode character to a double-precision floating point number.</summary>
        <returns>The numeric value of <paramref name="c" /> if that character represents a number; otherwise, -1.0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `c` parameter must be the <xref:System.Char> representation of a numeric value. For example, if `c` is "5", the return value is 5. However, if `c` is "z", the return value is -1.0.

 A character has an associated numeric value if and only if it is a member of one of the following <xref:System.Globalization.UnicodeCategory> categories: `DecimalDigitNumber`, `LetterNumber`, or `OtherNumber`.

 The <xref:System.Char.GetNumericValue%2A> method assumes that `c` corresponds to a single linguistic character and checks whether that character can be converted to a decimal digit. However, some numbers in the Unicode standard are represented by two <xref:System.Char> objects that form a surrogate pair. For example, the Aegean numbering system consists of code points U+10107 through U+10133. The following example uses the <xref:System.Char.ConvertFromUtf32%2A> method to instantiate a string that represents AEGEAN NUMBER ONE. As the output from the example shows, the <xref:System.Char.GetNumericValue%28System.Char%29> method returns -1 if it is passed either a high surrogate or a low surrogate of this character.

 :::code language="csharp" source="~/snippets/csharp/System/Char/GetNumericValue/getnumericvalue1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/FS/getnumericvalue1.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb" id="Snippet2":::



## Examples
 The following example demonstrates <xref:System.Char.GetNumericValue%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/GetNumericValue/getnumericvalue.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/FS/getnumericvalue.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.GetNumericValue(System.Text.Rune)" />
      </Docs>
    </Member>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (s As String, index As Integer) As Double" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : string * int -&gt; double" Usage="System.char.GetNumericValue (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A <see cref="T:System.String" />.</param>
        <param name="index">The character position in <paramref name="s" />.</param>
        <summary>Converts the numeric Unicode character at the specified position in a specified string to a double-precision floating point number.</summary>
        <returns>The numeric value of the character at position <paramref name="index" /> in <paramref name="s" /> if that character represents a number; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `s` parameter must be the string representation of a numeric value. For example, if the character at position `index` in `s` is "5", the return value is 5. However, if the character at position `index` in `s` is "z", the return value is -1.

 Character positions in a string are indexed starting from zero.

 A character has an associated numeric value if and only if it is a member of one of the following <xref:System.Globalization.UnicodeCategory> categories: `DecimalDigitNumber`, `LetterNumber`, or `OtherNumber`.

 If the <xref:System.Char> object at position `index` is the first character of a valid surrogate pair, the <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> method determines whether the surrogate pair forms a numeric digit. For example, the Aegean numbering system consists of code points U+10107 through U+10133. The following example uses the <xref:System.Char.ConvertFromUtf32%2A> method to instantiate a string that represents each Aegean number. As the output from the example shows, the <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> method returns the correct numeric value if it is passed the high surrogate of an Aegean number. However, if it is passed the low surrogate, it considers only the low surrogate in isolation and returns -1.

 :::code language="csharp" source="~/snippets/csharp/System/Char/GetNumericValue/getnumericvalue1.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/FS/getnumericvalue1.fs" id="Snippet3":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb" id="Snippet3":::



## Examples
 The following code example demonstrates <xref:System.Char.GetNumericValue%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/GetNumericValue/getnumericvalue.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/FS/getnumericvalue.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="char.GetTypeCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the <see cref="T:System.TypeCode" /> for value type <see cref="T:System.Char" />.</summary>
        <returns>The enumerated constant, <see cref="F:System.TypeCode.Char" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetUnicodeCategory">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Categorizes a Unicode character into a group identified by one of the <see cref="T:System.Globalization.UnicodeCategory" /> values.</summary>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
        <remarks>
          <format type="text/markdown"><![CDATA[

 ## Examples
 The following code example demonstrates <xref:System.Char.GetUnicodeCategory%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CPP/getunicodecategory.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/GetUnicodeCategory/getunicodecategory.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/FS/getunicodecategory.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/VB/getunicodecategory.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (c As Char) As UnicodeCategory" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : char -&gt; System.Globalization.UnicodeCategory" Usage="System.char.GetUnicodeCategory c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to categorize.</param>
        <summary>Categorizes a specified Unicode character into a group identified by one of the <see cref="T:System.Globalization.UnicodeCategory" /> values.</summary>
        <returns>A <see cref="T:System.Globalization.UnicodeCategory" /> value that identifies the group that contains <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> method does not always return the same <xref:System.Globalization.UnicodeCategory> value as the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> method when it is passed a particular character as a parameter. The <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> method is designed to reflect the current version of the Unicode standard. In contrast, although the <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> method usually reflects the current version of the Unicode standard, it may return a character's category based on a previous version of the standard or it may return a category that differs from the current standard in order to preserve backward compatibility. As a result, we recommend that you use the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> method instead of <xref:System.Char.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType>.

 Starting with .NET Framework 4.6.2, Unicode characters are classified based on [The Unicode Standard, Version 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). In versions of the .NET Framework from the .NET Framework 4 to  the .NET Framework 4.6.1, they are classified based on [The Unicode Standard, Version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)" />
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (s As String, index As Integer) As UnicodeCategory" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : string * int -&gt; System.Globalization.UnicodeCategory" Usage="System.char.GetUnicodeCategory (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A <see cref="T:System.String" />.</param>
        <param name="index">The character position in <paramref name="s" />.</param>
        <summary>Categorizes the character at the specified position in a specified string into a group identified by one of the <see cref="T:System.Globalization.UnicodeCategory" /> values.</summary>
        <returns>A <see cref="T:System.Globalization.UnicodeCategory" /> enumerated constant that identifies the group that contains the character at position <paramref name="index" /> in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Character positions in a string are indexed starting from zero.

 The <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> method does not always return the same <xref:System.Globalization.UnicodeCategory> value as the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> method when it is passed a particular character as a parameter. The <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> method is designed to reflect the current version of the Unicode standard. In contrast, although the <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> method usually reflects the current version of the Unicode standard, it may return a character's category based on a previous version of the standard or it may return a category that differs from the current standard in order to preserve backward compatibility. As a result, we recommend that you use the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> method instead of <xref:System.Char.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>.

 Starting with .NET Framework 4.6.2, Unicode characters are classified based on [The Unicode Standard, Version 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). In versions of the .NET Framework from the .NET Framework 4 to  the .NET Framework 4.6.1, they are classified based on [The Unicode Standard, Version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsAscii">
      <MemberSignature Language="C#" Value="public static bool IsAscii (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAscii(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsAscii(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAscii (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsAscii : char -&gt; bool" Usage="System.char.IsAscii c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsAscii(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The character to analyze.</param>
        <summary>Returns <see langword="true" /> if <paramref name="c" /> is an ASCII character ([ U+0000..U+007F ]).</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is an ASCII character; <see langword="false" /> otherwise.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Per http://www.unicode.org/glossary/#ASCII, ASCII is only U+0000..U+007F.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsciiDigit">
      <MemberSignature Language="C#" Value="public static bool IsAsciiDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAsciiDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsAsciiDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAsciiDigit (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsAsciiDigit : char -&gt; bool" Usage="System.char.IsAsciiDigit c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsAsciiDigit(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The character to evaluate.</param>
        <summary>Indicates whether a character is categorized as an ASCII digit.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is an ASCII digit; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method determines whether the character is in the range '0' through '9', inclusive.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsciiHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsAsciiHexDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAsciiHexDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsAsciiHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAsciiHexDigit (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsAsciiHexDigit : char -&gt; bool" Usage="System.char.IsAsciiHexDigit c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsAsciiHexDigit(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The character to evaluate.</param>
        <summary>Indicates whether a character is categorized as an ASCII hexademical digit.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a hexademical digit; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method determines whether the character is in the range '0' through '9', inclusive,
            'A' through 'F', inclusive, or 'a' through 'f', inclusive.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsciiHexDigitLower">
      <MemberSignature Language="C#" Value="public static bool IsAsciiHexDigitLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAsciiHexDigitLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsAsciiHexDigitLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAsciiHexDigitLower (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsAsciiHexDigitLower : char -&gt; bool" Usage="System.char.IsAsciiHexDigitLower c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsAsciiHexDigitLower(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The character to evaluate.</param>
        <summary>Indicates whether a character is categorized as an ASCII lower-case hexademical digit.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a lower-case hexademical digit; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This determines whether the character is in the range '0' through '9', inclusive,
            or 'a' through 'f', inclusive.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsciiHexDigitUpper">
      <MemberSignature Language="C#" Value="public static bool IsAsciiHexDigitUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAsciiHexDigitUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsAsciiHexDigitUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAsciiHexDigitUpper (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsAsciiHexDigitUpper : char -&gt; bool" Usage="System.char.IsAsciiHexDigitUpper c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsAsciiHexDigitUpper(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The character to evaluate.</param>
        <summary>Indicates whether a character is categorized as an ASCII upper-case hexademical digit.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a hexademical digit; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This determines whether the character is in the range '0' through '9', inclusive,
            or 'A' through 'F', inclusive.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsciiLetter">
      <MemberSignature Language="C#" Value="public static bool IsAsciiLetter (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAsciiLetter(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsAsciiLetter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAsciiLetter (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsAsciiLetter : char -&gt; bool" Usage="System.char.IsAsciiLetter c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsAsciiLetter(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The character to evaluate.</param>
        <summary>Indicates whether a character is categorized as an ASCII letter.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is an ASCII letter; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This determines whether the character is in the range 'A' through 'Z', inclusive,
            or 'a' through 'z', inclusive.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsciiLetterLower">
      <MemberSignature Language="C#" Value="public static bool IsAsciiLetterLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAsciiLetterLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsAsciiLetterLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAsciiLetterLower (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsAsciiLetterLower : char -&gt; bool" Usage="System.char.IsAsciiLetterLower c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsAsciiLetterLower(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The character to evaluate.</param>
        <summary>Indicates whether a character is categorized as a lowercase ASCII letter.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a lowercase ASCII letter; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This determines whether the character is in the range 'a' through 'z', inclusive.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsciiLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsAsciiLetterOrDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAsciiLetterOrDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsAsciiLetterOrDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAsciiLetterOrDigit (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsAsciiLetterOrDigit : char -&gt; bool" Usage="System.char.IsAsciiLetterOrDigit c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsAsciiLetterOrDigit(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The character to evaluate.</param>
        <summary>Indicates whether a character is categorized as an ASCII letter or digit.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is an ASCII letter or digit; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This determines whether the character is in the range 'A' through 'Z', inclusive,
            'a' through 'z', inclusive, or '0' through '9', inclusive.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsciiLetterUpper">
      <MemberSignature Language="C#" Value="public static bool IsAsciiLetterUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAsciiLetterUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsAsciiLetterUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAsciiLetterUpper (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsAsciiLetterUpper : char -&gt; bool" Usage="System.char.IsAsciiLetterUpper c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsAsciiLetterUpper(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The character to evaluate.</param>
        <summary>Indicates whether a character is categorized as an uppercase ASCII letter.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a lowercase ASCII letter; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This determines whether the character is in the range 'a' through 'z', inclusive.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBetween">
      <MemberSignature Language="C#" Value="public static bool IsBetween (char c, char minInclusive, char maxInclusive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsBetween(char c, char minInclusive, char maxInclusive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsBetween(System.Char,System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsBetween (c As Char, minInclusive As Char, maxInclusive As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsBetween : char * char * char -&gt; bool" Usage="System.char.IsBetween (c, minInclusive, maxInclusive)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsBetween(char c, char minInclusive, char maxInclusive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="minInclusive" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="maxInclusive" Type="System.Char" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The character to evaluate.</param>
        <param name="minInclusive">The lower bound, inclusive.</param>
        <param name="maxInclusive">The upper bound, inclusive.</param>
        <summary>Indicates whether a character is within the specified inclusive range.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is within the specified range; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The method does not validate that `maxInclusive` is greater than or equal
            to `minInclusive`.  If `maxInclusive` is less than
            `minInclusive`, the behavior is undefined.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsControl">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a specified Unicode character is categorized as a control character.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Control characters are formatting and other non-printing characters, such as ACK, BEL, CR, FF, LF, and VT. The Unicode standard assigns code points from \U0000 to \U001F, \U007F, and from \U0080 to \U009F to control characters. According to the Unicode standard, these values are to be interpreted as control characters unless their use is otherwise defined by an application. Valid control characters are members of the <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> category.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.IsControl(System.Text.Rune)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsControl : char -&gt; bool" Usage="System.char.IsControl c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified Unicode character is categorized as a control character.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a control character; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[


## Examples
 The following example lists the Unicode code point of each of the control characters.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol1.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsControl/IsControl1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsControl/FS/IsControl1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsControl : string * int -&gt; bool" Usage="System.char.IsControl (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string is categorized as a control character.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is a control character; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[


## Examples
 The following example enumerates the characters in a string and determines whether any are control characters.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsControl/IsControl2.cs" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsControl/FS/IsControl2.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl2.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a Unicode character is categorized as a decimal digit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Valid digits are members of the <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> category.

## Examples
 The following code example demonstrates <xref:System.Char.IsDigit%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsDigit/CPP/isdigit.cpp" id="Snippet4":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsDigit/isdigit.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsDigit/FS/isdigit.fs" id="Snippet4":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsDigit/VB/isdigit.vb" id="Snippet4":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsDigit : char -&gt; bool" Usage="System.char.IsDigit c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified Unicode character is categorized as a decimal digit.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a decimal digit; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method determines whether a <xref:System.Char> is a radix-10 digit. This contrasts with <xref:System.Char.IsNumber%2A>, which determines whether a `Char` is of any numeric Unicode category. Numbers include characters such as fractions, subscripts, superscripts, Roman numerals, currency numerators, encircled numbers, and script-specific digits.

 Valid digits are members of the <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> category.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.IsDigit(System.Text.Rune)" />
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsDigit : string * int -&gt; bool" Usage="System.char.IsDigit (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string is categorized as a decimal digit.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is a decimal digit; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method determines whether a <xref:System.Char> is a radix-10 digit. This contrasts with <xref:System.Char.IsNumber%2A>, which determines whether a <xref:System.Char> is of any numeric Unicode category. Numbers include characters such as fractions, subscripts, superscripts, Roman numerals, currency numerators, encircled numbers, and script-specific digits.

 Character positions in a string are indexed starting from zero.

 Valid digits are members of the <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> category.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsHighSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether the specified <see cref="T:System.Char" /> object is a high surrogate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following code example demonstrates the <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, and <xref:System.Char.IsSurrogatePair%2A> methods.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsHighSurrogate/sur.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR/char.surrogate/FS/sur.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsHighSurrogate : char -&gt; bool" Usage="System.char.IsHighSurrogate c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified <see cref="T:System.Char" /> object is a high surrogate.</summary>
        <returns>
          <see langword="true" /> if the numeric value of the <paramref name="c" /> parameter ranges from U+D800 through U+DBFF; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 In addition to representing single characters using a 16-bit code point, UTF-16 encoding allows abstract characters to be represented using two 16-bit code points, which is known as a surrogate pair. The first element in this pair is the high surrogate. Its code point can range from U+D800 to U+DBFF. An individual surrogate has no interpretation of its own; it is meaningful only when used as part of a surrogate pair.

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Rune" />
      </Docs>
    </Member>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsHighSurrogate : string * int -&gt; bool" Usage="System.char.IsHighSurrogate (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the <see cref="T:System.Char" /> object at the specified position in a string is a high surrogate.</summary>
        <returns>
          <see langword="true" /> if the numeric value of the specified character in the <paramref name="s" /> parameter ranges from U+D800 through U+DBFF; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `index` parameter is zero-based.

 In addition to representing single characters using a 16-bit code point, UTF-16 encoding allows abstract characters to be represented using two 16-bit code points, which is known as a surrogate pair. The first element in this pair is the high surrogate. Its code point can range from U+D800 to U+DBFF. An individual surrogate has no interpretation of its own; it is meaningful only when used as part of a surrogate pair.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is not a position within <paramref name="s" />.</exception>
        <altmember cref="T:System.Text.Rune" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetter">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a Unicode character is categorized as a Unicode letter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method determines whether a <xref:System.Char> is a member of any category of Unicode letter. Unicode letters include the following:

-   Uppercase letters, such as U+0041 (LATIN CAPITAL LETTER A) through U+005A (LATIN CAPITAL LETTER Z), or U+0400 (CYRILLIC CAPITAL LETTER IE WITH GRAVE) through U+042F (CYRILLIC CAPITAL LETTER YA). These characters are members of the <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> category.

-   Lowercase letters, such as U+0061 (LATIN SMALL LETTER A) through U+007A (LATIN SMALL LETTER Z), or U+03AC (GREEK SMALL LETTER ALPHA WITH TONOS) through U+03CE (GREEK SMALL LETTER OMEGA WITH TONOS). These characters are members of the <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> category.

-   Title case letters, such as U+01C5 (LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON) or U+1FFC (GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI). These characters are members of the <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> category.

-   Modifiers, such as U+02B0 (MODIFIER LETTER SMALL H) through U+02C1 (MODIFIER LETTER REVERSED GLOTTAL STOP), or U+1D2C (MODIFIER LETTER CAPITAL A) through U+1D61 (MODIFIER LETTER SMALL CHI). These characters are members of the <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> category.

-   Other letters, such as U+05D0 (HEBREW LETTER ALEF) through U+05EA (HEBREW LETTER TAV), U+0621 (ARABIC LETTER HAMZA) through U+063A (ARABIC LETTER GHAIN), or U+4E00 (\<CJK Ideograph, First>) through U+9FC3 (\<CJK Ideograph, Last>). These characters are members of the <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> category.

## Examples

The following code example demonstrates <xref:System.Char.IsLetter%2A>.

  :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetter/CPP/isletter.cpp" id="Snippet5":::
  :::code language="csharp" source="~/snippets/csharp/System/Char/IsLetter/isletter.cs" interactive="try-dotnet" id="Snippet5":::
  :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsLetter/FS/isletter.fs" id="Snippet5":::
  :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetter/VB/isletter.vb" id="Snippet5":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsLetter : char -&gt; bool" Usage="System.char.IsLetter c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified Unicode character is categorized as a Unicode letter.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a letter; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method determines whether a <xref:System.Char> is a member of any category of Unicode letter. Unicode letters include the following:

-   Uppercase letters, such as U+0041 (LATIN CAPITAL LETTER A) through U+005A (LATIN CAPITAL LETTER Z), or U+0400 (CYRILLIC CAPITAL LETTER IE WITH GRAVE) through U+042F (CYRILLIC CAPITAL LETTER YA). These characters are members of the <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> category.

-   Lowercase letters, such as U+0061 (LATIN SMALL LETTER A) through U+007A (LATIN SMALL LETTER Z), or U+03AC (GREEK SMALL LETTER ALPHA WITH TONOS) through U+03CE (GREEK SMALL LETTER OMEGA WITH TONOS). These characters are members of the <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> category.

-   Title case letters, such as U+01C5 (LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON) or U+1FFC (GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI). These characters are members of the <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> category.

-   Modifiers, such as U+02B0 (MODIFIER LETTER SMALL H) through U+02C1 (MODIFIER LETTER REVERSED GLOTTAL STOP), or U+1D2C (MODIFIER LETTER CAPITAL A) through U+1D61 (MODIFIER LETTER SMALL CHI). These characters are members of the <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> category.

-   Other letters, such as U+05D0 (HEBREW LETTER ALEF) through U+05EA (HEBREW LETTER TAV), U+0621 (ARABIC LETTER HAMZA) through U+063A (ARABIC LETTER GHAIN), or U+4E00 (\<CJK Ideograph, First>) through U+9FC3 (\<CJK Ideograph, Last>). These characters are members of the <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> category.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.IsLetter(System.Text.Rune)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsLetter : string * int -&gt; bool" Usage="System.char.IsLetter (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string is categorized as a Unicode letter.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is a letter; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Character positions in a string are indexed starting from zero.

 This method determines whether the character at a specified index position in a string is a member of any category of Unicode letter. Unicode letters include the following:

-   Uppercase letters, such as U+0041 (LATIN CAPITAL LETTER A) through U+005A (LATIN CAPITAL LETTER Z), or U+0400 (CYRILLIC CAPITAL LETTER IE WITH GRAVE) through U+042F (CYRILLIC CAPITAL LETTER YA). These characters are members of the <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> category.

-   Lowercase letters, such as U+0061 (LATIN SMALL LETTER A) through U+007A (LATIN SMALL LETTER Z), or U+03AC (GREEK SMALL LETTER ALPHA WITH TONOS) through U+03CE (GREEK SMALL LETTER OMEGA WITH TONOS). These characters are members of the <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> category.

-   Title case letters, such as U+01C5 (LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON) or U+1FFC (GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI). These characters are members of the <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> category.

-   Modifiers, such as U+02B0 (MODIFIER LETTER SMALL H) through U+02C1 (MODIFIER LETTER REVERSED GLOTTAL STOP), or U+1D2C (MODIFIER LETTER CAPITAL A) through U+1D61 (MODIFIER LETTER SMALL CHI). These characters are members of the <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> category.

-   Other letters, such as U+05D0 (HEBREW LETTER ALEF) through U+05EA (HEBREW LETTER TAV), U+0621 (ARABIC LETTER HAMZA) through U+063A (ARABIC LETTER GHAIN), or U+4E00 (\<CJK Ideograph, First>) through U+9FC3 (\<CJK Ideograph, Last>). These characters are members of the <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> category.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetterOrDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a Unicode character is categorized as a letter or a decimal digit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Valid letters and decimal digits are members of the following categories in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, or `DecimalDigitNumber`.

## Examples
 The following code example demonstrates <xref:System.Char.IsLetterOrDigit%2A>.

  :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CPP/isletterordigit.cpp" id="Snippet6":::
  :::code language="csharp" source="~/snippets/csharp/System/Char/IsLetterOrDigit/isletterordigit.cs" interactive="try-dotnet" id="Snippet6":::
  :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/FS/isletterordigit.fs" id="Snippet6":::
  :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/VB/isletterordigit.vb" id="Snippet6":::

  ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : char -&gt; bool" Usage="System.char.IsLetterOrDigit c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified Unicode character is categorized as a letter or a decimal digit.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a letter or a decimal digit; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Valid letters and decimal digits are members of the following categories in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, or `DecimalDigitNumber`.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.IsLetterOrDigit(System.Text.Rune)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : string * int -&gt; bool" Usage="System.char.IsLetterOrDigit (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string is categorized as a letter or a decimal digit.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is a letter or a decimal digit; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Character positions in a string are indexed starting from zero.

 Valid letters and decimal digits are members of the following categories in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, or `DecimalDigitNumber`.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a Unicode character is categorized as a lowercase letter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following code example demonstrates <xref:System.Char.IsLower%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLower/CPP/islower.cpp" id="Snippet7":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsLower/islower.cs" interactive="try-dotnet" id="Snippet7":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsLower/FS/islower.fs" id="Snippet7":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLower/VB/islower.vb" id="Snippet7":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsLower : char -&gt; bool" Usage="System.char.IsLower c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified Unicode character is categorized as a lowercase letter.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a lowercase letter; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Valid lowercase letters are members of the following category in <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.IsLower(System.Text.Rune)" />
        <altmember cref="M:System.Text.Rune.IsUpper(System.Text.Rune)" />
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsLower : string * int -&gt; bool" Usage="System.char.IsLower (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string is categorized as a lowercase letter.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is a lowercase letter; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Character positions in a string are indexed starting from zero.

 Valid lowercase letters are members of the following category in <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLowSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether the specified <see cref="T:System.Char" /> object is a low surrogate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following code example demonstrates the <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, and <xref:System.Char.IsSurrogatePair%2A> methods.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsHighSurrogate/sur.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR/char.surrogate/FS/sur.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsLowSurrogate : char -&gt; bool" Usage="System.char.IsLowSurrogate c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">The character to evaluate.</param>
        <summary>Indicates whether the specified <see cref="T:System.Char" /> object is a low surrogate.</summary>
        <returns>
          <see langword="true" /> if the numeric value of the <paramref name="c" /> parameter ranges from U+DC00 through U+DFFF; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 In addition to representing single characters using a 16-bit code point, UTF-16 encoding allows abstract characters to be represented using two 16-bit code points, which is known as a surrogate pair. The second element in this pair is the low surrogate. Its code point can range from U+DC00 to U+DFFF. An individual surrogate has no interpretation of its own; it is meaningful only when used as part of a surrogate pair.

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Rune" />
      </Docs>
    </Member>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsLowSurrogate : string * int -&gt; bool" Usage="System.char.IsLowSurrogate (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the <see cref="T:System.Char" /> object at the specified position in a string is a low surrogate.</summary>
        <returns>
          <see langword="true" /> if the numeric value of the specified character in the <paramref name="s" /> parameter ranges from U+DC00 through U+DFFF; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `index` parameter is zero-based.

 In addition to representing single characters using a 16-bit code point, UTF-16 encoding allows abstract characters to be represented using two 16-bit code points, which is known as a surrogate pair. The second element in this pair is the low surrogate. Its code point can range from U+DC00 to U+DFFF. An individual surrogate has no interpretation of its own; it is meaningful only when used as part of a surrogate pair.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is not a position within <paramref name="s" />.</exception>
        <altmember cref="T:System.Text.Rune" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNumber">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a Unicode character is categorized as a number.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNumber : char -&gt; bool" Usage="System.char.IsNumber c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified Unicode character is categorized as a number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a number; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method determines whether a <xref:System.Char> is of any numeric Unicode category. In addition to including digits, numbers include characters, fractions, subscripts, superscripts, Roman numerals, currency numerators, and encircled numbers. This method contrasts with the <xref:System.Char.IsDigit%2A> method, which determines whether a <xref:System.Char> is a radix-10 digit.

> [!IMPORTANT]
>  The <xref:System.Char.IsNumber%28System.Char%29> method is not intended to determine whether a string consists of numeric characters (for example, by calling the method for each character in a string). To determine whether a string consists of numeric characters, call one of the overloads of the `TryParse` method (such as <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> or <xref:System.Double.TryParse%2A?displayProperty=nameWithType> of an integral or floating point type.

 Valid numbers are members of the <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, or <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> category.

 The <xref:System.Char.IsNumber%28System.Char%29> method assumes that `c` corresponds to a single linguistic character and checks whether that character represents a number. However, some numbers in the Unicode standard are represented by two <xref:System.Char> objects that form a surrogate pair. For example, the Aegean numbering system consists of code points U+10107 through U+10133. The following example uses the <xref:System.Char.ConvertFromUtf32%2A> method to instantiate a string that represents AEGEAN NUMBER ONE. As the output from the example shows, the <xref:System.Char.IsNumber%28System.Char%29> method returns `false` if it is passed either a high surrogate or a low surrogate of this character.

 :::code language="csharp" source="~/snippets/csharp/System/Char/IsNumber/isnumber1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsNumber/FS/isnumber1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb" id="Snippet1":::



## Examples
 The following example demonstrates <xref:System.Char.IsNumber%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp" id="Snippet8":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsNumber/isnumber.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsNumber/FS/isnumber.fs" id="Snippet8":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb" id="Snippet8":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.IsNumber(System.Text.Rune)" />
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNumber : string * int -&gt; bool" Usage="System.char.IsNumber (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string is categorized as a number.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is a number; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method determines whether a <xref:System.Char> is of any numeric Unicode category. In addition to including digits, numbers include characters, fractions, subscripts, superscripts, Roman numerals, currency numerators, and encircled numbers. This method contrasts with the <xref:System.Char.IsDigit%2A> method, which determines whether a <xref:System.Char> is a radix-10 digit.

 Character positions in a string are indexed starting from zero.

> [!IMPORTANT]
>  The <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> method is not intended to determine whether a string consists of numeric characters (for example, by calling the method for each character in a string). To determine whether a string consists of numeric characters, call one of the overloads of the `TryParse` method (such as <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> or <xref:System.Double.TryParse%2A?displayProperty=nameWithType> of an integral or floating point type.

 Valid numbers are members of the <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, or <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> category.

 If the <xref:System.Char> object at position `index` is the first character of a valid surrogate pair, the <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> method determines whether the surrogate pair forms a numeric digit. For example, the Aegean numbering system consists of code points U+10107 through U+10133. The following example uses the <xref:System.Char.ConvertFromUtf32%2A> method to instantiate a string that represents AEGEAN NUMBER ONE. As the output from the example shows, the <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> method returns `true` if it is passed the high surrogate of AEGEAN NUMBER ONE. However, if it is passed the low surrogate, it considers only the category of the low surrogate and returns `false`.

 :::code language="csharp" source="~/snippets/csharp/System/Char/IsNumber/isnumber1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsNumber/FS/isnumber1.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb" id="Snippet2":::



## Examples
 The following example demonstrates <xref:System.Char.IsNumber%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp" id="Snippet8":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsNumber/isnumber.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsNumber/FS/isnumber.fs" id="Snippet8":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb" id="Snippet8":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPunctuation">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a Unicode character is categorized as a punctuation mark.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Valid punctuation marks are members of the following categories in <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InitialQuotePunctuation`, `FinalQuotePunctuation`, or `OtherPunctuation`. They include characters with the Unicode code points listed in the following table.

|||||
|-|-|-|-|
|U+0021 to U+0023|U+060C and U+060D|U+1800 to U+180A|U+3014 to U+301F|
|U+0025 to U+002A|U+061B|U+1944 and U+1945|U+3030|
|U+002C to U+002F|U+061E and U+061F|U+19DE and U+19DF|U+303D|
|U+003A and U+003B|U+066A to U+066D|U+1A1E and U+1A1F|U+30A0|
|U+003F and U+0040|U+06D4|U+1B5A to U+1B60|U+30FB|
|U+005B to U+005D|U+0700 to U+070D|U+2010 to U+2027|U+A874 to U+A877|
|U+005F|U+07F7 to U+07F9|U+2030 to U+2043|U+FD3E and U+FD3F|
|U+007B|U+0964 and U+0965|U+2045 to U+2051|U+FE10 to U+FE19|
|U+007D|U+0970|U+2053 to U+205E|U+FE30 to U+FE52|
|U+00A1|U+0DF4|U+207D and  U+207E|U+FE54 to U+FE61|
|U+00AB|U+0E4F to U+0E5B|U+208D and U+208E|U+FE63|
|U+00AD|U+0F04 to U+0F12|U+2329 and U+232A|U+FE68|
|U+00B7|U+0F3A to U+0F3D|U+2768 to U+2775|U+FE6A and U+FE6B|
|U+00BB|U+0F85|U+27C5 to U+27C6|U+FF01 to U+FF03|
|U+00BF|U+0FD0 and U+0FD1|U+27E6 to U+27EB|U+FF05 to U+FF0A|
|U+037E|U+104A to U+104F|U+2983 to U+2998|U+FF0C to U+FF0F|
|U+0387|U+10FB|U+29D8 to U+29DB|U+FF1A and U+FF1B|
|U+055A to U+055F|U+1361 to U+1368|U+29FC and U+29FD|U+FF1F and U+FF20|
|U+0589 and U+058A|U+166D and U+166E|U+2CF9 to U+2CFC|U+FF3B to U+FF3D|
|U+05BE|U+169B and U+169C|U+2CFE and U+2CFF|U+FF3F|
|U+05C0|U+16EB to U+16ED|U+2E00 to U+2E17|U+FF5B|
|U+05C3|U+1735 and U+1736|U+2E1C and U+2E1D|U+FF5D|
|U+05C6|U+17D4 to U+17D6|U+3001 to U+3003|U+FF5F to U+FF65|
|U+05F3 and U+05F4|U+17D8 to U+17DA|U+3008 to U+3011||

## Examples
 The following code example demonstrates <xref:System.Char.IsPunctuation%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CPP/ispunctuation.cpp" id="Snippet9":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsPunctuation/ispunctuation.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsPunctuation/FS/ispunctuation.fs" id="Snippet9":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsPunctuation/VB/ispunctuation.vb" id="Snippet9":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : char -&gt; bool" Usage="System.char.IsPunctuation c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified Unicode character is categorized as a punctuation mark.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a punctuation mark; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Valid punctuation marks are members of the following categories in <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InitialQuotePunctuation`, `FinalQuotePunctuation`, or `OtherPunctuation`. They include characters with the Unicode code points listed in the following table.

|||||
|-|-|-|-|
|U+0021 to U+0023|U+060C and U+060D|U+1800 to U+180A|U+3014 to U+301F|
|U+0025 to U+002A|U+061B|U+1944 and U+1945|U+3030|
|U+002C to U+002F|U+061E and U+061F|U+19DE and U+19DF|U+303D|
|U+003A and U+003B|U+066A to U+066D|U+1A1E and U+1A1F|U+30A0|
|U+003F and U+0040|U+06D4|U+1B5A to U+1B60|U+30FB|
|U+005B to U+005D|U+0700 to U+070D|U+2010 to U+2027|U+A874 to U+A877|
|U+005F|U+07F7 to U+07F9|U+2030 to U+2043|U+FD3E and U+FD3F|
|U+007B|U+0964 and U+0965|U+2045 to U+2051|U+FE10 to U+FE19|
|U+007D|U+0970|U+2053 to U+205E|U+FE30 to U+FE52|
|U+00A1|U+0DF4|U+207D and  U+207E|U+FE54 to U+FE61|
|U+00AB|U+0E4F to U+0E5B|U+208D and U+208E|U+FE63|
|U+00AD|U+0F04 to U+0F12|U+2329 and U+232A|U+FE68|
|U+00B7|U+0F3A to U+0F3D|U+2768 to U+2775|U+FE6A and U+FE6B|
|U+00BB|U+0F85|U+27C5 to U+27C6|U+FF01 to U+FF03|
|U+00BF|U+0FD0 and U+0FD1|U+27E6 to U+27EB|U+FF05 to U+FF0A|
|U+037E|U+104A to U+104F|U+2983 to U+2998|U+FF0C to U+FF0F|
|U+0387|U+10FB|U+29D8 to U+29DB|U+FF1A and U+FF1B|
|U+055A to U+055F|U+1361 to U+1368|U+29FC and U+29FD|U+FF1F and U+FF20|
|U+0589 and U+058A|U+166D and U+166E|U+2CF9 to U+2CFC|U+FF3B to U+FF3D|
|U+05BE|U+169B and U+169C|U+2CFE and U+2CFF|U+FF3F|
|U+05C0|U+16EB to U+16ED|U+2E00 to U+2E17|U+FF5B|
|U+05C3|U+1735 and U+1736|U+2E1C and U+2E1D|U+FF5D|
|U+05C6|U+17D4 to U+17D6|U+3001 to U+3003|U+FF5F to U+FF65|
|U+05F3 and U+05F4|U+17D8 to U+17DA|U+3008 to U+3011||

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.IsPunctuation(System.Text.Rune)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : string * int -&gt; bool" Usage="System.char.IsPunctuation (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string is categorized as a punctuation mark.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is a punctuation mark; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Character positions in a string are indexed starting from zero.

 Valid punctuation marks are members of the following categories in <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InitialQuotePunctuation`, `FinalQuotePunctuation`, or `OtherPunctuation`. They include characters with the Unicode code points listed in the following table.

|||||
|-|-|-|-|
|U+0021 to U+0023|U+060C and U+060D|U+1800 to U+180A|U+3014 to U+301F|
|U+0025 to U+002A|U+061B|U+1944 and U+1945|U+3030|
|U+002C to U+002F|U+061E and U+061F|U+19DE and U+19DF|U+303D|
|U+003A and U+003B|U+066A to U+066D|U+1A1E and U+1A1F|U+30A0|
|U+003F and U+0040|U+06D4|U+1B5A to U+1B60|U+30FB|
|U+005B to U+005D|U+0700 to U+070D|U+2010 to U+2027|U+A874 to U+A877|
|U+005F|U+07F7 to U+07F9|U+2030 to U+2043|U+FD3E and U+FD3F|
|U+007B|U+0964 and U+0965|U+2045 to U+2051|U+FE10 to U+FE19|
|U+007D|U+0970|U+2053 to U+205E|U+FE30 to U+FE52|
|U+00A1|U+0DF4|U+207D and  U+207E|U+FE54 to U+FE61|
|U+00AB|U+0E4F to U+0E5B|U+208D and U+208E|U+FE63|
|U+00AD|U+0F04 to U+0F12|U+2329 and U+232A|U+FE68|
|U+00B7|U+0F3A to U+0F3D|U+2768 to U+2775|U+FE6A and U+FE6B|
|U+00BB|U+0F85|U+27C5 to U+27C6|U+FF01 to U+FF03|
|U+00BF|U+0FD0 and U+0FD1|U+27E6 to U+27EB|U+FF05 to U+FF0A|
|U+037E|U+104A to U+104F|U+2983 to U+2998|U+FF0C to U+FF0F|
|U+0387|U+10FB|U+29D8 to U+29DB|U+FF1A and U+FF1B|
|U+055A to U+055F|U+1361 to U+1368|U+29FC and U+29FD|U+FF1F and U+FF20|
|U+0589 and U+058A|U+166D and U+166E|U+2CF9 to U+2CFC|U+FF3B to U+FF3D|
|U+05BE|U+169B and U+169C|U+2CFE and U+2CFF|U+FF3F|
|U+05C0|U+16EB to U+16ED|U+2E00 to U+2E17|U+FF5B|
|U+05C3|U+1735 and U+1736|U+2E1C and U+2E1D|U+FF5D|
|U+05C6|U+17D4 to U+17D6|U+3001 to U+3003|U+FF5F to U+FF65|
|U+05F3 and U+05F4|U+17D8 to U+17DA|U+3008 to U+3011||

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSeparator">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a Unicode character is categorized as a separator character.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The Unicode standard recognizes three subcategories of separators:

-   Space separators (the <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> category), which includes characters such as \u0020.

-   Line separators (the <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> category), which includes \u2028.

-   Paragraph separators (the <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> category), which includes \u2029.

> [!NOTE]
>  The Unicode standard classifies the characters \u000A (LF), \u000C (FF), and \u000D (CR) as control characters (members of the <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> category), not as separator characters.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSeparator : char -&gt; bool" Usage="System.char.IsSeparator c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified Unicode character is categorized as a separator character.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a separator character; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The Unicode standard recognizes three subcategories of separators:

-   Space separators (the <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> category), which includes characters such as \u0020.

-   Line separators (the <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> category), which includes \u2028.

-   Paragraph separators (the <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> category), which includes \u2029.

> [!NOTE]
>  The Unicode standard classifies the characters \u000A (LF), \u000C (FF), and \u000D (CR) as control characters (members of the <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> category), not as separator characters.



## Examples
 The following example lists the <xref:System.Char> objects that are classified as separator characters.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator1.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsSeparator/isseparator1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsSeparator/FS/isseparator1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.IsSeparator(System.Text.Rune)" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSeparator : string * int -&gt; bool" Usage="System.char.IsSeparator (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string is categorized as a separator character.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is a separator character; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Character positions in a string are indexed starting from zero.

 The Unicode standard recognizes three subcategories of separators:

-   Space separators (the <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> category), which includes characters such as \u0020.

-   Line separators (the <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> category), which includes \u2028.

-   Paragraph separators (the <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> category), which includes \u2029.

> [!NOTE]
>  The Unicode standard classifies the characters \u000A (LF), \u000C (FF), and \u000D (CR) as control characters (members of the <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> category), not as separator characters.



## Examples
 The following example demonstrates <xref:System.Char.IsSeparator%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator.cpp" id="Snippet10":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsSeparator/isseparator.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsSeparator/FS/isseparator.fs" id="Snippet10":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator.vb" id="Snippet10":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a character has a surrogate code unit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following example demonstrates the <xref:System.Char.IsSurrogate%2A> method.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CPP/issurrogate.cpp" id="Snippet11":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsSurrogate/issurrogate.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsSurrogate/FS/issurrogate.fs" id="Snippet11":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSurrogate/VB/issurrogate.vb" id="Snippet11":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSurrogate : char -&gt; bool" Usage="System.char.IsSurrogate c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified character has a surrogate code unit.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is either a high surrogate or a low surrogate; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 A surrogate is a <xref:System.Char> object with a UTF-16 code unit in the range from U+D800 to U+DFFF. Each character with a code unit in this range belongs to the <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> category. The individual surrogate code unit has no interpretation of its own, but has meaning only when used as part of a surrogate pair. For more information about surrogate pairs, see the Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?linkid=37123).

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Rune" />
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSurrogate : string * int -&gt; bool" Usage="System.char.IsSurrogate (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string has a surrogate code unit.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is a either a high surrogate or a low surrogate; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Character positions in a string are indexed starting from zero.

 A surrogate is a <xref:System.Char> object with a UTF-16 code unit in the range from U+D800 to U+DFFF. Each character with a code unit in this range belongs to the <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> category. The individual surrogate code unit has no interpretation of its own, but has meaning only when used as part of a surrogate pair. For more information about surrogate pairs, see the Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?linkid=37123).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Text.Rune" />
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogatePair">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether two specified <see cref="T:System.Char" /> objects form a surrogate pair.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following code example demonstrates the <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, and <xref:System.Char.IsSurrogatePair%2A> methods.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsHighSurrogate/sur.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR/char.surrogate/FS/sur.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (highSurrogate As Char, lowSurrogate As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSurrogatePair : char * char -&gt; bool" Usage="System.char.IsSurrogatePair (highSurrogate, lowSurrogate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="lowSurrogate" Type="System.Char" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">The character to evaluate as the high surrogate of a surrogate pair.</param>
        <param name="lowSurrogate">The character to evaluate as the low surrogate of a surrogate pair.</param>
        <summary>Indicates whether the two specified <see cref="T:System.Char" /> objects form a surrogate pair.</summary>
        <returns>
          <see langword="true" /> if the numeric value of the <paramref name="highSurrogate" /> parameter ranges from U+D800 through U+DBFF, and the numeric value of the <paramref name="lowSurrogate" /> parameter ranges from U+DC00 through U+DFFF; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Ordinarily, a single character is represented by a single 16-bit Unicode code unit. UTF-16 encoding also supports surrogate pairs, which allow a single abstract character to be represented by two 16-bit code units. The first code unit, whose value can range from U+D800 to U+DBFF, is the high surrogate. The second code unit, whose value can range from U+DC00 to U+DFFF, is the low surrogate. Individual surrogate code points have no interpretation of their own. For more information about surrogates and the Unicode Standard, see the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Rune" />
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSurrogatePair : string * int -&gt; bool" Usage="System.char.IsSurrogatePair (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The starting position of the pair of characters to evaluate within <paramref name="s" />.</param>
        <summary>Indicates whether two adjacent <see cref="T:System.Char" /> objects at a specified position in a string form a surrogate pair.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="s" /> parameter includes adjacent characters at positions <paramref name="index" /> and <paramref name="index" /> + 1, and the numeric value of the character at position <paramref name="index" /> ranges from U+D800 through U+DBFF, and the numeric value of the character at position <paramref name="index" />+1 ranges from U+DC00 through U+DFFF; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Ordinarily, a single character is represented by a single 16-bit Unicode code unit. UTF-16 encoding also supports surrogate pairs, which allow a single abstract character to be represented by two 16-bit code units. The first code unit, whose value can range from U+D800 to U+DBFF, is the high surrogate. The second code unit, whose value can range from U+DC00 to U+DFFF, is the low surrogate. Individual surrogate code points have no interpretation of their own. For more information about surrogates and the Unicode Standard, see the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is not a position within <paramref name="s" />.</exception>
        <altmember cref="T:System.Text.Rune" />
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSymbol">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a Unicode character is categorized as a symbol character.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Valid symbols are members of the following categories in <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, and `OtherSymbol`.

 Symbols in the Unicode standard are a loosely defined set of characters that include the following:

-   Currency symbols.

-   Letterlike symbols, which include a set of mathematical alphanumeric symbols as well as symbols such as ℅, №, and ™.

-   Number forms, such as subscripts and superscripts.

-   Mathematical operators and arrows.

-   Geometric symbols.

-   Technical symbols.

-   Braille patterns.

-   Dingbats.

## Examples
 The following code example demonstrates <xref:System.Char.IsSymbol%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSymbol/CPP/issymbol.cpp" id="Snippet12":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsSymbol/issymbol.cs" interactive="try-dotnet" id="Snippet12":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsSymbol/FS/issymbol.fs" id="Snippet12":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSymbol/VB/issymbol.vb" id="Snippet12":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSymbol : char -&gt; bool" Usage="System.char.IsSymbol c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified Unicode character is categorized as a symbol character.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is a symbol character; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Valid symbols are members of the following categories in <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, and `OtherSymbol`.

 Symbols in the Unicode standard are a loosely defined set of characters that include the following:

-   Currency symbols.

-   Letterlike symbols, which include a set of mathematical alphanumeric symbols as well as symbols such as ℅, №, and ™.

-   Number forms, such as subscripts and superscripts.

-   Mathematical operators and arrows.

-   Geometric symbols.

-   Technical symbols.

-   Braille patterns.

-   Dingbats.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.IsSymbol(System.Text.Rune)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSymbol : string * int -&gt; bool" Usage="System.char.IsSymbol (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string is categorized as a symbol character.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is a symbol character; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Character positions in a string are indexed starting from zero.

 Valid symbols are members of the following categories in <xref:System.Globalization.UnicodeCategory?displayProperty=nameWithType>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, and `OtherSymbol`.

 Symbols in the Unicode standard are a loosely defined set of characters that include the following:

-   Currency symbols.

-   Letterlike symbols, which include a set of mathematical alphanumeric symbols as well as symbols such as ℅, №, and ™.

-   Number forms, such as subscripts and superscripts.

-   Mathematical operators and arrows.

-   Geometric symbols.

-   Technical symbols.

-   Braille patterns.

-   Dingbats.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a Unicode character is categorized as an uppercase letter.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsUpper : char -&gt; bool" Usage="System.char.IsUpper c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified Unicode character is categorized as an uppercase letter.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is an uppercase letter; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Valid uppercase letters are members of the following category in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.IsUpper(System.Text.Rune)" />
        <altmember cref="M:System.Text.Rune.IsLower(System.Text.Rune)" />
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsLower(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsUpper : string * int -&gt; bool" Usage="System.char.IsUpper (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string is categorized as an uppercase letter.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is an uppercase letter; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Character positions in a string are indexed starting from zero.

 Valid uppercase letters are members of the following category in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsWhiteSpace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether a Unicode character is categorized as white space.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 White space characters are the following Unicode characters:

-   Members of the <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> category, which includes the characters SPACE (U+0020), NO-BREAK SPACE (U+00A0), OGHAM SPACE MARK (U+1680), EN QUAD (U+2000), EM QUAD (U+2001), EN SPACE (U+2002), EM SPACE (U+2003), THREE-PER-EM SPACE (U+2004), FOUR-PER-EM SPACE (U+2005), SIX-PER-EM SPACE (U+2006), FIGURE SPACE (U+2007), PUNCTUATION SPACE (U+2008), THIN SPACE (U+2009), HAIR SPACE (U+200A), NARROW NO-BREAK SPACE (U+202F), MEDIUM MATHEMATICAL SPACE (U+205F), and IDEOGRAPHIC SPACE (U+3000).

-   Members of the <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> category, which consists solely of the LINE SEPARATOR character (U+2028).

-   Members of the <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> category, which consists solely of the PARAGRAPH SEPARATOR character (U+2029).

-   The characters CHARACTER TABULATION (U+0009), LINE FEED (U+000A), LINE TABULATION (U+000B), FORM FEED (U+000C), CARRIAGE RETURN (U+000D), and NEXT LINE (U+0085).

## Examples
 The following example demonstrates the <xref:System.Char.IsWhiteSpace%28System.Char%29> method.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CPP/iswhitespace.cpp" id="Snippet14":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/IsWhiteSpace/iswhitespace.cs" interactive="try-dotnet" id="Snippet14":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/FS/iswhitespace.fs" id="Snippet14":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/VB/iswhitespace.vb" id="Snippet14":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (c As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : char -&gt; bool" Usage="System.char.IsWhiteSpace c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to evaluate.</param>
        <summary>Indicates whether the specified Unicode character is categorized as white space.</summary>
        <returns>
          <see langword="true" /> if <paramref name="c" /> is white space; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 White space characters are the following Unicode characters:

-   Members of the <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> category, which includes the characters SPACE (U+0020), NO-BREAK SPACE (U+00A0), OGHAM SPACE MARK (U+1680), EN QUAD (U+2000), EM QUAD (U+2001), EN SPACE (U+2002), EM SPACE (U+2003), THREE-PER-EM SPACE (U+2004), FOUR-PER-EM SPACE (U+2005), SIX-PER-EM SPACE (U+2006), FIGURE SPACE (U+2007), PUNCTUATION SPACE (U+2008), THIN SPACE (U+2009), HAIR SPACE (U+200A), NARROW NO-BREAK SPACE (U+202F), MEDIUM MATHEMATICAL SPACE (U+205F), and IDEOGRAPHIC SPACE (U+3000).

-   Members of the <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> category, which consists solely of the LINE SEPARATOR character (U+2028).

-   Members of the <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> category, which consists solely of the PARAGRAPH SEPARATOR character (U+2029).

-   The characters CHARACTER TABULATION (U+0009), LINE FEED (U+000A), LINE TABULATION (U+000B), FORM FEED (U+000C), CARRIAGE RETURN (U+000D), and NEXT LINE (U+0085).

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.IsWhiteSpace(System.Text.Rune)" />
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : string * int -&gt; bool" Usage="System.char.IsWhiteSpace (s, index)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A string.</param>
        <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        <summary>Indicates whether the character at the specified position in a specified string is categorized as white space.</summary>
        <returns>
          <see langword="true" /> if the character at position <paramref name="index" /> in <paramref name="s" /> is white space; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Character positions in a string are indexed starting from zero.

 White space characters are the following Unicode characters:

-   Members of the <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> category, which includes the characters SPACE (U+0020), NO-BREAK SPACE (U+00A0), OGHAM SPACE MARK (U+1680), EN QUAD (U+2000), EM QUAD (U+2001), EN SPACE (U+2002), EM SPACE (U+2003), THREE-PER-EM SPACE (U+2004), FOUR-PER-EM SPACE (U+2005), SIX-PER-EM SPACE (U+2006), FIGURE SPACE (U+2007), PUNCTUATION SPACE (U+2008), THIN SPACE (U+2009), HAIR SPACE (U+200A), NARROW NO-BREAK SPACE (U+202F), MEDIUM MATHEMATICAL SPACE (U+205F), and IDEOGRAPHIC SPACE (U+3000).

-   Members of the <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> category, which consists solely of the LINE SEPARATOR character (U+2028).

-   Members of the <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> category, which consists solely of the PARAGRAPH SEPARATOR character (U+2029).

-   The characters CHARACTER TABULATION (U+0009), LINE FEED (U+000A), LINE TABULATION (U+000B), FORM FEED (U+000C), CARRIAGE RETURN (U+000D), and NEXT LINE (U+0085).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const char MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Char " />
      <MemberSignature Language="F#" Value="val mutable MaxValue : char" Usage="System.char.MaxValue" />
      <MemberSignature Language="C++ CLI" Value="public: char MaxValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the largest possible value of a <see cref="T:System.Char" />. This field is constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The value of this constant is hexadecimal 0xFFFF.

 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const char MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MinValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Char " />
      <MemberSignature Language="F#" Value="val mutable MinValue : char" Usage="System.char.MinValue" />
      <MemberSignature Language="C++ CLI" Value="public: char MinValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the smallest possible value of a <see cref="T:System.Char" />. This field is constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The value of this constant is hexadecimal 0x00.

 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static char Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Char" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; char" Usage="System.char.Parse s" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a single character, or <see langword="null" />.</param>
        <summary>Converts the value of the specified string to its equivalent Unicode character.</summary>
        <returns>A Unicode character equivalent to the sole character in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following code example demonstrates <xref:System.Char.Parse%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.Parse/CPP/parse.cpp" id="Snippet15":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/Parse/parse.cs" interactive="try-dotnet" id="Snippet15":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.Parse/FS/parse.fs" id="Snippet15":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Parse/VB/parse.vb" id="Snippet15":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">The length of <paramref name="s" /> is not 1.</exception>
        <altmember cref="M:System.Char.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-other">Parsing Other Strings in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="char.System.IComparable.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">The object to compare.</param>
        <summary>Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
        <returns>A value that indicates the relative order of the objects being compared.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IComparable> interface.

| Value             | Meaning                                                                 |
|-------------------|-------------------------------------------------------------------------|
| Less than zero    | This instance precedes `value` in the sort order.                       |
| Zero              | This instance occurs in the same position in the sort order as `value`. |
| Greater than zero | This instance follows `value` in the sort order.                        |

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="char.System.IConvertible.GetTypeCode " />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the <see cref="T:System.TypeCode" /> for this instance.</summary>
        <returns>The enumerated constant that is the <see cref="T:System.TypeCode" /> of the class or value type that implements this interface.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="char.System.IConvertible.ToBoolean provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>**Note** This conversion is not supported. Attempting to do so throws an <see cref="T:System.InvalidCastException" />.</summary>
        <returns>This conversion is not supported. No value is returned.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">This conversion is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="char.System.IConvertible.ToByte provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>The converted value of the current <see cref="T:System.Char" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToByte%28System.Char%29?displayProperty=nameWithType> method instead.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="char.System.IConvertible.ToChar provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>The value of the current <see cref="T:System.Char" /> object unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="char.System.IConvertible.ToDateTime provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>**Note** This conversion is not supported. Attempting to do so throws an <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No value is returned.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">This conversion is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="char.System.IConvertible.ToDecimal provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>**Note** This conversion is not supported. Attempting to do so throws an <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No value is returned.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">This conversion is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="char.System.IConvertible.ToDouble provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>**Note** This conversion is not supported. Attempting to do so throws an <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No value is returned.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">This conversion is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="char.System.IConvertible.ToInt16 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>The converted value of the current <see cref="T:System.Char" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.Char%29?displayProperty=nameWithType> method instead.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="char.System.IConvertible.ToInt32 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>The converted value of the current <see cref="T:System.Char" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.Char%29?displayProperty=nameWithType> method instead.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="char.System.IConvertible.ToInt64 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>The converted value of the current <see cref="T:System.Char" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt64%28System.Char%29?displayProperty=nameWithType> method instead.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="char.System.IConvertible.ToSByte provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>The converted value of the current <see cref="T:System.Char" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.Char%29?displayProperty=nameWithType> method instead.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="char.System.IConvertible.ToSingle provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>**Note** This conversion is not supported. Attempting to do so throws an <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No value is returned.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">This conversion is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToString : IFormatProvider -&gt; string&#xA;override this.System.IConvertible.ToString : IFormatProvider -&gt; string" Usage="char.System.IConvertible.ToString provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <summary>Converts the value of this instance to an equivalent string, using the specified culture-specific formatting information.</summary>
        <returns>A string equivalent to the value of this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="char.System.IConvertible.ToType (type, provider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> object.</param>
        <param name="provider">An <see cref="T:System.IFormatProvider" /> object.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>An object of the specified type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29> method instead.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">The value of the current <see cref="T:System.Char" /> object cannot be converted to the type specified by the <paramref name="type" /> parameter.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="char.System.IConvertible.ToUInt16 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">An <see cref="T:System.IFormatProvider" /> object. (Specify <see langword="null" /> because the <paramref name="provider" /> parameter is ignored.)</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>The converted value of the current <see cref="T:System.Char" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.Char%29?displayProperty=nameWithType> method instead.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="char.System.IConvertible.ToUInt32 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">An <see cref="T:System.IFormatProvider" /> object. (Specify <see langword="null" /> because the <paramref name="provider" /> parameter is ignored.)</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>The converted value of the current <see cref="T:System.Char" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.Char%29?displayProperty=nameWithType> method instead.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="char.System.IConvertible.ToUInt64 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">An <see cref="T:System.IFormatProvider" /> object. (Specify <see langword="null" /> because the <paramref name="provider" /> parameter is ignored.)</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>The converted value of the current <see cref="T:System.Char" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Char> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.Char%29?displayProperty=nameWithType> method instead.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider formatProvider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider formatProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (format As String, formatProvider As IFormatProvider) As String Implements IFormattable.ToString" />
      <MemberSignature Language="F#" Value="abstract member System.IFormattable.ToString : string * IFormatProvider -&gt; string&#xA;override this.System.IFormattable.ToString : string * IFormatProvider -&gt; string" Usage="char.System.IFormattable.ToString (format, formatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IFormattable.ToString(System::String ^ format, IFormatProvider ^ formatProvider) = IFormattable::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="format">The format to use.
 -or-
 A <see langword="null" /> reference (<see langword="Nothing" /> in Visual Basic) to use the default format defined for the type of the <see cref="T:System.IFormattable" /> implementation.</param>
        <param name="formatProvider">The provider to use to format the value.
 -or-
 A <see langword="null" /> reference (<see langword="Nothing" /> in Visual Basic) to obtain the numeric format information from the current locale setting of the operating system.</param>
        <summary>Formats the value of the current instance using the specified format.</summary>
        <returns>The value of the current instance in the specified format.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IParsable&lt;System.Char&gt;.Parse">
      <MemberSignature Language="C#" Value="static char IParsable&lt;char&gt;.Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.IParsable&lt;System.Char&gt;.Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IParsable&lt;System#Char&gt;#Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Parse (s As String, provider As IFormatProvider) As Char Implements IParsable(Of Char).Parse" />
      <MemberSignature Language="F#" Value="static member System.IParsable&lt;System.Char&gt;.Parse : string * IFormatProvider -&gt; char" Usage="System.char.System.IParsable&lt;System.Char&gt;.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.IParsable&lt;System.Char&gt;.Parse(System::String ^ s, IFormatProvider ^ provider) = IParsable&lt;char&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IParsable`1.Parse(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a string into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IParsable&lt;System.Char&gt;.TryParse">
      <MemberSignature Language="C#" Value="static bool IParsable&lt;char&gt;.TryParse (string s, IFormatProvider provider, out char result);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.IParsable&lt;System.Char&gt;.TryParse(string s, class System.IFormatProvider provider, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IParsable&lt;System#Char&gt;#TryParse(System.String,System.IFormatProvider,System.Char@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryParse (s As String, provider As IFormatProvider, ByRef result As Char) As Boolean Implements IParsable(Of Char).TryParse" />
      <MemberSignature Language="F#" Value="static member System.IParsable&lt;System.Char&gt;.TryParse : string * IFormatProvider * char -&gt; bool" Usage="System.char.System.IParsable&lt;System.Char&gt;.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.IParsable&lt;System.Char&gt;.TryParse(System::String ^ s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] char % result) = IParsable&lt;char&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Char" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ISpanFormattable.TryFormat">
      <MemberSignature Language="C#" Value="bool ISpanFormattable.TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.ISpanFormattable.TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#ISpanFormattable#TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, format As ReadOnlySpan(Of Char), provider As IFormatProvider) As Boolean Implements ISpanFormattable.TryFormat" />
      <MemberSignature Language="F#" Value="abstract member System.ISpanFormattable.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.System.ISpanFormattable.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="char.System.ISpanFormattable.TryFormat (destination, charsWritten, format, provider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.ISpanFormattable.TryFormat(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider ^ provider) = ISpanFormattable::TryFormat;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ISpanFormattable.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span in which to write this instance's value formatted as a span of characters.</param>
        <param name="charsWritten">When this method returns, the number of characters that were written in <paramref name="destination" />.</param>
        <param name="format">A span containing the characters that represent a standard or custom format string that defines the acceptable format for <paramref name="destination" />.</param>
        <param name="provider">An optional object that supplies culture-specific formatting information for <paramref name="destination" />.</param>
        <summary>Tries to format the value of the current instance into the provided span of characters.</summary>
        <returns>
          <see langword="true" /> if the formatting was successful; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ISpanParsable&lt;System.Char&gt;.Parse">
      <MemberSignature Language="C#" Value="static char ISpanParsable&lt;char&gt;.Parse (ReadOnlySpan&lt;char&gt; s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.ISpanParsable&lt;System.Char&gt;.Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#ISpanParsable&lt;System#Char&gt;#Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Parse (s As ReadOnlySpan(Of Char), provider As IFormatProvider) As Char Implements ISpanParsable(Of Char).Parse" />
      <MemberSignature Language="F#" Value="static member System.ISpanParsable&lt;System.Char&gt;.Parse : ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; char" Usage="System.char.System.ISpanParsable&lt;System.Char&gt;.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.ISpanParsable&lt;System.Char&gt;.Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider) = ISpanParsable&lt;char&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ISpanParsable&lt;System.Char&gt;.TryParse">
      <MemberSignature Language="C#" Value="static bool ISpanParsable&lt;char&gt;.TryParse (ReadOnlySpan&lt;char&gt; s, IFormatProvider provider, out char result);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.ISpanParsable&lt;System.Char&gt;.TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#ISpanParsable&lt;System#Char&gt;#TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Char@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryParse (s As ReadOnlySpan(Of Char), provider As IFormatProvider, ByRef result As Char) As Boolean Implements ISpanParsable(Of Char).TryParse" />
      <MemberSignature Language="F#" Value="static member System.ISpanParsable&lt;System.Char&gt;.TryParse : ReadOnlySpan&lt;char&gt; * IFormatProvider * char -&gt; bool" Usage="System.char.System.ISpanParsable&lt;System.Char&gt;.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.ISpanParsable&lt;System.Char&gt;.TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] char % result) = ISpanParsable&lt;char&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Char" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IUtf8SpanFormattable.TryFormat">
      <MemberSignature Language="C#" Value="bool IUtf8SpanFormattable.TryFormat (Span&lt;byte&gt; utf8Destination, out int bytesWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IUtf8SpanFormattable.TryFormat(valuetype System.Span`1&lt;unsigned int8&gt; utf8Destination, [out] int32&amp; bytesWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IUtf8SpanFormattable#TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function TryFormat (utf8Destination As Span(Of Byte), ByRef bytesWritten As Integer, format As ReadOnlySpan(Of Char), provider As IFormatProvider) As Boolean Implements IUtf8SpanFormattable.TryFormat" />
      <MemberSignature Language="F#" Value="abstract member System.IUtf8SpanFormattable.TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.System.IUtf8SpanFormattable.TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="char.System.IUtf8SpanFormattable.TryFormat (utf8Destination, bytesWritten, format, provider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IUtf8SpanFormattable.TryFormat(Span&lt;System::Byte&gt; utf8Destination, [Runtime::InteropServices::Out] int % bytesWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider ^ provider) = IUtf8SpanFormattable::TryFormat;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-8.0">M:System.Numerics.INumberBase`1.System#IUtf8SpanFormattable#TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
        <InterfaceMember FrameworkAlternate="net-9.0">M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditionOperators&lt;System.Char,System.Char,System.Char&gt;.op_Addition">
      <MemberSignature Language="C#" Value="static char IAdditionOperators&lt;char,char,char&gt;.operator + (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IAdditionOperators&lt;System.Char,System.Char,System.Char&gt;.op_Addition(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IAdditionOperators&lt;System#Char,System#Char,System#Char&gt;#op_Addition(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator + (left As Char, right As Char) As Char Implements IAdditionOperators(Of Char, Char, Char).op_Addition" />
      <MemberSignature Language="F#" Value="static member ( + ) : char * char -&gt; char" Usage="left + right" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IAdditionOperators&lt;System.Char,System.Char,System.Char&gt;.operator +(char left, char right) = System::Numerics::IAdditionOperators&lt;char, char, char&gt;::op_Addition;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IAdditionOperators`3.op_Addition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to which <paramref name="right" /> is added.</param>
        <param name="right">The value that's added to <paramref name="left" />.</param>
        <summary>Adds two values together to compute their sum.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditionOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedAddition">
      <MemberSignature Language="C#" Value="static char IAdditionOperators&lt;char,char,char&gt;.op_CheckedAddition (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IAdditionOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedAddition(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IAdditionOperators&lt;System#Char,System#Char,System#Char&gt;#op_CheckedAddition(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedAddition (left As Char, right As Char) As Char Implements IAdditionOperators(Of Char, Char, Char).op_CheckedAddition" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IAdditionOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedAddition : char * char -&gt; char" Usage="System.char.System.Numerics.IAdditionOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedAddition (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IAdditionOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedAddition(char left, char right) = System::Numerics::IAdditionOperators&lt;char, char, char&gt;::op_CheckedAddition;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IAdditionOperators`3.op_CheckedAddition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to which <paramref name="right" /> is added.</param>
        <param name="right">The value that's added to <paramref name="left" />.</param>
        <summary>Adds two values together to compute their sum.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditiveIdentity&lt;System.Char,System.Char&gt;.AdditiveIdentity">
      <MemberSignature Language="C#" Value="static char System.Numerics.IAdditiveIdentity&lt;System.Char,System.Char&gt;.AdditiveIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char System.Numerics.IAdditiveIdentity&lt;System.Char,System.Char&gt;.AdditiveIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Char.System#Numerics#IAdditiveIdentity&lt;System#Char,System#Char&gt;#AdditiveIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property AdditiveIdentity As Char Implements IAdditiveIdentity(Of Char, Char).AdditiveIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IAdditiveIdentity&lt;System.Char,System.Char&gt;.AdditiveIdentity : char" Usage="System.Numerics.IAdditiveIdentity&lt;System.Char,System.Char&gt;.AdditiveIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property char System::Numerics::IAdditiveIdentity&lt;System::Char,System::Char&gt;::AdditiveIdentity { char get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IAdditiveIdentity`2.AdditiveIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the additive identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetByteCount">
      <MemberSignature Language="C#" Value="int IBinaryInteger&lt;char&gt;.GetByteCount ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetByteCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryInteger&lt;System#Char&gt;#GetByteCount" />
      <MemberSignature Language="VB.NET" Value="Function GetByteCount () As Integer Implements IBinaryInteger(Of Char).GetByteCount" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetByteCount : unit -&gt; int&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetByteCount : unit -&gt; int" Usage="char.System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetByteCount " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetByteCount() = System::Numerics::IBinaryInteger&lt;char&gt;::GetByteCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.GetByteCount</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</summary>
        <returns>The number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.GetByteCount" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetShortestBitLength">
      <MemberSignature Language="C#" Value="int IBinaryInteger&lt;char&gt;.GetShortestBitLength ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetShortestBitLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryInteger&lt;System#Char&gt;#GetShortestBitLength" />
      <MemberSignature Language="VB.NET" Value="Function GetShortestBitLength () As Integer Implements IBinaryInteger(Of Char).GetShortestBitLength" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetShortestBitLength : unit -&gt; int&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetShortestBitLength : unit -&gt; int" Usage="char.System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetShortestBitLength " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IBinaryInteger&lt;System.Char&gt;.GetShortestBitLength() = System::Numerics::IBinaryInteger&lt;char&gt;::GetShortestBitLength;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.GetShortestBitLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the length, in bits, of the shortest two's complement representation of the current value.</summary>
        <returns>The length, in bits, of the shortest two's complement representation of the current value.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.GetShortestBitLength" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Char&gt;.LeadingZeroCount">
      <MemberSignature Language="C#" Value="static char IBinaryInteger&lt;char&gt;.LeadingZeroCount (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IBinaryInteger&lt;System.Char&gt;.LeadingZeroCount(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryInteger&lt;System#Char&gt;#LeadingZeroCount(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function LeadingZeroCount (value As Char) As Char Implements IBinaryInteger(Of Char).LeadingZeroCount" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.Char&gt;.LeadingZeroCount : char -&gt; char" Usage="System.char.System.Numerics.IBinaryInteger&lt;System.Char&gt;.LeadingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IBinaryInteger&lt;System.Char&gt;.LeadingZeroCount(char value) = System::Numerics::IBinaryInteger&lt;char&gt;::LeadingZeroCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.LeadingZeroCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose leading zero bits are to be counted.</param>
        <summary>Computes the number of leading zero bits in a value.</summary>
        <returns>The number of leading zero bits in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Char&gt;.PopCount">
      <MemberSignature Language="C#" Value="static char IBinaryInteger&lt;char&gt;.PopCount (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IBinaryInteger&lt;System.Char&gt;.PopCount(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryInteger&lt;System#Char&gt;#PopCount(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function PopCount (value As Char) As Char Implements IBinaryInteger(Of Char).PopCount" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.Char&gt;.PopCount : char -&gt; char" Usage="System.char.System.Numerics.IBinaryInteger&lt;System.Char&gt;.PopCount value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IBinaryInteger&lt;System.Char&gt;.PopCount(char value) = System::Numerics::IBinaryInteger&lt;char&gt;::PopCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.PopCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose set bits are to be counted.</param>
        <summary>Computes the number of bits that are set in a value.</summary>
        <returns>The number of set bits in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Char&gt;.RotateLeft">
      <MemberSignature Language="C#" Value="static char IBinaryInteger&lt;char&gt;.RotateLeft (char value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IBinaryInteger&lt;System.Char&gt;.RotateLeft(char value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryInteger&lt;System#Char&gt;#RotateLeft(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function RotateLeft (value As Char, rotateAmount As Integer) As Char Implements IBinaryInteger(Of Char).RotateLeft" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.Char&gt;.RotateLeft : char * int -&gt; char" Usage="System.char.System.Numerics.IBinaryInteger&lt;System.Char&gt;.RotateLeft (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IBinaryInteger&lt;System.Char&gt;.RotateLeft(char value, int rotateAmount) = System::Numerics::IBinaryInteger&lt;char&gt;::RotateLeft;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.RotateLeft(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that's rotated left by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated left.</param>
        <summary>Rotates a value left by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> left by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Char&gt;.RotateRight">
      <MemberSignature Language="C#" Value="static char IBinaryInteger&lt;char&gt;.RotateRight (char value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IBinaryInteger&lt;System.Char&gt;.RotateRight(char value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryInteger&lt;System#Char&gt;#RotateRight(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function RotateRight (value As Char, rotateAmount As Integer) As Char Implements IBinaryInteger(Of Char).RotateRight" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.Char&gt;.RotateRight : char * int -&gt; char" Usage="System.char.System.Numerics.IBinaryInteger&lt;System.Char&gt;.RotateRight (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IBinaryInteger&lt;System.Char&gt;.RotateRight(char value, int rotateAmount) = System::Numerics::IBinaryInteger&lt;char&gt;::RotateRight;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.RotateRight(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that's rotated right by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated right.</param>
        <summary>Rotates a value right by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> right by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Char&gt;.TrailingZeroCount">
      <MemberSignature Language="C#" Value="static char IBinaryInteger&lt;char&gt;.TrailingZeroCount (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IBinaryInteger&lt;System.Char&gt;.TrailingZeroCount(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryInteger&lt;System#Char&gt;#TrailingZeroCount(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TrailingZeroCount (value As Char) As Char Implements IBinaryInteger(Of Char).TrailingZeroCount" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.Char&gt;.TrailingZeroCount : char -&gt; char" Usage="System.char.System.Numerics.IBinaryInteger&lt;System.Char&gt;.TrailingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IBinaryInteger&lt;System.Char&gt;.TrailingZeroCount(char value) = System::Numerics::IBinaryInteger&lt;char&gt;::TrailingZeroCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TrailingZeroCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose trailing zero bits are to be counted.</param>
        <summary>Computes the number of trailing zero bits in a value.</summary>
        <returns>The number of trailing zero bits in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryReadBigEndian">
      <MemberSignature Language="C#" Value="static bool IBinaryInteger&lt;char&gt;.TryReadBigEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryReadBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] char&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryInteger&lt;System#Char&gt;#TryReadBigEndian(System.ReadOnlySpan{System.Byte},System.Boolean,System.Char@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryReadBigEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As Char) As Boolean Implements IBinaryInteger(Of Char).TryReadBigEndian" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryReadBigEndian : ReadOnlySpan&lt;byte&gt; * bool * char -&gt; bool" Usage="System.char.System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryReadBigEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryReadBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] char % value) = System::Numerics::IBinaryInteger&lt;char&gt;::TryReadBigEndian;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="value" Type="System.Char" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryReadLittleEndian">
      <MemberSignature Language="C#" Value="static bool IBinaryInteger&lt;char&gt;.TryReadLittleEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryReadLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] char&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryInteger&lt;System#Char&gt;#TryReadLittleEndian(System.ReadOnlySpan{System.Byte},System.Boolean,System.Char@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryReadLittleEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As Char) As Boolean Implements IBinaryInteger(Of Char).TryReadLittleEndian" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryReadLittleEndian : ReadOnlySpan&lt;byte&gt; * bool * char -&gt; bool" Usage="System.char.System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryReadLittleEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryReadLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] char % value) = System::Numerics::IBinaryInteger&lt;char&gt;::TryReadLittleEndian;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="value" Type="System.Char" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteBigEndian">
      <MemberSignature Language="C#" Value="bool IBinaryInteger&lt;char&gt;.TryWriteBigEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryInteger&lt;System#Char&gt;#TryWriteBigEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteBigEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IBinaryInteger(Of Char).TryWriteBigEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteBigEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteBigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="char.System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteBigEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteBigEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IBinaryInteger&lt;char&gt;::TryWriteBigEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TryWriteBigEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in big-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TryWriteBigEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteLittleEndian">
      <MemberSignature Language="C#" Value="bool IBinaryInteger&lt;char&gt;.TryWriteLittleEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryInteger&lt;System#Char&gt;#TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteLittleEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IBinaryInteger(Of Char).TryWriteLittleEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteLittleEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteLittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="char.System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteLittleEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IBinaryInteger&lt;System.Char&gt;.TryWriteLittleEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IBinaryInteger&lt;char&gt;::TryWriteLittleEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in little-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryNumber&lt;System.Char&gt;.AllBitsSet">
      <MemberSignature Language="C#" Value="static char System.Numerics.IBinaryNumber&lt;System.Char&gt;.AllBitsSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char System.Numerics.IBinaryNumber&lt;System.Char&gt;.AllBitsSet" />
      <MemberSignature Language="DocId" Value="P:System.Char.System#Numerics#IBinaryNumber&lt;System#Char&gt;#AllBitsSet" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property AllBitsSet As Char Implements IBinaryNumber(Of Char).AllBitsSet" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryNumber&lt;System.Char&gt;.AllBitsSet : char" Usage="System.Numerics.IBinaryNumber&lt;System.Char&gt;.AllBitsSet" />
      <MemberSignature Language="C++ CLI" Value="static property char System::Numerics::IBinaryNumber&lt;System::Char&gt;::AllBitsSet { char get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IBinaryNumber`1.AllBitsSet</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an instance of the binary type in which all bits are set.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryNumber&lt;System.Char&gt;.IsPow2">
      <MemberSignature Language="C#" Value="static bool IBinaryNumber&lt;char&gt;.IsPow2 (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IBinaryNumber&lt;System.Char&gt;.IsPow2(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryNumber&lt;System#Char&gt;#IsPow2(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsPow2 (value As Char) As Boolean Implements IBinaryNumber(Of Char).IsPow2" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryNumber&lt;System.Char&gt;.IsPow2 : char -&gt; bool" Usage="System.char.System.Numerics.IBinaryNumber&lt;System.Char&gt;.IsPow2 value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IBinaryNumber&lt;System.Char&gt;.IsPow2(char value) = System::Numerics::IBinaryNumber&lt;char&gt;::IsPow2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.IsPow2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is a power of two.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a power of two; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryNumber&lt;System.Char&gt;.Log2">
      <MemberSignature Language="C#" Value="static char IBinaryNumber&lt;char&gt;.Log2 (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IBinaryNumber&lt;System.Char&gt;.Log2(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBinaryNumber&lt;System#Char&gt;#Log2(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Log2 (value As Char) As Char Implements IBinaryNumber(Of Char).Log2" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryNumber&lt;System.Char&gt;.Log2 : char -&gt; char" Usage="System.char.System.Numerics.IBinaryNumber&lt;System.Char&gt;.Log2 value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IBinaryNumber&lt;System.Char&gt;.Log2(char value) = System::Numerics::IBinaryNumber&lt;char&gt;::Log2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.Log2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose log2 is to be computed.</param>
        <summary>Computes the log2 of a value.</summary>
        <returns>The log2 of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.op_BitwiseAnd">
      <MemberSignature Language="C#" Value="static char IBitwiseOperators&lt;char,char,char&gt;.operator &amp; (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.op_BitwiseAnd(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBitwiseOperators&lt;System#Char,System#Char,System#Char&gt;#op_BitwiseAnd(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator And (left As Char, right As Char) As Char Implements IBitwiseOperators(Of Char, Char, Char).op_BitwiseAnd" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : char * char -&gt; char" Usage="left &amp;&amp;&amp; right" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.operator &amp;(char left, char right) = System::Numerics::IBitwiseOperators&lt;char, char, char&gt;::op_BitwiseAnd;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_BitwiseAnd(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to <see langword="and" /> with <paramref name="right" />.</param>
        <param name="right">The value to <see langword="and" /> with <paramref name="left" />.</param>
        <summary>Computes the bitwise-and of two values.</summary>
        <returns>The bitwise-and of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.op_BitwiseOr">
      <MemberSignature Language="C#" Value="static char IBitwiseOperators&lt;char,char,char&gt;.operator | (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.op_BitwiseOr(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBitwiseOperators&lt;System#Char,System#Char,System#Char&gt;#op_BitwiseOr(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Or (left As Char, right As Char) As Char Implements IBitwiseOperators(Of Char, Char, Char).op_BitwiseOr" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : char * char -&gt; char" Usage="left ||| right" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.operator |(char left, char right) = System::Numerics::IBitwiseOperators&lt;char, char, char&gt;::op_BitwiseOr;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_BitwiseOr(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to <see langword="or" /> with <paramref name="right" />.</param>
        <param name="right">The value to <see langword="or" /> with <paramref name="left" />.</param>
        <summary>Computes the bitwise-or of two values.</summary>
        <returns>The bitwise-or of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.op_ExclusiveOr">
      <MemberSignature Language="C#" Value="static char IBitwiseOperators&lt;char,char,char&gt;.operator ^ (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.op_ExclusiveOr(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBitwiseOperators&lt;System#Char,System#Char,System#Char&gt;#op_ExclusiveOr(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Xor (left As Char, right As Char) As Char Implements IBitwiseOperators(Of Char, Char, Char).op_ExclusiveOr" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : char * char -&gt; char" Usage="left ^^^ right" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.operator ^(char left, char right) = System::Numerics::IBitwiseOperators&lt;char, char, char&gt;::op_ExclusiveOr;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_ExclusiveOr(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to xor with <paramref name="right" />.</param>
        <param name="right">The value to xor with <paramref name="left" />.</param>
        <summary>Computes the exclusive-or of two values.</summary>
        <returns>The exclusive-or of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.op_OnesComplement">
      <MemberSignature Language="C#" Value="static char IBitwiseOperators&lt;char,char,char&gt;.operator ~ (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.op_OnesComplement(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IBitwiseOperators&lt;System#Char,System#Char,System#Char&gt;#op_OnesComplement(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Not (value As Char) As Char Implements IBitwiseOperators(Of Char, Char, Char).op_OnesComplement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.op_OnesComplement : char -&gt; char" Usage="System.char.System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.op_OnesComplement value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IBitwiseOperators&lt;System.Char,System.Char,System.Char&gt;.operator ~(char value) = System::Numerics::IBitwiseOperators&lt;char, char, char&gt;::op_OnesComplement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_OnesComplement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the ones-complement.</param>
        <summary>Computes the ones-complement representation of a given value.</summary>
        <returns>The ones-complement of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_GreaterThan">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;char,char,bool&gt;.operator &gt; (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_GreaterThan(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IComparisonOperators&lt;System#Char,System#Char,System#Boolean&gt;#op_GreaterThan(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt; (left As Char, right As Char) As Boolean Implements IComparisonOperators(Of Char, Char, Boolean).op_GreaterThan" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : char * char -&gt; bool" Usage="left &gt; right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.operator &gt;(char left, char right) = System::Numerics::IComparisonOperators&lt;char, char, bool&gt;::op_GreaterThan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is greater.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;char,char,bool&gt;.operator &gt;= (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_GreaterThanOrEqual(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IComparisonOperators&lt;System#Char,System#Char,System#Boolean&gt;#op_GreaterThanOrEqual(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt;= (left As Char, right As Char) As Boolean Implements IComparisonOperators(Of Char, Char, Boolean).op_GreaterThanOrEqual" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : char * char -&gt; bool" Usage="left &gt;= right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.operator &gt;=(char left, char right) = System::Numerics::IComparisonOperators&lt;char, char, bool&gt;::op_GreaterThanOrEqual;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is greater or equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_LessThan">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;char,char,bool&gt;.operator &lt; (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_LessThan(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IComparisonOperators&lt;System#Char,System#Char,System#Boolean&gt;#op_LessThan(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt; (left As Char, right As Char) As Boolean Implements IComparisonOperators(Of Char, Char, Boolean).op_LessThan" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : char * char -&gt; bool" Usage="left &lt; right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.operator &lt;(char left, char right) = System::Numerics::IComparisonOperators&lt;char, char, bool&gt;::op_LessThan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is less.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;char,char,bool&gt;.operator &lt;= (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_LessThanOrEqual(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IComparisonOperators&lt;System#Char,System#Char,System#Boolean&gt;#op_LessThanOrEqual(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt;= (left As Char, right As Char) As Boolean Implements IComparisonOperators(Of Char, Char, Boolean).op_LessThanOrEqual" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : char * char -&gt; bool" Usage="left &lt;= right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Char,System.Char,System.Boolean&gt;.operator &lt;=(char left, char right) = System::Numerics::IComparisonOperators&lt;char, char, bool&gt;::op_LessThanOrEqual;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is less or equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDecrementOperators&lt;System.Char&gt;.op_CheckedDecrement">
      <MemberSignature Language="C#" Value="static char IDecrementOperators&lt;char&gt;.op_CheckedDecrement (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IDecrementOperators&lt;System.Char&gt;.op_CheckedDecrement(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IDecrementOperators&lt;System#Char&gt;#op_CheckedDecrement(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedDecrement (value As Char) As Char Implements IDecrementOperators(Of Char).op_CheckedDecrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IDecrementOperators&lt;System.Char&gt;.op_CheckedDecrement : char -&gt; char" Usage="System.char.System.Numerics.IDecrementOperators&lt;System.Char&gt;.op_CheckedDecrement value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IDecrementOperators&lt;System.Char&gt;.op_CheckedDecrement(char value) = System::Numerics::IDecrementOperators&lt;char&gt;::op_CheckedDecrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_CheckedDecrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to decrement.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDecrementOperators&lt;System.Char&gt;.op_Decrement">
      <MemberSignature Language="C#" Value="static char IDecrementOperators&lt;char&gt;.operator -- (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IDecrementOperators&lt;System.Char&gt;.op_Decrement(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IDecrementOperators&lt;System#Char&gt;#op_Decrement(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_Decrement (value As Char) As Char Implements IDecrementOperators(Of Char).op_Decrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IDecrementOperators&lt;System.Char&gt;.op_Decrement : char -&gt; char" Usage="System.char.System.Numerics.IDecrementOperators&lt;System.Char&gt;.op_Decrement value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IDecrementOperators&lt;System.Char&gt;.operator --(char value) = System::Numerics::IDecrementOperators&lt;char&gt;::op_Decrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_Decrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to decrement.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDivisionOperators&lt;System.Char,System.Char,System.Char&gt;.op_Division">
      <MemberSignature Language="C#" Value="static char IDivisionOperators&lt;char,char,char&gt;.operator / (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IDivisionOperators&lt;System.Char,System.Char,System.Char&gt;.op_Division(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IDivisionOperators&lt;System#Char,System#Char,System#Char&gt;#op_Division(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator / (left As Char, right As Char) As Char Implements IDivisionOperators(Of Char, Char, Char).op_Division" />
      <MemberSignature Language="F#" Value="static member ( / ) : char * char -&gt; char" Usage="left / right" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IDivisionOperators&lt;System.Char,System.Char,System.Char&gt;.operator /(char left, char right) = System::Numerics::IDivisionOperators&lt;char, char, char&gt;::op_Division;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDivisionOperators`3.op_Division(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> divides.</param>
        <param name="right">The value that divides <paramref name="left" />.</param>
        <summary>Divides one value by another to compute their quotient.</summary>
        <returns>The quotient of <paramref name="left" /> divided by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IEqualityOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_Equality">
      <MemberSignature Language="C#" Value="static bool IEqualityOperators&lt;char,char,bool&gt;.operator == (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IEqualityOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_Equality(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IEqualityOperators&lt;System#Char,System#Char,System#Boolean&gt;#op_Equality(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator == (left As Char, right As Char) As Boolean Implements IEqualityOperators(Of Char, Char, Boolean).op_Equality" />
      <MemberSignature Language="F#" Value="static member ( = ) : char * char -&gt; bool" Usage="left = right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IEqualityOperators&lt;System.Char,System.Char,System.Boolean&gt;.operator ==(char left, char right) = System::Numerics::IEqualityOperators&lt;char, char, bool&gt;::op_Equality;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine equality.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IEqualityOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_Inequality">
      <MemberSignature Language="C#" Value="static bool IEqualityOperators&lt;char,char,bool&gt;.operator != (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IEqualityOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_Inequality(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IEqualityOperators&lt;System#Char,System#Char,System#Boolean&gt;#op_Inequality(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator != (left As Char, right As Char) As Boolean Implements IEqualityOperators(Of Char, Char, Boolean).op_Inequality" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IEqualityOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_Inequality : char * char -&gt; bool" Usage="System.char.System.Numerics.IEqualityOperators&lt;System.Char,System.Char,System.Boolean&gt;.op_Inequality (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IEqualityOperators&lt;System.Char,System.Char,System.Boolean&gt;.operator !=(char left, char right) = System::Numerics::IEqualityOperators&lt;char, char, bool&gt;::op_Inequality;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine inequality.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IIncrementOperators&lt;System.Char&gt;.op_CheckedIncrement">
      <MemberSignature Language="C#" Value="static char IIncrementOperators&lt;char&gt;.op_CheckedIncrement (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IIncrementOperators&lt;System.Char&gt;.op_CheckedIncrement(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IIncrementOperators&lt;System#Char&gt;#op_CheckedIncrement(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedIncrement (value As Char) As Char Implements IIncrementOperators(Of Char).op_CheckedIncrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IIncrementOperators&lt;System.Char&gt;.op_CheckedIncrement : char -&gt; char" Usage="System.char.System.Numerics.IIncrementOperators&lt;System.Char&gt;.op_CheckedIncrement value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IIncrementOperators&lt;System.Char&gt;.op_CheckedIncrement(char value) = System::Numerics::IIncrementOperators&lt;char&gt;::op_CheckedIncrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_CheckedIncrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to increment.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IIncrementOperators&lt;System.Char&gt;.op_Increment">
      <MemberSignature Language="C#" Value="static char IIncrementOperators&lt;char&gt;.operator ++ (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IIncrementOperators&lt;System.Char&gt;.op_Increment(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IIncrementOperators&lt;System#Char&gt;#op_Increment(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_Increment (value As Char) As Char Implements IIncrementOperators(Of Char).op_Increment" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IIncrementOperators&lt;System.Char&gt;.op_Increment : char -&gt; char" Usage="System.char.System.Numerics.IIncrementOperators&lt;System.Char&gt;.op_Increment value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IIncrementOperators&lt;System.Char&gt;.operator ++(char value) = System::Numerics::IIncrementOperators&lt;char&gt;::op_Increment;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_Increment(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to increment.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMinMaxValue&lt;System.Char&gt;.MaxValue">
      <MemberSignature Language="C#" Value="static char System.Numerics.IMinMaxValue&lt;System.Char&gt;.MaxValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char System.Numerics.IMinMaxValue&lt;System.Char&gt;.MaxValue" />
      <MemberSignature Language="DocId" Value="P:System.Char.System#Numerics#IMinMaxValue&lt;System#Char&gt;#MaxValue" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MaxValue As Char Implements IMinMaxValue(Of Char).MaxValue" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMinMaxValue&lt;System.Char&gt;.MaxValue : char" Usage="System.Numerics.IMinMaxValue&lt;System.Char&gt;.MaxValue" />
      <MemberSignature Language="C++ CLI" Value="static property char System::Numerics::IMinMaxValue&lt;System::Char&gt;::MaxValue { char get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMinMaxValue`1.MaxValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum value of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMinMaxValue&lt;System.Char&gt;.MinValue">
      <MemberSignature Language="C#" Value="static char System.Numerics.IMinMaxValue&lt;System.Char&gt;.MinValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char System.Numerics.IMinMaxValue&lt;System.Char&gt;.MinValue" />
      <MemberSignature Language="DocId" Value="P:System.Char.System#Numerics#IMinMaxValue&lt;System#Char&gt;#MinValue" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MinValue As Char Implements IMinMaxValue(Of Char).MinValue" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMinMaxValue&lt;System.Char&gt;.MinValue : char" Usage="System.Numerics.IMinMaxValue&lt;System.Char&gt;.MinValue" />
      <MemberSignature Language="C++ CLI" Value="static property char System::Numerics::IMinMaxValue&lt;System::Char&gt;::MinValue { char get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMinMaxValue`1.MinValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the minimum value of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IModulusOperators&lt;System.Char,System.Char,System.Char&gt;.op_Modulus">
      <MemberSignature Language="C#" Value="static char IModulusOperators&lt;char,char,char&gt;.operator % (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IModulusOperators&lt;System.Char,System.Char,System.Char&gt;.op_Modulus(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IModulusOperators&lt;System#Char,System#Char,System#Char&gt;#op_Modulus(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Mod (left As Char, right As Char) As Char Implements IModulusOperators(Of Char, Char, Char).op_Modulus" />
      <MemberSignature Language="F#" Value="static member ( % ) : char * char -&gt; char" Usage="left % right" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IModulusOperators&lt;System.Char,System.Char,System.Char&gt;.operator %(char left, char right) = System::Numerics::IModulusOperators&lt;char, char, char&gt;::op_Modulus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IModulusOperators`3.op_Modulus(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> divides.</param>
        <param name="right">The value that divides <paramref name="left" />.</param>
        <summary>Divides two values together to compute their modulus or remainder.</summary>
        <returns>The modulus or remainder of <paramref name="left" /> divided by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplicativeIdentity&lt;System.Char,System.Char&gt;.MultiplicativeIdentity">
      <MemberSignature Language="C#" Value="static char System.Numerics.IMultiplicativeIdentity&lt;System.Char,System.Char&gt;.MultiplicativeIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char System.Numerics.IMultiplicativeIdentity&lt;System.Char,System.Char&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Char.System#Numerics#IMultiplicativeIdentity&lt;System#Char,System#Char&gt;#MultiplicativeIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MultiplicativeIdentity As Char Implements IMultiplicativeIdentity(Of Char, Char).MultiplicativeIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMultiplicativeIdentity&lt;System.Char,System.Char&gt;.MultiplicativeIdentity : char" Usage="System.Numerics.IMultiplicativeIdentity&lt;System.Char,System.Char&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property char System::Numerics::IMultiplicativeIdentity&lt;System::Char,System::Char&gt;::MultiplicativeIdentity { char get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMultiplicativeIdentity`2.MultiplicativeIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the multiplicative identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplyOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedMultiply">
      <MemberSignature Language="C#" Value="static char IMultiplyOperators&lt;char,char,char&gt;.op_CheckedMultiply (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IMultiplyOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedMultiply(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IMultiplyOperators&lt;System#Char,System#Char,System#Char&gt;#op_CheckedMultiply(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedMultiply (left As Char, right As Char) As Char Implements IMultiplyOperators(Of Char, Char, Char).op_CheckedMultiply" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMultiplyOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedMultiply : char * char -&gt; char" Usage="System.char.System.Numerics.IMultiplyOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedMultiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IMultiplyOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedMultiply(char left, char right) = System::Numerics::IMultiplyOperators&lt;char, char, char&gt;::op_CheckedMultiply;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IMultiplyOperators`3.op_CheckedMultiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> multiplies.</param>
        <param name="right">The value that multiplies <paramref name="left" />.</param>
        <summary>Multiplies two values together to compute their product.</summary>
        <returns>The product of <paramref name="left" /> multiplied by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplyOperators&lt;System.Char,System.Char,System.Char&gt;.op_Multiply">
      <MemberSignature Language="C#" Value="static char IMultiplyOperators&lt;char,char,char&gt;.operator * (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IMultiplyOperators&lt;System.Char,System.Char,System.Char&gt;.op_Multiply(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IMultiplyOperators&lt;System#Char,System#Char,System#Char&gt;#op_Multiply(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator * (left As Char, right As Char) As Char Implements IMultiplyOperators(Of Char, Char, Char).op_Multiply" />
      <MemberSignature Language="F#" Value="static member ( * ) : char * char -&gt; char" Usage="left * right" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IMultiplyOperators&lt;System.Char,System.Char,System.Char&gt;.operator *(char left, char right) = System::Numerics::IMultiplyOperators&lt;char, char, char&gt;::op_Multiply;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IMultiplyOperators`3.op_Multiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> multiplies.</param>
        <param name="right">The value that multiplies <paramref name="left" />.</param>
        <summary>Multiplies two values together to compute their product.</summary>
        <returns>The product of <paramref name="left" /> multiplied by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.Abs">
      <MemberSignature Language="C#" Value="static char INumberBase&lt;char&gt;.Abs (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.INumberBase&lt;System.Char&gt;.Abs(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#Abs(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Abs (value As Char) As Char Implements INumberBase(Of Char).Abs" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.Abs : char -&gt; char" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.Abs value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.INumberBase&lt;System.Char&gt;.Abs(char value) = System::Numerics::INumberBase&lt;char&gt;::Abs;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Abs(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to get its absolute.</param>
        <summary>Computes the absolute of a value.</summary>
        <returns>The absolute of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsCanonical">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsCanonical (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsCanonical(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsCanonical(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsCanonical (value As Char) As Boolean Implements INumberBase(Of Char).IsCanonical" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsCanonical : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsCanonical value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsCanonical(char value) = System::Numerics::INumberBase&lt;char&gt;::IsCanonical;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsCanonical(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is in its canonical representation.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is in its canonical representation; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsComplexNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsComplexNumber (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsComplexNumber(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsComplexNumber(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsComplexNumber (value As Char) As Boolean Implements INumberBase(Of Char).IsComplexNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsComplexNumber : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsComplexNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsComplexNumber(char value) = System::Numerics::INumberBase&lt;char&gt;::IsComplexNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsComplexNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a complex number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a complex number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsEvenInteger">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsEvenInteger (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsEvenInteger(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsEvenInteger(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsEvenInteger (value As Char) As Boolean Implements INumberBase(Of Char).IsEvenInteger" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsEvenInteger : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsEvenInteger value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsEvenInteger(char value) = System::Numerics::INumberBase&lt;char&gt;::IsEvenInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsEvenInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an even integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an even integer; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsFinite">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsFinite (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsFinite(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsFinite(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsFinite (value As Char) As Boolean Implements INumberBase(Of Char).IsFinite" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsFinite : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsFinite value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsFinite(char value) = System::Numerics::INumberBase&lt;char&gt;::IsFinite;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsFinite(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is finite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is finite; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsImaginaryNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsImaginaryNumber (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsImaginaryNumber(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsImaginaryNumber(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsImaginaryNumber (value As Char) As Boolean Implements INumberBase(Of Char).IsImaginaryNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsImaginaryNumber : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsImaginaryNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsImaginaryNumber(char value) = System::Numerics::INumberBase&lt;char&gt;::IsImaginaryNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsImaginaryNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a pure imaginary number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a pure imaginary number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsInfinity (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsInfinity(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsInfinity(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsInfinity (value As Char) As Boolean Implements INumberBase(Of Char).IsInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsInfinity : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsInfinity(char value) = System::Numerics::INumberBase&lt;char&gt;::IsInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is infinite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is infinite; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsInteger">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsInteger (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsInteger(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsInteger(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsInteger (value As Char) As Boolean Implements INumberBase(Of Char).IsInteger" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsInteger : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsInteger value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsInteger(char value) = System::Numerics::INumberBase&lt;char&gt;::IsInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an integer; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsNaN">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsNaN (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsNaN(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsNaN(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNaN (value As Char) As Boolean Implements INumberBase(Of Char).IsNaN" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsNaN : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsNaN value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsNaN(char value) = System::Numerics::INumberBase&lt;char&gt;::IsNaN;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNaN(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is NaN.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is NaN; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsNegative">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsNegative (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsNegative(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsNegative(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNegative (value As Char) As Boolean Implements INumberBase(Of Char).IsNegative" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsNegative : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsNegative value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsNegative(char value) = System::Numerics::INumberBase&lt;char&gt;::IsNegative;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegative(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsNegativeInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsNegativeInfinity (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsNegativeInfinity(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsNegativeInfinity(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNegativeInfinity (value As Char) As Boolean Implements INumberBase(Of Char).IsNegativeInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsNegativeInfinity : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsNegativeInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsNegativeInfinity(char value) = System::Numerics::INumberBase&lt;char&gt;::IsNegativeInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegativeInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsNormal">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsNormal (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsNormal(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsNormal(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNormal (value As Char) As Boolean Implements INumberBase(Of Char).IsNormal" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsNormal : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsNormal value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsNormal(char value) = System::Numerics::INumberBase&lt;char&gt;::IsNormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is normal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is normal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsOddInteger">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsOddInteger (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsOddInteger(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsOddInteger(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsOddInteger (value As Char) As Boolean Implements INumberBase(Of Char).IsOddInteger" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsOddInteger : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsOddInteger value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsOddInteger(char value) = System::Numerics::INumberBase&lt;char&gt;::IsOddInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsOddInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an odd integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an odd integer; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsPositive">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsPositive (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsPositive(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsPositive(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsPositive (value As Char) As Boolean Implements INumberBase(Of Char).IsPositive" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsPositive : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsPositive value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsPositive(char value) = System::Numerics::INumberBase&lt;char&gt;::IsPositive;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositive(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsPositiveInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsPositiveInfinity (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsPositiveInfinity(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsPositiveInfinity(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsPositiveInfinity (value As Char) As Boolean Implements INumberBase(Of Char).IsPositiveInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsPositiveInfinity : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsPositiveInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsPositiveInfinity(char value) = System::Numerics::INumberBase&lt;char&gt;::IsPositiveInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositiveInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsRealNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsRealNumber (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsRealNumber(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsRealNumber(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsRealNumber (value As Char) As Boolean Implements INumberBase(Of Char).IsRealNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsRealNumber : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsRealNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsRealNumber(char value) = System::Numerics::INumberBase&lt;char&gt;::IsRealNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsRealNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a real number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a real number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsSubnormal">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsSubnormal (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsSubnormal(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsSubnormal(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsSubnormal (value As Char) As Boolean Implements INumberBase(Of Char).IsSubnormal" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsSubnormal : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsSubnormal value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsSubnormal(char value) = System::Numerics::INumberBase&lt;char&gt;::IsSubnormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsSubnormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is subnormal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is subnormal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.IsZero">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.IsZero (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.IsZero(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#IsZero(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsZero (value As Char) As Boolean Implements INumberBase(Of Char).IsZero" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.IsZero : char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.IsZero value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.IsZero(char value) = System::Numerics::INumberBase&lt;char&gt;::IsZero;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsZero(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is zero.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is zero; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.MaxMagnitude">
      <MemberSignature Language="C#" Value="static char INumberBase&lt;char&gt;.MaxMagnitude (char x, char y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.INumberBase&lt;System.Char&gt;.MaxMagnitude(char x, char y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#MaxMagnitude(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxMagnitude (x As Char, y As Char) As Char Implements INumberBase(Of Char).MaxMagnitude" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.MaxMagnitude : char * char -&gt; char" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.INumberBase&lt;System.Char&gt;.MaxMagnitude(char x, char y) = System::Numerics::INumberBase&lt;char&gt;::MaxMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.MaxMagnitudeNumber">
      <MemberSignature Language="C#" Value="static char INumberBase&lt;char&gt;.MaxMagnitudeNumber (char x, char y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.INumberBase&lt;System.Char&gt;.MaxMagnitudeNumber(char x, char y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#MaxMagnitudeNumber(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxMagnitudeNumber (x As Char, y As Char) As Char Implements INumberBase(Of Char).MaxMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.MaxMagnitudeNumber : char * char -&gt; char" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.MaxMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.INumberBase&lt;System.Char&gt;.MaxMagnitudeNumber(char x, char y) = System::Numerics::INumberBase&lt;char&gt;::MaxMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the greater magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.MinMagnitude">
      <MemberSignature Language="C#" Value="static char INumberBase&lt;char&gt;.MinMagnitude (char x, char y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.INumberBase&lt;System.Char&gt;.MinMagnitude(char x, char y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#MinMagnitude(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinMagnitude (x As Char, y As Char) As Char Implements INumberBase(Of Char).MinMagnitude" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.MinMagnitude : char * char -&gt; char" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.INumberBase&lt;System.Char&gt;.MinMagnitude(char x, char y) = System::Numerics::INumberBase&lt;char&gt;::MinMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.MinMagnitudeNumber">
      <MemberSignature Language="C#" Value="static char INumberBase&lt;char&gt;.MinMagnitudeNumber (char x, char y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.INumberBase&lt;System.Char&gt;.MinMagnitudeNumber(char x, char y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#MinMagnitudeNumber(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinMagnitudeNumber (x As Char, y As Char) As Char Implements INumberBase(Of Char).MinMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.MinMagnitudeNumber : char * char -&gt; char" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.MinMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.INumberBase&lt;System.Char&gt;.MinMagnitudeNumber(char x, char y) = System::Numerics::INumberBase&lt;char&gt;::MinMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the lesser magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.One">
      <MemberSignature Language="C#" Value="static char System.Numerics.INumberBase&lt;System.Char&gt;.One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char System.Numerics.INumberBase&lt;System.Char&gt;.One" />
      <MemberSignature Language="DocId" Value="P:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#One" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property One As Char Implements INumberBase(Of Char).One" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.One : char" Usage="System.Numerics.INumberBase&lt;System.Char&gt;.One" />
      <MemberSignature Language="C++ CLI" Value="static property char System::Numerics::INumberBase&lt;System::Char&gt;::One { char get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.One</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>1</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.Parse">
      <MemberSignature Language="C#" Value="static char INumberBase&lt;char&gt;.Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.INumberBase&lt;System.Char&gt;.Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Parse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider) As Char Implements INumberBase(Of Char).Parse" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; char" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.INumberBase&lt;System.Char&gt;.Parse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider) = System::Numerics::INumberBase&lt;char&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.Parse">
      <MemberSignature Language="C#" Value="static char INumberBase&lt;char&gt;.Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.INumberBase&lt;System.Char&gt;.Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Char Implements INumberBase(Of Char).Parse" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; char" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.INumberBase&lt;System.Char&gt;.Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider) = System::Numerics::INumberBase&lt;char&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a string into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.Radix">
      <MemberSignature Language="C#" Value="static int System.Numerics.INumberBase&lt;System.Char&gt;.Radix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 System.Numerics.INumberBase&lt;System.Char&gt;.Radix" />
      <MemberSignature Language="DocId" Value="P:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#Radix" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property Radix As Integer Implements INumberBase(Of Char).Radix" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.Radix : int" Usage="System.Numerics.INumberBase&lt;System.Char&gt;.Radix" />
      <MemberSignature Language="C++ CLI" Value="static property int System::Numerics::INumberBase&lt;System::Char&gt;::Radix { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Radix</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the radix, or base, for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.TryConvertToChecked&lt;TOther&gt; (char value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(char value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#TryConvertToChecked``1(System.Char,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToChecked(Of TOther As INumberBase(Of TOther)) (value As Char, ByRef result As TOther) As Boolean Implements INumberBase(Of Char).TryConvertToChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToChecked : char * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToChecked(char value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;char&gt;::TryConvertToChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToChecked``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.TryConvertToSaturating&lt;TOther&gt; (char value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(char value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#TryConvertToSaturating``1(System.Char,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToSaturating(Of TOther As INumberBase(Of TOther)) (value As Char, ByRef result As TOther) As Boolean Implements INumberBase(Of Char).TryConvertToSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToSaturating : char * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToSaturating(char value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;char&gt;::TryConvertToSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToSaturating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.TryConvertToTruncating&lt;TOther&gt; (char value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(char value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#TryConvertToTruncating``1(System.Char,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToTruncating(Of TOther As INumberBase(Of TOther)) (value As Char, ByRef result As TOther) As Boolean Implements INumberBase(Of Char).TryConvertToTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToTruncating : char * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertToTruncating(char value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;char&gt;::TryConvertToTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToTruncating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.TryConvertFromChecked&lt;TOther&gt; (TOther value, out char result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#TryConvertFromChecked``1(``0,System.Char@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromChecked(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Char) As Boolean Implements INumberBase(Of Char).TryConvertFromChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromChecked : 'Other * char -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromChecked(TOther value, [Runtime::InteropServices::Out] char % result) = System::Numerics::INumberBase&lt;char&gt;::TryConvertFromChecked;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Char" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.TryConvertFromSaturating&lt;TOther&gt; (TOther value, out char result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#TryConvertFromSaturating``1(``0,System.Char@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Char) As Boolean Implements INumberBase(Of Char).TryConvertFromSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromSaturating : 'Other * char -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromSaturating(TOther value, [Runtime::InteropServices::Out] char % result) = System::Numerics::INumberBase&lt;char&gt;::TryConvertFromSaturating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Char" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.TryConvertFromTruncating&lt;TOther&gt; (TOther value, out char result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#TryConvertFromTruncating``1(``0,System.Char@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Char) As Boolean Implements INumberBase(Of Char).TryConvertFromTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromTruncating : 'Other * char -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Char&gt;.TryConvertFromTruncating(TOther value, [Runtime::InteropServices::Out] char % result) = System::Numerics::INumberBase&lt;char&gt;::TryConvertFromTruncating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Char" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.TryParse">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out char result);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Char@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Char) As Boolean Implements INumberBase(Of Char).TryParse" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] char % result) = System::Numerics::INumberBase&lt;char&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Char" RefType="out" Index="3" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.TryParse">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;char&gt;.TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out char result);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Char&gt;.TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Char@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Char) As Boolean Implements INumberBase(Of Char).TryParse" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.TryParse : string * System.Globalization.NumberStyles * IFormatProvider * char -&gt; bool" Usage="System.char.System.Numerics.INumberBase&lt;System.Char&gt;.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Char&gt;.TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] char % result) = System::Numerics::INumberBase&lt;char&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Char" RefType="out" Index="3" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Char&gt;.Zero">
      <MemberSignature Language="C#" Value="static char System.Numerics.INumberBase&lt;System.Char&gt;.Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char System.Numerics.INumberBase&lt;System.Char&gt;.Zero" />
      <MemberSignature Language="DocId" Value="P:System.Char.System#Numerics#INumberBase&lt;System#Char&gt;#Zero" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property Zero As Char Implements INumberBase(Of Char).Zero" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Char&gt;.Zero : char" Usage="System.Numerics.INumberBase&lt;System.Char&gt;.Zero" />
      <MemberSignature Language="C++ CLI" Value="static property char System::Numerics::INumberBase&lt;System::Char&gt;::Zero { char get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Zero</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>0</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;.op_LeftShift">
      <MemberSignature Language="C#" Value="static char IShiftOperators&lt;char,int,char&gt;.operator &lt;&lt; (char value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;.op_LeftShift(char value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IShiftOperators&lt;System#Char,System#Int32,System#Char&gt;#op_LeftShift(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt;&lt; (value As Char, shiftAmount As Integer) As Char Implements IShiftOperators(Of Char, Integer, Char).op_LeftShift" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : char * int -&gt; char" Usage="value &lt;&lt;&lt; shiftAmount" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;.operator &lt;&lt;(char value, int shiftAmount) = System::Numerics::IShiftOperators&lt;char, int, char&gt;::op_LeftShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_LeftShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted left by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted left.</param>
        <summary>Shifts a value left by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> left by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;.op_RightShift">
      <MemberSignature Language="C#" Value="static char IShiftOperators&lt;char,int,char&gt;.operator &gt;&gt; (char value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;.op_RightShift(char value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IShiftOperators&lt;System#Char,System#Int32,System#Char&gt;#op_RightShift(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt;&gt; (value As Char, shiftAmount As Integer) As Char Implements IShiftOperators(Of Char, Integer, Char).op_RightShift" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : char * int -&gt; char" Usage="value &gt;&gt;&gt; shiftAmount" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;.operator &gt;&gt;(char value, int shiftAmount) = System::Numerics::IShiftOperators&lt;char, int, char&gt;::op_RightShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_RightShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted right by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted right.</param>
        <summary>Shifts a value right by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> right by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;.op_UnsignedRightShift">
      <MemberSignature Language="C#" Value="static char IShiftOperators&lt;char,int,char&gt;.op_UnsignedRightShift (char value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;.op_UnsignedRightShift(char value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IShiftOperators&lt;System#Char,System#Int32,System#Char&gt;#op_UnsignedRightShift(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_UnsignedRightShift (value As Char, shiftAmount As Integer) As Char Implements IShiftOperators(Of Char, Integer, Char).op_UnsignedRightShift" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;.op_UnsignedRightShift : char * int -&gt; char" Usage="System.char.System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;.op_UnsignedRightShift (value, shiftAmount)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IShiftOperators&lt;System.Char,System.Int32,System.Char&gt;.op_UnsignedRightShift(char value, int shiftAmount) = System::Numerics::IShiftOperators&lt;char, int, char&gt;::op_UnsignedRightShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_UnsignedRightShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted right by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted right.</param>
        <summary>Shifts a value right by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> right by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.ISubtractionOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedSubtraction">
      <MemberSignature Language="C#" Value="static char ISubtractionOperators&lt;char,char,char&gt;.op_CheckedSubtraction (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.ISubtractionOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedSubtraction(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#ISubtractionOperators&lt;System#Char,System#Char,System#Char&gt;#op_CheckedSubtraction(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedSubtraction (left As Char, right As Char) As Char Implements ISubtractionOperators(Of Char, Char, Char).op_CheckedSubtraction" />
      <MemberSignature Language="F#" Value="static member System.Numerics.ISubtractionOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedSubtraction : char * char -&gt; char" Usage="System.char.System.Numerics.ISubtractionOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedSubtraction (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.ISubtractionOperators&lt;System.Char,System.Char,System.Char&gt;.op_CheckedSubtraction(char left, char right) = System::Numerics::ISubtractionOperators&lt;char, char, char&gt;::op_CheckedSubtraction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ISubtractionOperators`3.op_CheckedSubtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value from which <paramref name="right" /> is subtracted.</param>
        <param name="right">The value that's subtracted from <paramref name="left" />.</param>
        <summary>Subtracts two values to compute their difference.</summary>
        <returns>The value of <paramref name="right" /> subtracted from <paramref name="left" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.ISubtractionOperators&lt;System.Char,System.Char,System.Char&gt;.op_Subtraction">
      <MemberSignature Language="C#" Value="static char ISubtractionOperators&lt;char,char,char&gt;.operator - (char left, char right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.ISubtractionOperators&lt;System.Char,System.Char,System.Char&gt;.op_Subtraction(char left, char right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#ISubtractionOperators&lt;System#Char,System#Char,System#Char&gt;#op_Subtraction(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator - (left As Char, right As Char) As Char Implements ISubtractionOperators(Of Char, Char, Char).op_Subtraction" />
      <MemberSignature Language="F#" Value="static member ( - ) : char * char -&gt; char" Usage="left - right" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.ISubtractionOperators&lt;System.Char,System.Char,System.Char&gt;.operator -(char left, char right) = System::Numerics::ISubtractionOperators&lt;char, char, char&gt;::op_Subtraction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ISubtractionOperators`3.op_Subtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Char" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value from which <paramref name="right" /> is subtracted.</param>
        <param name="right">The value that's subtracted from <paramref name="left" />.</param>
        <summary>Subtracts two values to compute their difference.</summary>
        <returns>The value of <paramref name="right" /> subtracted from <paramref name="left" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryNegationOperators&lt;System.Char,System.Char&gt;.op_CheckedUnaryNegation">
      <MemberSignature Language="C#" Value="static char IUnaryNegationOperators&lt;char,char&gt;.op_CheckedUnaryNegation (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IUnaryNegationOperators&lt;System.Char,System.Char&gt;.op_CheckedUnaryNegation(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IUnaryNegationOperators&lt;System#Char,System#Char&gt;#op_CheckedUnaryNegation(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedUnaryNegation (value As Char) As Char Implements IUnaryNegationOperators(Of Char, Char).op_CheckedUnaryNegation" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IUnaryNegationOperators&lt;System.Char,System.Char&gt;.op_CheckedUnaryNegation : char -&gt; char" Usage="System.char.System.Numerics.IUnaryNegationOperators&lt;System.Char,System.Char&gt;.op_CheckedUnaryNegation value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IUnaryNegationOperators&lt;System.Char,System.Char&gt;.op_CheckedUnaryNegation(char value) = System::Numerics::IUnaryNegationOperators&lt;char, char&gt;::op_CheckedUnaryNegation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryNegationOperators`2.op_CheckedUnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary negation.</param>
        <summary>Computes the checked unary negation of a value.</summary>
        <returns>The unary negation of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryNegationOperators&lt;System.Char,System.Char&gt;.op_UnaryNegation">
      <MemberSignature Language="C#" Value="static char IUnaryNegationOperators&lt;char,char&gt;.operator - (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IUnaryNegationOperators&lt;System.Char,System.Char&gt;.op_UnaryNegation(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IUnaryNegationOperators&lt;System#Char,System#Char&gt;#op_UnaryNegation(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator - (value As Char) As Char Implements IUnaryNegationOperators(Of Char, Char).op_UnaryNegation" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : char -&gt; char" Usage="- value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IUnaryNegationOperators&lt;System.Char,System.Char&gt;.operator -(char value) = System::Numerics::IUnaryNegationOperators&lt;char, char&gt;::op_UnaryNegation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryNegationOperators`2.op_UnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary negation.</param>
        <summary>Computes the unary negation of a value.</summary>
        <returns>The unary negation of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryPlusOperators&lt;System.Char,System.Char&gt;.op_UnaryPlus">
      <MemberSignature Language="C#" Value="static char IUnaryPlusOperators&lt;char,char&gt;.operator + (char value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig char System.Numerics.IUnaryPlusOperators&lt;System.Char,System.Char&gt;.op_UnaryPlus(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#Numerics#IUnaryPlusOperators&lt;System#Char,System#Char&gt;#op_UnaryPlus(System.Char)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator + (value As Char) As Char Implements IUnaryPlusOperators(Of Char, Char).op_UnaryPlus" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : char -&gt; char" Usage="+ value" />
      <MemberSignature Language="C++ CLI" Value=" static char System.Numerics.IUnaryPlusOperators&lt;System.Char,System.Char&gt;.operator +(char value) = System::Numerics::IUnaryPlusOperators&lt;char, char&gt;::op_UnaryPlus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryPlusOperators`2.op_UnaryPlus(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary plus.</param>
        <summary>Computes the unary plus of a value.</summary>
        <returns>The unary plus of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the value of a Unicode character to its lowercase equivalent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following example demonstrates <xref:System.Char.ToLower%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToLower/CPP/tolower.cpp" id="Snippet16":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/ToLower/tolower.cs" interactive="try-dotnet" id="Snippet16":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.ToLower/FS/tolower.fs" id="Snippet16":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToLower/VB/tolower.vb" id="Snippet16":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char) As Char" />
      <MemberSignature Language="F#" Value="static member ToLower : char -&gt; char" Usage="System.char.ToLower c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to convert.</param>
        <summary>Converts the value of a Unicode character to its lowercase equivalent.</summary>
        <returns>The lowercase equivalent of <paramref name="c" />, or the unchanged value of <paramref name="c" />, if <paramref name="c" /> is already lowercase or not alphabetic.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Casing rules are obtained from the current culture.

 Use <xref:System.String.ToLower%2A?displayProperty=nameWithType> to convert a string to lowercase.

 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling character-casing and string-casing methods that substitute default values. Instead, you should call methods that require parameters to be explicitly specified. To convert a character to lowercase by using the casing conventions of the current culture, call the <see cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</para>
        </block>
        <altmember cref="M:System.Text.Rune.ToLower(System.Text.Rune,System.Globalization.CultureInfo)" />
        <altmember cref="M:System.Text.Rune.ToUpper(System.Text.Rune,System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="F#" Value="static member ToLower : char * System.Globalization.CultureInfo -&gt; char" Usage="System.char.ToLower (c, culture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to convert.</param>
        <param name="culture">An object that supplies culture-specific casing rules.</param>
        <summary>Converts the value of a specified Unicode character to its lowercase equivalent using specified culture-specific formatting information.</summary>
        <returns>The lowercase equivalent of <paramref name="c" />, modified according to <paramref name="culture" />, or the unchanged value of <paramref name="c" />, if <paramref name="c" /> is already lowercase or not alphabetic.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Use <xref:System.String.ToLower%2A?displayProperty=nameWithType> to convert a string to lowercase.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Text.Rune.ToLower(System.Text.Rune,System.Globalization.CultureInfo)" />
        <altmember cref="M:System.Text.Rune.ToUpper(System.Text.Rune,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static char ToLowerInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLowerInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLowerInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLowerInvariant (c As Char) As Char" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : char -&gt; char" Usage="System.char.ToLowerInvariant c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLowerInvariant(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to convert.</param>
        <summary>Converts the value of a Unicode character to its lowercase equivalent using the casing rules of the invariant culture.</summary>
        <returns>The lowercase equivalent of the <paramref name="c" /> parameter, or the unchanged value of <paramref name="c" />, if <paramref name="c" /> is already lowercase or not alphabetic.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 If your application is unaffected by the current culture and depends on the case of a character changing in a predictable way, then use the <xref:System.Char.ToLowerInvariant%2A> method. The <xref:System.Char.ToLowerInvariant%2A> method is equivalent to `ToLower(Char, CultureInfo.InvariantCulture)`.

 Use <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> to convert a string to lowercase.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.ToLowerInvariant(System.Text.Rune)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the value of this instance to its equivalent string representation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following code example demonstrates <xref:System.Char.ToString%2A>.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp" id="Snippet17":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/ToString/tostring.cs" interactive="try-dotnet" id="Snippet17":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Char.ToString/FS/tostring.fs" id="Snippet17":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb" id="Snippet17":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="char.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the value of this instance to its equivalent string representation.</summary>
        <returns>The string representation of the value of this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToString (c As Char) As String" />
      <MemberSignature Language="F#" Value="static member ToString : char -&gt; string" Usage="System.char.ToString c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ToString(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to convert.</param>
        <summary>Converts the specified Unicode character to its equivalent string representation.</summary>
        <returns>The string representation of the value of <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="char.ToString provider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-2.0;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">(Reserved) An object that supplies culture-specific formatting information.</param>
        <summary>Converts the value of this instance to its equivalent string representation using the specified culture-specific format information.</summary>
        <returns>The string representation of the value of this instance as specified by <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `provider` parameter is ignored; it does not participate in this operation.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the value of a Unicode character to its uppercase equivalent.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char) As Char" />
      <MemberSignature Language="F#" Value="static member ToUpper : char -&gt; char" Usage="System.char.ToUpper c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to convert.</param>
        <summary>Converts the value of a Unicode character to its uppercase equivalent.</summary>
        <returns>The uppercase equivalent of <paramref name="c" />, or the unchanged value of <paramref name="c" /> if <paramref name="c" /> is already uppercase, has no uppercase equivalent, or is not alphabetic.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Casing rules are obtained from the current culture.

 Use <xref:System.String.ToUpper%2A?displayProperty=nameWithType> to convert a string to uppercase.



## Examples
 The following example converts each character in an array to its uppercase equivalent.

 :::code language="csharp" source="~/snippets/csharp/System/Char/ToUpper/toupper1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.char.toupper/fs/toupper1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling character-casing and string-casing methods that substitute default values. Instead, you should call methods that require parameters to be explicitly specified. To convert a character to uppercase by using the casing conventions of the current culture, call the <see cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</para>
        </block>
        <altmember cref="M:System.Text.Rune.ToUpper(System.Text.Rune,System.Globalization.CultureInfo)" />
        <altmember cref="M:System.Text.Rune.ToLower(System.Text.Rune,System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="F#" Value="static member ToUpper : char * System.Globalization.CultureInfo -&gt; char" Usage="System.char.ToUpper (c, culture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to convert.</param>
        <param name="culture">An object that supplies culture-specific casing rules.</param>
        <summary>Converts the value of a specified Unicode character to its uppercase equivalent using specified culture-specific formatting information.</summary>
        <returns>The uppercase equivalent of <paramref name="c" />, modified according to <paramref name="culture" />, or the unchanged value of <paramref name="c" /> if <paramref name="c" /> is already uppercase, has no uppercase equivalent, or is not alphabetic.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Use <xref:System.String.ToUpper%2A?displayProperty=nameWithType> to convert a string to uppercase.



## Examples
 The following example converts each character in an array to its uppercase equivalent for the en-US culture, the invariant culture, and the tr-TR culture. In this example, the uppercase equivalent of each lowercase letter is identical for all cultures except for one case. The lowercase "i" character (U+0069) converts to "I" (U+0049) in the en-US and invariant cultures, but to "İ" (U+0130) in the tr-TR culture.

 :::code language="csharp" source="~/snippets/csharp/System/Char/ToUpper/toupper5.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.char.toupper/fs/toupper5.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper5.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Text.Rune.ToUpper(System.Text.Rune,System.Globalization.CultureInfo)" />
        <altmember cref="M:System.Text.Rune.ToLower(System.Text.Rune,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static char ToUpperInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpperInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpperInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpperInvariant (c As Char) As Char" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : char -&gt; char" Usage="System.char.ToUpperInvariant c" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpperInvariant(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">The Unicode character to convert.</param>
        <summary>Converts the value of a Unicode character to its uppercase equivalent using the casing rules of the invariant culture.</summary>
        <returns>The uppercase equivalent of the <paramref name="c" /> parameter, or the unchanged value of <paramref name="c" />, if <paramref name="c" /> is already uppercase or not alphabetic.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 If your application is unaffected by the current culture and depends on the case of a character changing in a predictable way, use the <xref:System.Char.ToUpperInvariant%2A> method.  The <xref:System.Char.ToUpperInvariant%2A> method is equivalent to `ToUpper(Char, CultureInfo.InvariantCulture)`.

 Use <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> to convert a string to uppercase.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Rune.ToUpperInvariant(System.Text.Rune)" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out char result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.TryParse(System.String,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Char) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * char -&gt; bool" Usage="System.char.TryParse (s, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] char % result);" />
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, out char result);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Char" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a single character, or <see langword="null" />.</param>
        <param name="result">When this method returns, contains a Unicode character equivalent to the sole character in <paramref name="s" />, if the conversion succeeded, or an undefined value if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is <see langword="null" /> or the length of <paramref name="s" /> is not 1. This parameter is passed uninitialized.</param>
        <summary>Converts the value of the specified string to its equivalent Unicode character. A return code indicates whether the conversion succeeded or failed.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="s" /> parameter was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Char.TryParse%2A> method is like the <xref:System.Char.Parse%2A> method, except the <xref:System.Char.TryParse%2A> method does not throw an exception if the conversion fails.



## Examples
 The following code example demonstrates overloads of the <xref:System.Char.TryParse%2A> method for several base types, and the <xref:System.DateTime.TryParseExact%2A> method for the <xref:System.DateTime> base type.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR/T.TryParse/CPP/tp.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Char/TryParse/tp.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR/T.TryParse/FS/tp.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR/T.TryParse/VB/tp.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="M:System.Char.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-other">Parsing Other Strings in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
