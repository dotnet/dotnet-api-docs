<Type Name="UInt128" FullName="System.UInt128">
  <TypeSignature Language="C#" Value="public readonly struct UInt128 : IComparable&lt;UInt128&gt;, IEquatable&lt;UInt128&gt;, IParsable&lt;UInt128&gt;, ISpanParsable&lt;UInt128&gt;, System.Numerics.IAdditionOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.IAdditiveIdentity&lt;UInt128,UInt128&gt;, System.Numerics.IBinaryInteger&lt;UInt128&gt;, System.Numerics.IBinaryNumber&lt;UInt128&gt;, System.Numerics.IBitwiseOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.IComparisonOperators&lt;UInt128,UInt128,bool&gt;, System.Numerics.IDecrementOperators&lt;UInt128&gt;, System.Numerics.IDivisionOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.IEqualityOperators&lt;UInt128,UInt128,bool&gt;, System.Numerics.IIncrementOperators&lt;UInt128&gt;, System.Numerics.IMinMaxValue&lt;UInt128&gt;, System.Numerics.IModulusOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.IMultiplicativeIdentity&lt;UInt128,UInt128&gt;, System.Numerics.IMultiplyOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.INumber&lt;UInt128&gt;, System.Numerics.INumberBase&lt;UInt128&gt;, System.Numerics.IShiftOperators&lt;UInt128,int,UInt128&gt;, System.Numerics.ISubtractionOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.IUnaryNegationOperators&lt;UInt128,UInt128&gt;, System.Numerics.IUnaryPlusOperators&lt;UInt128,UInt128&gt;, System.Numerics.IUnsignedNumber&lt;UInt128&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit UInt128 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.UInt128&gt;, class System.IEquatable`1&lt;valuetype System.UInt128&gt;, class System.IFormattable, class System.IParsable`1&lt;valuetype System.UInt128&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IAdditionOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IAdditiveIdentity`2&lt;valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IBinaryInteger`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IBinaryNumber`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IBitwiseOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IComparisonOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IDivisionOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IEqualityOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IMinMaxValue`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IModulusOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IMultiplyOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.INumber`1&lt;valuetype System.UInt128&gt;, class System.Numerics.INumberBase`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IShiftOperators`3&lt;valuetype System.UInt128, int32, valuetype System.UInt128&gt;, class System.Numerics.ISubtractionOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IUnsignedNumber`1&lt;valuetype System.UInt128&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="DocId" Value="T:System.UInt128" />
  <TypeSignature Language="VB.NET" Value="Public Structure UInt128&#xA;Implements IAdditionOperators(Of UInt128, UInt128, UInt128), IAdditiveIdentity(Of UInt128, UInt128), IBinaryInteger(Of UInt128), IBinaryNumber(Of UInt128), IBitwiseOperators(Of UInt128, UInt128, UInt128), IComparable(Of UInt128), IComparisonOperators(Of UInt128, UInt128, Boolean), IDecrementOperators(Of UInt128), IDivisionOperators(Of UInt128, UInt128, UInt128), IEqualityOperators(Of UInt128, UInt128, Boolean), IEquatable(Of UInt128), IIncrementOperators(Of UInt128), IMinMaxValue(Of UInt128), IModulusOperators(Of UInt128, UInt128, UInt128), IMultiplicativeIdentity(Of UInt128, UInt128), IMultiplyOperators(Of UInt128, UInt128, UInt128), INumber(Of UInt128), INumberBase(Of UInt128), IParsable(Of UInt128), IShiftOperators(Of UInt128, Integer, UInt128), ISpanParsable(Of UInt128), ISubtractionOperators(Of UInt128, UInt128, UInt128), IUnaryNegationOperators(Of UInt128, UInt128), IUnaryPlusOperators(Of UInt128, UInt128), IUnsignedNumber(Of UInt128)" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="F#" Value="type UInt128 = struct&#xA;    interface IFormattable&#xA;    interface IParsable&lt;UInt128&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;UInt128&gt;&#xA;    interface IAdditionOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IAdditiveIdentity&lt;UInt128, UInt128&gt;&#xA;    interface IBinaryInteger&lt;UInt128&gt;&#xA;    interface IBinaryNumber&lt;UInt128&gt;&#xA;    interface IBitwiseOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IComparisonOperators&lt;UInt128, UInt128, bool&gt;&#xA;    interface IEqualityOperators&lt;UInt128, UInt128, bool&gt;&#xA;    interface IDecrementOperators&lt;UInt128&gt;&#xA;    interface IDivisionOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IIncrementOperators&lt;UInt128&gt;&#xA;    interface IModulusOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IMultiplicativeIdentity&lt;UInt128, UInt128&gt;&#xA;    interface IMultiplyOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface INumber&lt;UInt128&gt;&#xA;    interface INumberBase&lt;UInt128&gt;&#xA;    interface ISubtractionOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IUnaryNegationOperators&lt;UInt128, UInt128&gt;&#xA;    interface IUnaryPlusOperators&lt;UInt128, UInt128&gt;&#xA;    interface IShiftOperators&lt;UInt128, int, UInt128&gt;&#xA;    interface IMinMaxValue&lt;UInt128&gt;&#xA;    interface IUnsignedNumber&lt;UInt128&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C++ CLI" Value="public value class UInt128 : IComparable&lt;UInt128&gt;, IEquatable&lt;UInt128&gt;, IParsable&lt;UInt128&gt;, ISpanParsable&lt;UInt128&gt;, System::Numerics::IAdditionOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::IAdditiveIdentity&lt;UInt128, UInt128&gt;, System::Numerics::IBinaryInteger&lt;UInt128&gt;, System::Numerics::IBinaryNumber&lt;UInt128&gt;, System::Numerics::IBitwiseOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::IComparisonOperators&lt;UInt128, UInt128, bool&gt;, System::Numerics::IDecrementOperators&lt;UInt128&gt;, System::Numerics::IDivisionOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::IEqualityOperators&lt;UInt128, UInt128, bool&gt;, System::Numerics::IIncrementOperators&lt;UInt128&gt;, System::Numerics::IMinMaxValue&lt;UInt128&gt;, System::Numerics::IModulusOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::IMultiplicativeIdentity&lt;UInt128, UInt128&gt;, System::Numerics::IMultiplyOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::INumber&lt;UInt128&gt;, System::Numerics::INumberBase&lt;UInt128&gt;, System::Numerics::IShiftOperators&lt;UInt128, int, UInt128&gt;, System::Numerics::ISubtractionOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::IUnaryNegationOperators&lt;UInt128, UInt128&gt;, System::Numerics::IUnaryPlusOperators&lt;UInt128, UInt128&gt;, System::Numerics::IUnsignedNumber&lt;UInt128&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C#" Value="public readonly struct UInt128 : IComparable&lt;UInt128&gt;, IEquatable&lt;UInt128&gt;, IParsable&lt;UInt128&gt;, ISpanParsable&lt;UInt128&gt;, IUtf8SpanParsable&lt;UInt128&gt;, System.Numerics.IAdditionOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.IAdditiveIdentity&lt;UInt128,UInt128&gt;, System.Numerics.IBinaryInteger&lt;UInt128&gt;, System.Numerics.IBinaryNumber&lt;UInt128&gt;, System.Numerics.IBitwiseOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.IComparisonOperators&lt;UInt128,UInt128,bool&gt;, System.Numerics.IDecrementOperators&lt;UInt128&gt;, System.Numerics.IDivisionOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.IEqualityOperators&lt;UInt128,UInt128,bool&gt;, System.Numerics.IIncrementOperators&lt;UInt128&gt;, System.Numerics.IMinMaxValue&lt;UInt128&gt;, System.Numerics.IModulusOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.IMultiplicativeIdentity&lt;UInt128,UInt128&gt;, System.Numerics.IMultiplyOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.INumber&lt;UInt128&gt;, System.Numerics.INumberBase&lt;UInt128&gt;, System.Numerics.IShiftOperators&lt;UInt128,int,UInt128&gt;, System.Numerics.ISubtractionOperators&lt;UInt128,UInt128,UInt128&gt;, System.Numerics.IUnaryNegationOperators&lt;UInt128,UInt128&gt;, System.Numerics.IUnaryPlusOperators&lt;UInt128,UInt128&gt;, System.Numerics.IUnsignedNumber&lt;UInt128&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit UInt128 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.UInt128&gt;, class System.IEquatable`1&lt;valuetype System.UInt128&gt;, class System.IFormattable, class System.IParsable`1&lt;valuetype System.UInt128&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;valuetype System.UInt128&gt;, class System.IUtf8SpanFormattable, class System.IUtf8SpanParsable`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IAdditionOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IAdditiveIdentity`2&lt;valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IBinaryInteger`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IBinaryNumber`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IBitwiseOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IComparisonOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IDivisionOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IEqualityOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IMinMaxValue`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IModulusOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IMultiplyOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.INumber`1&lt;valuetype System.UInt128&gt;, class System.Numerics.INumberBase`1&lt;valuetype System.UInt128&gt;, class System.Numerics.IShiftOperators`3&lt;valuetype System.UInt128, int32, valuetype System.UInt128&gt;, class System.Numerics.ISubtractionOperators`3&lt;valuetype System.UInt128, valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;valuetype System.UInt128, valuetype System.UInt128&gt;, class System.Numerics.IUnsignedNumber`1&lt;valuetype System.UInt128&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure UInt128&#xA;Implements IAdditionOperators(Of UInt128, UInt128, UInt128), IAdditiveIdentity(Of UInt128, UInt128), IBinaryInteger(Of UInt128), IBinaryNumber(Of UInt128), IBitwiseOperators(Of UInt128, UInt128, UInt128), IComparable(Of UInt128), IComparisonOperators(Of UInt128, UInt128, Boolean), IDecrementOperators(Of UInt128), IDivisionOperators(Of UInt128, UInt128, UInt128), IEqualityOperators(Of UInt128, UInt128, Boolean), IEquatable(Of UInt128), IIncrementOperators(Of UInt128), IMinMaxValue(Of UInt128), IModulusOperators(Of UInt128, UInt128, UInt128), IMultiplicativeIdentity(Of UInt128, UInt128), IMultiplyOperators(Of UInt128, UInt128, UInt128), INumber(Of UInt128), INumberBase(Of UInt128), IParsable(Of UInt128), IShiftOperators(Of UInt128, Integer, UInt128), ISpanParsable(Of UInt128), ISubtractionOperators(Of UInt128, UInt128, UInt128), IUnaryNegationOperators(Of UInt128, UInt128), IUnaryPlusOperators(Of UInt128, UInt128), IUnsignedNumber(Of UInt128), IUtf8SpanParsable(Of UInt128)" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type UInt128 = struct&#xA;    interface IFormattable&#xA;    interface IParsable&lt;UInt128&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;UInt128&gt;&#xA;    interface IAdditionOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IAdditiveIdentity&lt;UInt128, UInt128&gt;&#xA;    interface IBinaryInteger&lt;UInt128&gt;&#xA;    interface IBinaryNumber&lt;UInt128&gt;&#xA;    interface IBitwiseOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IComparisonOperators&lt;UInt128, UInt128, bool&gt;&#xA;    interface IEqualityOperators&lt;UInt128, UInt128, bool&gt;&#xA;    interface IDecrementOperators&lt;UInt128&gt;&#xA;    interface IDivisionOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IIncrementOperators&lt;UInt128&gt;&#xA;    interface IModulusOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IMultiplicativeIdentity&lt;UInt128, UInt128&gt;&#xA;    interface IMultiplyOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface INumber&lt;UInt128&gt;&#xA;    interface INumberBase&lt;UInt128&gt;&#xA;    interface ISubtractionOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IUnaryNegationOperators&lt;UInt128, UInt128&gt;&#xA;    interface IUnaryPlusOperators&lt;UInt128, UInt128&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;UInt128&gt;&#xA;    interface IShiftOperators&lt;UInt128, int, UInt128&gt;&#xA;    interface IMinMaxValue&lt;UInt128&gt;&#xA;    interface IUnsignedNumber&lt;UInt128&gt;" FrameworkAlternate="net-8.0" />
  <TypeSignature Language="C++ CLI" Value="public value class UInt128 : IComparable&lt;UInt128&gt;, IEquatable&lt;UInt128&gt;, IParsable&lt;UInt128&gt;, ISpanParsable&lt;UInt128&gt;, IUtf8SpanParsable&lt;UInt128&gt;, System::Numerics::IAdditionOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::IAdditiveIdentity&lt;UInt128, UInt128&gt;, System::Numerics::IBinaryInteger&lt;UInt128&gt;, System::Numerics::IBinaryNumber&lt;UInt128&gt;, System::Numerics::IBitwiseOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::IComparisonOperators&lt;UInt128, UInt128, bool&gt;, System::Numerics::IDecrementOperators&lt;UInt128&gt;, System::Numerics::IDivisionOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::IEqualityOperators&lt;UInt128, UInt128, bool&gt;, System::Numerics::IIncrementOperators&lt;UInt128&gt;, System::Numerics::IMinMaxValue&lt;UInt128&gt;, System::Numerics::IModulusOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::IMultiplicativeIdentity&lt;UInt128, UInt128&gt;, System::Numerics::IMultiplyOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::INumber&lt;UInt128&gt;, System::Numerics::INumberBase&lt;UInt128&gt;, System::Numerics::IShiftOperators&lt;UInt128, int, UInt128&gt;, System::Numerics::ISubtractionOperators&lt;UInt128, UInt128, UInt128&gt;, System::Numerics::IUnaryNegationOperators&lt;UInt128, UInt128&gt;, System::Numerics::IUnaryPlusOperators&lt;UInt128, UInt128&gt;, System::Numerics::IUnsignedNumber&lt;UInt128&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type UInt128 = struct&#xA;    interface IFormattable&#xA;    interface IParsable&lt;UInt128&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;UInt128&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;UInt128&gt;&#xA;    interface IAdditionOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IAdditiveIdentity&lt;UInt128, UInt128&gt;&#xA;    interface IBinaryInteger&lt;UInt128&gt;&#xA;    interface IBinaryNumber&lt;UInt128&gt;&#xA;    interface IBitwiseOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IComparisonOperators&lt;UInt128, UInt128, bool&gt;&#xA;    interface IEqualityOperators&lt;UInt128, UInt128, bool&gt;&#xA;    interface IDecrementOperators&lt;UInt128&gt;&#xA;    interface IDivisionOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IIncrementOperators&lt;UInt128&gt;&#xA;    interface IModulusOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IMultiplicativeIdentity&lt;UInt128, UInt128&gt;&#xA;    interface IMultiplyOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface INumber&lt;UInt128&gt;&#xA;    interface INumberBase&lt;UInt128&gt;&#xA;    interface ISubtractionOperators&lt;UInt128, UInt128, UInt128&gt;&#xA;    interface IUnaryNegationOperators&lt;UInt128, UInt128&gt;&#xA;    interface IUnaryPlusOperators&lt;UInt128, UInt128&gt;&#xA;    interface IShiftOperators&lt;UInt128, int, UInt128&gt;&#xA;    interface IMinMaxValue&lt;UInt128&gt;&#xA;    interface IUnsignedNumber&lt;UInt128&gt;" FrameworkAlternate="net-9.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IParsable&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ISpanFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ISpanParsable&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ISpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditionOperators&lt;System.UInt128,System.UInt128,System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;System.UInt128,System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IBinaryInteger&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IBinaryNumber&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IBinaryNumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;System.UInt128,System.UInt128,System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IComparisonOperators&lt;System.UInt128,System.UInt128,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IComparisonOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDecrementOperators&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDecrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDivisionOperators&lt;System.UInt128,System.UInt128,System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IEqualityOperators&lt;System.UInt128,System.UInt128,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TOther,TResult&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IIncrementOperators&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IIncrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMinMaxValue&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IModulusOperators&lt;System.UInt128,System.UInt128,System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;System.UInt128,System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;System.UInt128,System.UInt128,System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.INumber&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.INumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.INumberBase&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.INumberBase&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IShiftOperators&lt;System.UInt128,System.Int32,System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IShiftOperators&lt;TSelf,System.Int32,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;System.UInt128,System.UInt128,System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;System.UInt128,System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;System.UInt128,System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnsignedNumber&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;System.UInt128&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a 128-bit unsigned integer.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UInt128 (ulong upper, ulong lower);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 upper, unsigned int64 lower) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.#ctor(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (upper As ULong, lower As ULong)" />
      <MemberSignature Language="F#" Value="new UInt128 : uint64 * uint64 -&gt; UInt128" Usage="new System.UInt128 (upper, lower)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UInt128(System::UInt64 upper, System::UInt64 lower);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="upper" Type="System.UInt64" />
        <Parameter Name="lower" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="upper">The upper 64-bits of the 128-bit value.</param>
        <param name="lower">The lower 64-bits of the 128-bit value.</param>
        <summary>Initializes a new instance of the <see cref="T:System.UInt128" /> struct.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static UInt128 Clamp (UInt128 value, UInt128 min, UInt128 max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Clamp(valuetype System.UInt128 value, valuetype System.UInt128 min, valuetype System.UInt128 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Clamp(System.UInt128,System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UInt128, min As UInt128, max As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member Clamp : UInt128 * UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 Clamp(UInt128 value, UInt128 min, UInt128 max) = System::Numerics::INumber&lt;UInt128&gt;::Clamp;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Clamp(`0,`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
        <Parameter Name="min" Type="System.UInt128" />
        <Parameter Name="max" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to clamp.</param>
        <param name="min">The inclusive minimum to which <paramref name="value" /> should clamp.</param>
        <param name="max">The inclusive maximum to which <paramref name="value" /> should clamp.</param>
        <summary>Clamps a value to an inclusive minimum and maximum value.</summary>
        <returns>The result of clamping <paramref name="value" /> to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Clamp(`0,`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object? value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="uInt128.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">An object to compare with this instance.</param>
        <summary>Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
        <returns>
          <para>A value that indicates the relative order of the objects being compared. The return value has these meanings:</para>
          <list type="table">
            <listheader>
              <term>Value</term>
              <description>Meaning</description>
            </listheader>
            <item>
              <term>Less than zero</term>
              <description>This instance precedes <paramref name="value" /> in the sort order.</description>
            </item>
            <item>
              <term>Zero</term>
              <description>This instance occurs in the same position in the sort order as <paramref name="value" />.</description>
            </item>
            <item>
              <term>Greater than zero</term>
              <description>This instance follows <paramref name="value" /> in the sort order.</description>
            </item>
          </list>
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IComparable.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.CompareTo(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As UInt128) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : UInt128 -&gt; int&#xA;override this.CompareTo : UInt128 -&gt; int" Usage="uInt128.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(UInt128 value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">An object to compare with this instance.</param>
        <summary>Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
        <returns>
          <para>A value that indicates the relative order of the objects being compared. The return value has these meanings:</para>
          <list type="table">
            <listheader>
              <term>Value</term>
              <description>Meaning</description>
            </listheader>
            <item>
              <term>Less than zero</term>
              <description>This instance precedes <paramref name="value" /> in the sort order.</description>
            </item>
            <item>
              <term>Zero</term>
              <description>This instance occurs in the same position in the sort order as <paramref name="value" />.</description>
            </item>
            <item>
              <term>Greater than zero</term>
              <description>This instance follows <paramref name="value" /> in the sort order.</description>
            </item>
          </list>
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static UInt128 CreateChecked&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 CreateChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.CreateChecked``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateChecked(Of TOther As INumberBase(Of TOther)) (value As TOther) As UInt128" />
      <MemberSignature Language="F#" Value="static member CreateChecked : 'Other -&gt; UInt128 (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.UInt128.CreateChecked value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static UInt128 CreateChecked(TOther value) = System::Numerics::INumberBase&lt;UInt128&gt;::CreateChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateChecked``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <code data-dev-comment-type="typeparamref">TSelf</code>.</param>
        <summary>Creates an instance of the current type from a value, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateChecked``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static UInt128 CreateSaturating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 CreateSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.CreateSaturating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther) As UInt128" />
      <MemberSignature Language="F#" Value="static member CreateSaturating : 'Other -&gt; UInt128 (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.UInt128.CreateSaturating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static UInt128 CreateSaturating(TOther value) = System::Numerics::INumberBase&lt;UInt128&gt;::CreateSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <code data-dev-comment-type="typeparamref">TSelf</code>.</param>
        <summary>Creates an instance of the current type from a value, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, saturating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static UInt128 CreateTruncating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 CreateTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.CreateTruncating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther) As UInt128" />
      <MemberSignature Language="F#" Value="static member CreateTruncating : 'Other -&gt; UInt128 (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.UInt128.CreateTruncating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static UInt128 CreateTruncating(TOther value) = System::Numerics::INumberBase&lt;UInt128&gt;::CreateTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <code data-dev-comment-type="typeparamref">TSelf</code>.</param>
        <summary>Creates an instance of the current type from a value, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, truncating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (UInt128 Quotient, UInt128 Remainder) DivRem (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;valuetype System.UInt128, valuetype System.UInt128&gt; DivRem(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.DivRem(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As UInt128, right As UInt128) As ValueTuple(Of UInt128, UInt128)" />
      <MemberSignature Language="F#" Value="static member DivRem : UInt128 * UInt128 -&gt; ValueTuple&lt;UInt128, UInt128&gt;" Usage="System.UInt128.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;UInt128, UInt128&gt; DivRem(UInt128 left, UInt128 right) = System::Numerics::IBinaryInteger&lt;UInt128&gt;::DivRem;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.DivRem(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.UInt128,System.UInt128&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-7.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">The value which <paramref name="right" /> divides.</param>
        <param name="right">The value which divides <paramref name="left" />.</param>
        <summary>Computes the quotient and remainder of two values.</summary>
        <returns>The quotient and remainder of <paramref name="left" /> divided-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.DivRem(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object? obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uInt128.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="obj">The object to compare with the current object.</param>
        <summary>Determines whether the specified object is equal to the current object.</summary>
        <returns>
          <see langword="true" /> if the specified object is equal to the current object; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (UInt128 other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.UInt128 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Equals(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : UInt128 -&gt; bool" Usage="uInt128.Equals other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(UInt128 other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="other">An object to compare with this object.</param>
        <summary>Indicates whether the current object is equal to another object of the same type.</summary>
        <returns>
          <see langword="true" /> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IEquatable`1.Equals(`0)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uInt128.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serves as the default hash function.</summary>
        <returns>A hash code for the current object.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="IsEvenInteger">
      <MemberSignature Language="C#" Value="public static bool IsEvenInteger (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEvenInteger(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.IsEvenInteger(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEvenInteger (value As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsEvenInteger : UInt128 -&gt; bool" Usage="System.UInt128.IsEvenInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEvenInteger(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsEvenInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsEvenInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an even integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an even integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `2.0` will return `true` while `2.2` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsOddInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsEvenInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsOddInteger">
      <MemberSignature Language="C#" Value="public static bool IsOddInteger (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOddInteger(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.IsOddInteger(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOddInteger (value As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsOddInteger : UInt128 -&gt; bool" Usage="System.UInt128.IsOddInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOddInteger(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsOddInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsOddInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an odd integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an odd integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `3.0` will return `true` while `3.3` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsEvenInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsOddInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsPow2">
      <MemberSignature Language="C#" Value="public static bool IsPow2 (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPow2(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.IsPow2(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPow2 (value As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPow2 : UInt128 -&gt; bool" Usage="System.UInt128.IsPow2 value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPow2(UInt128 value) = System::Numerics::IBinaryNumber&lt;UInt128&gt;::IsPow2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.IsPow2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is a power of two.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a power of two; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryNumber`1.IsPow2(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount">
      <MemberSignature Language="C#" Value="public static UInt128 LeadingZeroCount (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 LeadingZeroCount(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.LeadingZeroCount(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeadingZeroCount (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : UInt128 -&gt; UInt128" Usage="System.UInt128.LeadingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 LeadingZeroCount(UInt128 value) = System::Numerics::IBinaryInteger&lt;UInt128&gt;::LeadingZeroCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.LeadingZeroCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value whose leading zeroes are to be counted.</param>
        <summary>Computes the number of leading zeros in a value.</summary>
        <returns>The number of leading zeros in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.LeadingZeroCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static UInt128 Log2 (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Log2(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Log2(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member Log2 : UInt128 -&gt; UInt128" Usage="System.UInt128.Log2 value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 Log2(UInt128 value) = System::Numerics::IBinaryNumber&lt;UInt128&gt;::Log2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.Log2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value whose log2 is to be computed.</param>
        <summary>Computes the log2 of a value.</summary>
        <returns>The log2 of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryNumber`1.Log2(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static UInt128 Max (UInt128 x, UInt128 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Max(valuetype System.UInt128 x, valuetype System.UInt128 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Max(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As UInt128, y As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member Max : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.Max (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 Max(UInt128 x, UInt128 y) = System::Numerics::INumber&lt;UInt128&gt;::Max;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Max(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UInt128" />
        <Parameter Name="y" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `maximum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Max(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public static UInt128 MaxValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.UInt128 MaxValue" />
      <MemberSignature Language="DocId" Value="P:System.UInt128.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxValue As UInt128" />
      <MemberSignature Language="F#" Value="static member MaxValue : UInt128" Usage="MaxValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property UInt128 MaxValue { UInt128 get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMinMaxValue`1.MaxValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum value of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.IMinMaxValue`1.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static UInt128 Min (UInt128 x, UInt128 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Min(valuetype System.UInt128 x, valuetype System.UInt128 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Min(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As UInt128, y As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member Min : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.Min (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 Min(UInt128 x, UInt128 y) = System::Numerics::INumber&lt;UInt128&gt;::Min;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Min(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UInt128" />
        <Parameter Name="y" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `minimum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Min(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public static UInt128 MinValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.UInt128 MinValue" />
      <MemberSignature Language="DocId" Value="P:System.UInt128.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinValue As UInt128" />
      <MemberSignature Language="F#" Value="static member MinValue : UInt128" Usage="MinValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property UInt128 MinValue { UInt128 get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMinMaxValue`1.MinValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the minimum value of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.IMinMaxValue`1.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static UInt128 One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.UInt128 One" />
      <MemberSignature Language="DocId" Value="P:System.UInt128.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As UInt128" />
      <MemberSignature Language="F#" Value="static member One : UInt128" Usage="One" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property UInt128 One { UInt128 get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.One</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>1</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.INumberBase`1.One" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static UInt128 operator + (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Addition(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Addition(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( + ) : UInt128 * UInt128 -&gt; UInt128" Usage="left + right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator +(UInt128 left, UInt128 right) = System::Numerics::IAdditionOperators&lt;UInt128, UInt128, UInt128&gt;::op_Addition;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IAdditionOperators`3.op_Addition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Adds two values together to compute their sum.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IAdditionOperators`3.op_Addition(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static UInt128 operator &amp; (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_BitwiseAnd(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_BitwiseAnd(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : UInt128 * UInt128 -&gt; UInt128" Usage="left &amp;&amp;&amp; right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator &amp;(UInt128 left, UInt128 right) = System::Numerics::IBitwiseOperators&lt;UInt128, UInt128, UInt128&gt;::op_BitwiseAnd;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_BitwiseAnd(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Computes the bitwise-and of two values.</summary>
        <returns>The bitwise-and of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBitwiseOperators`3.op_BitwiseAnd(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static UInt128 operator | (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_BitwiseOr(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_BitwiseOr(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : UInt128 * UInt128 -&gt; UInt128" Usage="left ||| right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator |(UInt128 left, UInt128 right) = System::Numerics::IBitwiseOperators&lt;UInt128, UInt128, UInt128&gt;::op_BitwiseOr;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_BitwiseOr(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Computes the bitwise-or of two values.</summary>
        <returns>The bitwise-or of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBitwiseOperators`3.op_BitwiseOr(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_CheckedAddition">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedAddition (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedAddition(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedAddition(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedAddition (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedAddition : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.op_CheckedAddition (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedAddition(UInt128 left, UInt128 right) = System::Numerics::IAdditionOperators&lt;UInt128, UInt128, UInt128&gt;::op_CheckedAddition;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IAdditionOperators`3.op_CheckedAddition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Adds two values together to compute their sum.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IAdditionOperators`3.op_Addition(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_CheckedDecrement">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedDecrement (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedDecrement(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedDecrement(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedDecrement (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedDecrement : UInt128 -&gt; UInt128" Usage="System.UInt128.op_CheckedDecrement value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedDecrement(UInt128 value) = System::Numerics::IDecrementOperators&lt;UInt128&gt;::op_CheckedDecrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_CheckedDecrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IDecrementOperators`1.op_Decrement(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_CheckedDivision">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedDivision (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedDivision(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedDivision(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedDivision (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedDivision : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.op_CheckedDivision (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedDivision(UInt128 left, UInt128 right) = System::Numerics::IDivisionOperators&lt;UInt128, UInt128, UInt128&gt;::op_CheckedDivision;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDivisionOperators`3.op_CheckedDivision(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Divides two values together to compute their quotient.</summary>
        <returns>The quotient of <paramref name="left" /> divided-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IDivisionOperators`3.op_CheckedDivision(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_CheckedExplicit">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedExplicit (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedExplicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedExplicit(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedExplicit (value As Double) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedExplicit : double -&gt; UInt128" Usage="System.UInt128.op_CheckedExplicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedExplicit(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_CheckedExplicit">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedExplicit (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedExplicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedExplicit(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedExplicit (value As Short) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedExplicit : int16 -&gt; UInt128" Usage="System.UInt128.op_CheckedExplicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedExplicit(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_CheckedExplicit">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedExplicit (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedExplicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedExplicit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedExplicit (value As Integer) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedExplicit : int -&gt; UInt128" Usage="System.UInt128.op_CheckedExplicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedExplicit(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_CheckedExplicit">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedExplicit (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedExplicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedExplicit(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedExplicit (value As Long) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedExplicit : int64 -&gt; UInt128" Usage="System.UInt128.op_CheckedExplicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedExplicit(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_CheckedExplicit">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedExplicit (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedExplicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedExplicit(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedExplicit (value As IntPtr) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedExplicit : nativeint -&gt; UInt128" Usage="System.UInt128.op_CheckedExplicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedExplicit(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_CheckedExplicit">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedExplicit (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedExplicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedExplicit(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedExplicit (value As SByte) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedExplicit : sbyte -&gt; UInt128" Usage="System.UInt128.op_CheckedExplicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedExplicit(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_CheckedExplicit">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedExplicit (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedExplicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedExplicit(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedExplicit (value As Single) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedExplicit : single -&gt; UInt128" Usage="System.UInt128.op_CheckedExplicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedExplicit(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_CheckedExplicit">
      <MemberSignature Language="C#" Value="public static byte op_CheckedExplicit (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_CheckedExplicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedExplicit(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedExplicit (value As UInt128) As Byte" />
      <MemberSignature Language="F#" Value="static member op_CheckedExplicit : UInt128 -&gt; byte" Usage="System.UInt128.op_CheckedExplicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte op_CheckedExplicit(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_CheckedIncrement">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedIncrement (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedIncrement(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedIncrement(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedIncrement (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedIncrement : UInt128 -&gt; UInt128" Usage="System.UInt128.op_CheckedIncrement value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedIncrement(UInt128 value) = System::Numerics::IIncrementOperators&lt;UInt128&gt;::op_CheckedIncrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_CheckedIncrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IIncrementOperators`1.op_CheckedIncrement(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_CheckedMultiply">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedMultiply (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedMultiply(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedMultiply(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedMultiply (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedMultiply : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.op_CheckedMultiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedMultiply(UInt128 left, UInt128 right) = System::Numerics::IMultiplyOperators&lt;UInt128, UInt128, UInt128&gt;::op_CheckedMultiply;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IMultiplyOperators`3.op_CheckedMultiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Multiplies two values together to compute their product.</summary>
        <returns>The product of <paramref name="left" /> multiplied-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IMultiplyOperators`3.op_CheckedMultiply(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_CheckedSubtraction">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedSubtraction (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedSubtraction(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedSubtraction(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedSubtraction (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedSubtraction : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.op_CheckedSubtraction (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedSubtraction(UInt128 left, UInt128 right) = System::Numerics::ISubtractionOperators&lt;UInt128, UInt128, UInt128&gt;::op_CheckedSubtraction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ISubtractionOperators`3.op_CheckedSubtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Subtracts two values to compute their difference.</summary>
        <returns>The difference of <paramref name="right" /> subtracted from <paramref name="left" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.ISubtractionOperators`3.op_CheckedSubtraction(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_CheckedUnaryNegation">
      <MemberSignature Language="C#" Value="public static UInt128 op_CheckedUnaryNegation (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_CheckedUnaryNegation(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_CheckedUnaryNegation(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_CheckedUnaryNegation (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_CheckedUnaryNegation : UInt128 -&gt; UInt128" Usage="System.UInt128.op_CheckedUnaryNegation value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_CheckedUnaryNegation(UInt128 value) = System::Numerics::IUnaryNegationOperators&lt;UInt128, UInt128&gt;::op_CheckedUnaryNegation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryNegationOperators`2.op_CheckedUnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Computes the unary negation of a value.</summary>
        <returns>The unary negation of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IUnaryNegationOperators`2.op_CheckedUnaryNegation(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static UInt128 operator -- (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Decrement(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Decrement(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Decrement : UInt128 -&gt; UInt128" Usage="System.UInt128.op_Decrement value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator --(UInt128 value) = System::Numerics::IDecrementOperators&lt;UInt128&gt;::op_Decrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_Decrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IDecrementOperators`1.op_Decrement(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static UInt128 operator / (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Division(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Division(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( / ) : UInt128 * UInt128 -&gt; UInt128" Usage="left / right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator /(UInt128 left, UInt128 right) = System::Numerics::IDivisionOperators&lt;UInt128, UInt128, UInt128&gt;::op_Division;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDivisionOperators`3.op_Division(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Divides two values together to compute their quotient.</summary>
        <returns>The quotient of <paramref name="left" /> divided-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IDivisionOperators`3.op_Division(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Equality(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As UInt128, right As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( = ) : UInt128 * UInt128 -&gt; bool" Usage="left = right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(UInt128 left, UInt128 right) = System::Numerics::IEqualityOperators&lt;UInt128, UInt128, bool&gt;::op_Equality;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Compares two values to determine equality.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static UInt128 operator ^ (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_ExclusiveOr(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_ExclusiveOr(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : UInt128 * UInt128 -&gt; UInt128" Usage="left ^^^ right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator ^(UInt128 left, UInt128 right) = System::Numerics::IBitwiseOperators&lt;UInt128, UInt128, UInt128&gt;::op_ExclusiveOr;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_ExclusiveOr(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Computes the exclusive-or of two values.</summary>
        <returns>The exclusive-or of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBitwiseOperators`3.op_ExclusiveOr(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UInt128 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.Decimal)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; UInt128" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UInt128(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Decimal" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UInt128 (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.Double)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; UInt128" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UInt128(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Double" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UInt128 (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Explicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.Int16)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Short) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int16 -&gt; UInt128" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UInt128(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Int16" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UInt128 (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.Int32)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int -&gt; UInt128" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UInt128(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Int32" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UInt128 (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Explicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.Int64)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Long) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int64 -&gt; UInt128" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UInt128(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Int64" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UInt128 (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.IntPtr)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeint -&gt; UInt128" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UInt128(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.IntPtr" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UInt128 (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Explicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.SByte)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As SByte) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Explicit : sbyte -&gt; UInt128" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UInt128(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.SByte" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UInt128 (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.Single)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; UInt128" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UInt128(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Single" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As Byte" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; byte" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.Byte" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.Byte" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator char (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname char op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.Char" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As Char" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; char" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator char(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.Char" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.Char" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As Decimal" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; decimal" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.Decimal" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.Decimal" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As Double" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; double" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.Double" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.Double" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Half (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Half op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.Half" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As Half" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; Half" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Half(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Half</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.Half" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.Half" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Int128 (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Int128 op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.Int128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As Int128" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; Int128" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Int128(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.Int128" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.Int128" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As Short" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; int16" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.Int16" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.Int16" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As Integer" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; int" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.Int32" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.Int32" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As Long" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; int64" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.Int64" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.Int64" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As IntPtr" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; nativeint" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.IntPtr" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.IntPtr" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As SByte" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; sbyte" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.SByte" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.SByte" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As Single" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; single" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.Single" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.Single" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As UShort" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; uint16" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.UInt16" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.UInt16" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As UInteger" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; uint32" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.UInt32" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.UInt32" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As ULong" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; uint64" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.UInt64" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.UInt64" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator UIntPtr (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native unsigned int op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Explicit(System.UInt128)~System.UIntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As UIntPtr" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; unativeint" Usage="System.UInt128.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator UIntPtr(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a 128-bit unsigned integer to a <see cref="T:System.UIntPtr" /> value.</summary>
        <returns>
          <paramref name="value" /> converted to a <see cref="T:System.UIntPtr" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_GreaterThan(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As UInt128, right As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : UInt128 * UInt128 -&gt; bool" Usage="left &gt; right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(UInt128 left, UInt128 right) = System::Numerics::IComparisonOperators&lt;UInt128, UInt128, bool&gt;::op_GreaterThan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Compares two values to determine which is greater.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_GreaterThanOrEqual(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As UInt128, right As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : UInt128 * UInt128 -&gt; bool" Usage="left &gt;= right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(UInt128 left, UInt128 right) = System::Numerics::IComparisonOperators&lt;UInt128, UInt128, bool&gt;::op_GreaterThanOrEqual;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Compares two values to determine which is greater or equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator UInt128 (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Implicit(System.Byte)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; UInt128" Usage="System.UInt128.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator UInt128(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.Byte" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator UInt128 (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Implicit(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Implicit(System.Char)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Char) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Implicit : char -&gt; UInt128" Usage="System.UInt128.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator UInt128(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.Char" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator UInt128 (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Implicit(System.UInt16)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; UInt128" Usage="System.UInt128.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator UInt128(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.UInt16" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator UInt128 (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Implicit(System.UInt32)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; UInt128" Usage="System.UInt128.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator UInt128(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.UInt32" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator UInt128 (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Implicit(System.UInt64)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; UInt128" Usage="System.UInt128.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator UInt128(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.UInt64" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator UInt128 (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Implicit(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Implicit(System.UIntPtr)~System.UInt128" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UIntPtr) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Implicit : unativeint -&gt; UInt128" Usage="System.UInt128.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator UInt128(UIntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.UIntPtr" /> value to a 128-bit unsigned integer.</summary>
        <returns>
          <paramref name="value" /> converted to a 128-bit unsigned integer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static UInt128 operator ++ (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Increment(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Increment(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_Increment : UInt128 -&gt; UInt128" Usage="System.UInt128.op_Increment value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator ++(UInt128 value) = System::Numerics::IIncrementOperators&lt;UInt128&gt;::op_Increment;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_Increment(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IIncrementOperators`1.op_Increment(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Inequality(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As UInt128, right As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member op_Inequality : UInt128 * UInt128 -&gt; bool" Usage="System.UInt128.op_Inequality (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(UInt128 left, UInt128 right) = System::Numerics::IEqualityOperators&lt;UInt128, UInt128, bool&gt;::op_Inequality;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Compares two values to determine inequality.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static UInt128 operator &lt;&lt; (UInt128 value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_LeftShift(valuetype System.UInt128 value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_LeftShift(System.UInt128,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As UInt128, shiftAmount As Integer) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : UInt128 * int -&gt; UInt128" Usage="value &lt;&lt;&lt; shiftAmount" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator &lt;&lt;(UInt128 value, int shiftAmount) = System::Numerics::IShiftOperators&lt;UInt128, int, UInt128&gt;::op_LeftShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_LeftShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
        <Parameter Name="shiftAmount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="shiftAmount">To be added.</param>
        <summary>Shifts a value left by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> left by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IShiftOperators`3.op_LeftShift(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_LessThan(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As UInt128, right As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : UInt128 * UInt128 -&gt; bool" Usage="left &lt; right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(UInt128 left, UInt128 right) = System::Numerics::IComparisonOperators&lt;UInt128, UInt128, bool&gt;::op_LessThan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Compares two values to determine which is less.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_LessThanOrEqual(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As UInt128, right As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : UInt128 * UInt128 -&gt; bool" Usage="left &lt;= right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(UInt128 left, UInt128 right) = System::Numerics::IComparisonOperators&lt;UInt128, UInt128, bool&gt;::op_LessThanOrEqual;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Compares two values to determine which is less or equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static UInt128 operator % (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Modulus(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Modulus(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( % ) : UInt128 * UInt128 -&gt; UInt128" Usage="left % right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator %(UInt128 left, UInt128 right) = System::Numerics::IModulusOperators&lt;UInt128, UInt128, UInt128&gt;::op_Modulus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IModulusOperators`3.op_Modulus(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Divides two values together to compute their modulus or remainder.</summary>
        <returns>The modulus or remainder of <paramref name="left" /> divided-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IModulusOperators`3.op_Modulus(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static UInt128 operator * (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Multiply(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Multiply(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( * ) : UInt128 * UInt128 -&gt; UInt128" Usage="left * right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator *(UInt128 left, UInt128 right) = System::Numerics::IMultiplyOperators&lt;UInt128, UInt128, UInt128&gt;::op_Multiply;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IMultiplyOperators`3.op_Multiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Multiplies two values together to compute their product.</summary>
        <returns>The product of <paramref name="left" /> multiplied-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IMultiplyOperators`3.op_Multiply(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static UInt128 operator ~ (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_OnesComplement(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_OnesComplement(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : UInt128 -&gt; UInt128" Usage="System.UInt128.op_OnesComplement value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator ~(UInt128 value) = System::Numerics::IBitwiseOperators&lt;UInt128, UInt128, UInt128&gt;::op_OnesComplement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_OnesComplement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Computes the ones-complement representation of a given value.</summary>
        <returns>The ones-complement of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBitwiseOperators`3.op_OnesComplement(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static UInt128 operator &gt;&gt; (UInt128 value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_RightShift(valuetype System.UInt128 value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_RightShift(System.UInt128,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As UInt128, shiftAmount As Integer) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : UInt128 * int -&gt; UInt128" Usage="value &gt;&gt;&gt; shiftAmount" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator &gt;&gt;(UInt128 value, int shiftAmount) = System::Numerics::IShiftOperators&lt;UInt128, int, UInt128&gt;::op_RightShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_RightShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
        <Parameter Name="shiftAmount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="shiftAmount">To be added.</param>
        <summary>Shifts a value right by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> right by <paramref name="shiftAmount" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This operation is meant to perform a signed (otherwise known as an arithmetic) right shift on signed types.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.IShiftOperators`3.op_RightShift(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static UInt128 operator - (UInt128 left, UInt128 right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_Subtraction(valuetype System.UInt128 left, valuetype System.UInt128 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_Subtraction(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As UInt128, right As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( - ) : UInt128 * UInt128 -&gt; UInt128" Usage="left - right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator -(UInt128 left, UInt128 right) = System::Numerics::ISubtractionOperators&lt;UInt128, UInt128, UInt128&gt;::op_Subtraction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ISubtractionOperators`3.op_Subtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt128" />
        <Parameter Name="right" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Subtracts two values to compute their difference.</summary>
        <returns>The difference of <paramref name="right" /> subtracted from <paramref name="left" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.ISubtractionOperators`3.op_Subtraction(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static UInt128 operator - (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_UnaryNegation(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_UnaryNegation(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : UInt128 -&gt; UInt128" Usage="- value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator -(UInt128 value) = System::Numerics::IUnaryNegationOperators&lt;UInt128, UInt128&gt;::op_UnaryNegation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryNegationOperators`2.op_UnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Computes the unary negation of a value.</summary>
        <returns>The unary negation of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IUnaryNegationOperators`2.op_UnaryNegation(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static UInt128 operator + (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_UnaryPlus(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_UnaryPlus(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : UInt128 -&gt; UInt128" Usage="+ value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 operator +(UInt128 value) = System::Numerics::IUnaryPlusOperators&lt;UInt128, UInt128&gt;::op_UnaryPlus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryPlusOperators`2.op_UnaryPlus(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Computes the unary plus of a value.</summary>
        <returns>The unary plus of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IUnaryPlusOperators`2.op_UnaryPlus(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnsignedRightShift">
      <MemberSignature Language="C#" Value="public static UInt128 op_UnsignedRightShift (UInt128 value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.UInt128 op_UnsignedRightShift(valuetype System.UInt128 value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.op_UnsignedRightShift(System.UInt128,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_UnsignedRightShift (value As UInt128, shiftAmount As Integer) As UInt128" />
      <MemberSignature Language="F#" Value="static member op_UnsignedRightShift : UInt128 * int -&gt; UInt128" Usage="System.UInt128.op_UnsignedRightShift (value, shiftAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 op_UnsignedRightShift(UInt128 value, int shiftAmount) = System::Numerics::IShiftOperators&lt;UInt128, int, UInt128&gt;::op_UnsignedRightShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_UnsignedRightShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
        <Parameter Name="shiftAmount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="shiftAmount">To be added.</param>
        <summary>Shifts a value right by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> right by <paramref name="shiftAmount" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This operation is meant to perform n unsigned (otherwise known as a logical) right shift on all types.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.IShiftOperators`3.op_UnsignedRightShift(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UInt128 Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As UInt128" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; UInt128" Usage="System.UInt128.Parse s" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to parse.</param>
        <summary>Parses a string into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UInt128 Parse (ReadOnlySpan&lt;byte&gt; utf8Text, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Parse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (utf8Text As ReadOnlySpan(Of Byte), provider As IFormatProvider) As UInt128" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;byte&gt; * IFormatProvider -&gt; UInt128" Usage="System.UInt128.Parse (utf8Text, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 Parse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, IFormatProvider ^ provider) = IUtf8SpanParsable&lt;UInt128&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IUtf8SpanParsable`1.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanParsable`1.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UInt128 Parse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), provider As IFormatProvider) As UInt128" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; UInt128" Usage="System.UInt128.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider) = ISpanParsable&lt;UInt128&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UInt128 Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As UInt128" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; UInt128" Usage="System.UInt128.Parse (s, style)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <summary>Parses a string into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UInt128 Parse (string s, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As UInt128" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; UInt128" Usage="System.UInt128.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 Parse(System::String ^ s, IFormatProvider ^ provider) = IParsable&lt;UInt128&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IParsable`1.Parse(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a string into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UInt128 Parse (ReadOnlySpan&lt;byte&gt; utf8Text, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Parse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (utf8Text As ReadOnlySpan(Of Byte), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = Nothing) As UInt128" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;byte&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; UInt128" Usage="System.UInt128.Parse (utf8Text, style, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UInt128 Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = Nothing) As UInt128" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; UInt128" Usage="System.UInt128.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static UInt128 Parse (string s, System.Globalization.NumberStyles style, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As UInt128" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; UInt128" Usage="System.UInt128.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider) = System::Numerics::INumberBase&lt;UInt128&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a string into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopCount">
      <MemberSignature Language="C#" Value="public static UInt128 PopCount (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 PopCount(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.PopCount(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PopCount (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member PopCount : UInt128 -&gt; UInt128" Usage="System.UInt128.PopCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 PopCount(UInt128 value) = System::Numerics::IBinaryInteger&lt;UInt128&gt;::PopCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.PopCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value whose set bits are to be counted.</param>
        <summary>Computes the number of bits that are set in a value.</summary>
        <returns>The number of set bits in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.PopCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="RotateLeft">
      <MemberSignature Language="C#" Value="public static UInt128 RotateLeft (UInt128 value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 RotateLeft(valuetype System.UInt128 value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.RotateLeft(System.UInt128,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RotateLeft (value As UInt128, rotateAmount As Integer) As UInt128" />
      <MemberSignature Language="F#" Value="static member RotateLeft : UInt128 * int -&gt; UInt128" Usage="System.UInt128.RotateLeft (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 RotateLeft(UInt128 value, int rotateAmount) = System::Numerics::IBinaryInteger&lt;UInt128&gt;::RotateLeft;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.RotateLeft(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
        <Parameter Name="rotateAmount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The value which is rotated left by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated left.</param>
        <summary>Rotates a value left by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> left by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.RotateLeft(`0,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RotateRight">
      <MemberSignature Language="C#" Value="public static UInt128 RotateRight (UInt128 value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 RotateRight(valuetype System.UInt128 value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.RotateRight(System.UInt128,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RotateRight (value As UInt128, rotateAmount As Integer) As UInt128" />
      <MemberSignature Language="F#" Value="static member RotateRight : UInt128 * int -&gt; UInt128" Usage="System.UInt128.RotateRight (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 RotateRight(UInt128 value, int rotateAmount) = System::Numerics::IBinaryInteger&lt;UInt128&gt;::RotateRight;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.RotateRight(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
        <Parameter Name="rotateAmount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The value which is rotated right by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated right.</param>
        <summary>Rotates a value right by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> right by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.RotateRight(`0,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.Sign(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As UInt128) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : UInt128 -&gt; int" Usage="System.UInt128.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(UInt128 value) = System::Numerics::INumber&lt;UInt128&gt;::Sign;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Sign(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value whose sign is to be computed.</param>
        <summary>Computes the sign of a value.</summary>
        <returns>A positive value if <paramref name="value" /> is positive, <see cref="P:System.Numerics.INumberBase`1.Zero" /> if <paramref name="value" /> is zero, and a negative value if <paramref name="value" /> is negative.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

It is recommended that a function return `1`, `0`, and `-1`, respectively.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Sign(`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditiveIdentity&lt;System.UInt128,System.UInt128&gt;.AdditiveIdentity">
      <MemberSignature Language="C#" Value="static UInt128 System.Numerics.IAdditiveIdentity&lt;System.UInt128,System.UInt128&gt;.AdditiveIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.UInt128 System.Numerics.IAdditiveIdentity&lt;System.UInt128,System.UInt128&gt;.AdditiveIdentity" />
      <MemberSignature Language="DocId" Value="P:System.UInt128.System#Numerics#IAdditiveIdentity&lt;System#UInt128,System#UInt128&gt;#AdditiveIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property AdditiveIdentity As UInt128 Implements IAdditiveIdentity(Of UInt128, UInt128).AdditiveIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IAdditiveIdentity&lt;System.UInt128,System.UInt128&gt;.AdditiveIdentity : UInt128" Usage="System.Numerics.IAdditiveIdentity&lt;System.UInt128,System.UInt128&gt;.AdditiveIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property UInt128 System::Numerics::IAdditiveIdentity&lt;System::UInt128,System::UInt128&gt;::AdditiveIdentity { UInt128 get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IAdditiveIdentity`2.AdditiveIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the additive identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetByteCount">
      <MemberSignature Language="C#" Value="int IBinaryInteger&lt;UInt128&gt;.GetByteCount ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetByteCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#IBinaryInteger&lt;System#UInt128&gt;#GetByteCount" />
      <MemberSignature Language="VB.NET" Value="Function GetByteCount () As Integer Implements IBinaryInteger(Of UInt128).GetByteCount" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetByteCount : unit -&gt; int&#xA;override this.System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetByteCount : unit -&gt; int" Usage="uInt128.System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetByteCount " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetByteCount() = System::Numerics::IBinaryInteger&lt;UInt128&gt;::GetByteCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.GetByteCount</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</summary>
        <returns>The number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.GetByteCount" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetShortestBitLength">
      <MemberSignature Language="C#" Value="int IBinaryInteger&lt;UInt128&gt;.GetShortestBitLength ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetShortestBitLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#IBinaryInteger&lt;System#UInt128&gt;#GetShortestBitLength" />
      <MemberSignature Language="VB.NET" Value="Function GetShortestBitLength () As Integer Implements IBinaryInteger(Of UInt128).GetShortestBitLength" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetShortestBitLength : unit -&gt; int&#xA;override this.System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetShortestBitLength : unit -&gt; int" Usage="uInt128.System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetShortestBitLength " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.GetShortestBitLength() = System::Numerics::IBinaryInteger&lt;UInt128&gt;::GetShortestBitLength;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.GetShortestBitLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the length, in bits, of the shortest two's complement representation of the current value.</summary>
        <returns>The length, in bits, of the shortest two's complement representation of the current value.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.GetShortestBitLength" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryReadBigEndian">
      <MemberSignature Language="C#" Value="static bool IBinaryInteger&lt;UInt128&gt;.TryReadBigEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryReadBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] valuetype System.UInt128&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#IBinaryInteger&lt;System#UInt128&gt;#TryReadBigEndian(System.ReadOnlySpan{System.Byte},System.Boolean,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryReadBigEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As UInt128) As Boolean Implements IBinaryInteger(Of UInt128).TryReadBigEndian" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryReadBigEndian : ReadOnlySpan&lt;byte&gt; * bool * UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryReadBigEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryReadBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] UInt128 % value) = System::Numerics::IBinaryInteger&lt;UInt128&gt;::TryReadBigEndian;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="value" Type="System.UInt128" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryReadLittleEndian">
      <MemberSignature Language="C#" Value="static bool IBinaryInteger&lt;UInt128&gt;.TryReadLittleEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryReadLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] valuetype System.UInt128&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#IBinaryInteger&lt;System#UInt128&gt;#TryReadLittleEndian(System.ReadOnlySpan{System.Byte},System.Boolean,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryReadLittleEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As UInt128) As Boolean Implements IBinaryInteger(Of UInt128).TryReadLittleEndian" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryReadLittleEndian : ReadOnlySpan&lt;byte&gt; * bool * UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryReadLittleEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryReadLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] UInt128 % value) = System::Numerics::IBinaryInteger&lt;UInt128&gt;::TryReadLittleEndian;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="value" Type="System.UInt128" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteBigEndian">
      <MemberSignature Language="C#" Value="bool IBinaryInteger&lt;UInt128&gt;.TryWriteBigEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#IBinaryInteger&lt;System#UInt128&gt;#TryWriteBigEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteBigEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IBinaryInteger(Of UInt128).TryWriteBigEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteBigEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteBigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="uInt128.System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteBigEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteBigEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IBinaryInteger&lt;UInt128&gt;::TryWriteBigEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TryWriteBigEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in big-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TryWriteBigEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteLittleEndian">
      <MemberSignature Language="C#" Value="bool IBinaryInteger&lt;UInt128&gt;.TryWriteLittleEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#IBinaryInteger&lt;System#UInt128&gt;#TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteLittleEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IBinaryInteger(Of UInt128).TryWriteLittleEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteLittleEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteLittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="uInt128.System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteLittleEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IBinaryInteger&lt;System.UInt128&gt;.TryWriteLittleEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IBinaryInteger&lt;UInt128&gt;::TryWriteLittleEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in little-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryNumber&lt;System.UInt128&gt;.AllBitsSet">
      <MemberSignature Language="C#" Value="static UInt128 System.Numerics.IBinaryNumber&lt;System.UInt128&gt;.AllBitsSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.UInt128 System.Numerics.IBinaryNumber&lt;System.UInt128&gt;.AllBitsSet" />
      <MemberSignature Language="DocId" Value="P:System.UInt128.System#Numerics#IBinaryNumber&lt;System#UInt128&gt;#AllBitsSet" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property AllBitsSet As UInt128 Implements IBinaryNumber(Of UInt128).AllBitsSet" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryNumber&lt;System.UInt128&gt;.AllBitsSet : UInt128" Usage="System.Numerics.IBinaryNumber&lt;System.UInt128&gt;.AllBitsSet" />
      <MemberSignature Language="C++ CLI" Value="static property UInt128 System::Numerics::IBinaryNumber&lt;System::UInt128&gt;::AllBitsSet { UInt128 get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IBinaryNumber`1.AllBitsSet</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an instance of the binary type in which all bits are set.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplicativeIdentity&lt;System.UInt128,System.UInt128&gt;.MultiplicativeIdentity">
      <MemberSignature Language="C#" Value="static UInt128 System.Numerics.IMultiplicativeIdentity&lt;System.UInt128,System.UInt128&gt;.MultiplicativeIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.UInt128 System.Numerics.IMultiplicativeIdentity&lt;System.UInt128,System.UInt128&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="DocId" Value="P:System.UInt128.System#Numerics#IMultiplicativeIdentity&lt;System#UInt128,System#UInt128&gt;#MultiplicativeIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MultiplicativeIdentity As UInt128 Implements IMultiplicativeIdentity(Of UInt128, UInt128).MultiplicativeIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMultiplicativeIdentity&lt;System.UInt128,System.UInt128&gt;.MultiplicativeIdentity : UInt128" Usage="System.Numerics.IMultiplicativeIdentity&lt;System.UInt128,System.UInt128&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property UInt128 System::Numerics::IMultiplicativeIdentity&lt;System::UInt128,System::UInt128&gt;::MultiplicativeIdentity { UInt128 get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMultiplicativeIdentity`2.MultiplicativeIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the multiplicative identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumber&lt;System.UInt128&gt;.CopySign">
      <MemberSignature Language="C#" Value="static UInt128 INumber&lt;UInt128&gt;.CopySign (UInt128 value, UInt128 sign);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.UInt128 System.Numerics.INumber&lt;System.UInt128&gt;.CopySign(valuetype System.UInt128 value, valuetype System.UInt128 sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumber&lt;System#UInt128&gt;#CopySign(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function CopySign (value As UInt128, sign As UInt128) As UInt128 Implements INumber(Of UInt128).CopySign" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumber&lt;System.UInt128&gt;.CopySign : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.System.Numerics.INumber&lt;System.UInt128&gt;.CopySign (value, sign)" />
      <MemberSignature Language="C++ CLI" Value=" static UInt128 System.Numerics.INumber&lt;System.UInt128&gt;.CopySign(UInt128 value, UInt128 sign) = System::Numerics::INumber&lt;UInt128&gt;::CopySign;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.CopySign(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
        <Parameter Name="sign" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value whose magnitude is used in the result.</param>
        <param name="sign">The value whose sign is used in the result.</param>
        <summary>Copies the sign of a value to the sign of another value.</summary>
        <returns>A value with the magnitude of <paramref name="value" /> and the sign of <paramref name="sign" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumber&lt;System.UInt128&gt;.MaxNumber">
      <MemberSignature Language="C#" Value="static UInt128 INumber&lt;UInt128&gt;.MaxNumber (UInt128 x, UInt128 y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.UInt128 System.Numerics.INumber&lt;System.UInt128&gt;.MaxNumber(valuetype System.UInt128 x, valuetype System.UInt128 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumber&lt;System#UInt128&gt;#MaxNumber(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxNumber (x As UInt128, y As UInt128) As UInt128 Implements INumber(Of UInt128).MaxNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumber&lt;System.UInt128&gt;.MaxNumber : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.System.Numerics.INumber&lt;System.UInt128&gt;.MaxNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UInt128 System.Numerics.INumber&lt;System.UInt128&gt;.MaxNumber(UInt128 x, UInt128 y) = System::Numerics::INumber&lt;UInt128&gt;::MaxNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.MaxNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UInt128" />
        <Parameter Name="y" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumber&lt;System.UInt128&gt;.MinNumber">
      <MemberSignature Language="C#" Value="static UInt128 INumber&lt;UInt128&gt;.MinNumber (UInt128 x, UInt128 y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.UInt128 System.Numerics.INumber&lt;System.UInt128&gt;.MinNumber(valuetype System.UInt128 x, valuetype System.UInt128 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumber&lt;System#UInt128&gt;#MinNumber(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinNumber (x As UInt128, y As UInt128) As UInt128 Implements INumber(Of UInt128).MinNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumber&lt;System.UInt128&gt;.MinNumber : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.System.Numerics.INumber&lt;System.UInt128&gt;.MinNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UInt128 System.Numerics.INumber&lt;System.UInt128&gt;.MinNumber(UInt128 x, UInt128 y) = System::Numerics::INumber&lt;UInt128&gt;::MinNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.MinNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UInt128" />
        <Parameter Name="y" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.Abs">
      <MemberSignature Language="C#" Value="static UInt128 INumberBase&lt;UInt128&gt;.Abs (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.UInt128 System.Numerics.INumberBase&lt;System.UInt128&gt;.Abs(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#Abs(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Abs (value As UInt128) As UInt128 Implements INumberBase(Of UInt128).Abs" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.Abs : UInt128 -&gt; UInt128" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.Abs value" />
      <MemberSignature Language="C++ CLI" Value=" static UInt128 System.Numerics.INumberBase&lt;System.UInt128&gt;.Abs(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::Abs;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Abs(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to get its absolute.</param>
        <summary>Computes the absolute of a value.</summary>
        <returns>The absolute of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsCanonical">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsCanonical (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsCanonical(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsCanonical(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsCanonical (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsCanonical" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsCanonical : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsCanonical value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsCanonical(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsCanonical;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsCanonical(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is in its canonical representation.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is in its canonical representation; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsComplexNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsComplexNumber (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsComplexNumber(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsComplexNumber(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsComplexNumber (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsComplexNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsComplexNumber : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsComplexNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsComplexNumber(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsComplexNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsComplexNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a complex number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a complex number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsFinite">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsFinite (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsFinite(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsFinite(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsFinite (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsFinite" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsFinite : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsFinite value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsFinite(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsFinite;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsFinite(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is finite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is finite; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsImaginaryNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsImaginaryNumber (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsImaginaryNumber(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsImaginaryNumber(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsImaginaryNumber (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsImaginaryNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsImaginaryNumber : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsImaginaryNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsImaginaryNumber(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsImaginaryNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsImaginaryNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a pure imaginary number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a pure imaginary number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsInfinity (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsInfinity(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsInfinity(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsInfinity (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsInfinity : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsInfinity(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is infinite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is infinite; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsInteger">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsInteger (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsInteger(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsInteger(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsInteger (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsInteger" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsInteger : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsInteger value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsInteger(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an integer; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNaN">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsNaN (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNaN(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsNaN(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNaN (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsNaN" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNaN : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNaN value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNaN(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsNaN;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNaN(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is NaN.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is NaN; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNegative">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsNegative (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNegative(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsNegative(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNegative (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsNegative" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNegative : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNegative value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNegative(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsNegative;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegative(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNegativeInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsNegativeInfinity (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNegativeInfinity(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsNegativeInfinity(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNegativeInfinity (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsNegativeInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNegativeInfinity : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNegativeInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNegativeInfinity(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsNegativeInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegativeInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNormal">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsNormal (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNormal(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsNormal(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNormal (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsNormal" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNormal : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNormal value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsNormal(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsNormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is normal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is normal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsPositive">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsPositive (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsPositive(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsPositive(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsPositive (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsPositive" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsPositive : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsPositive value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsPositive(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsPositive;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositive(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsPositiveInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsPositiveInfinity (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsPositiveInfinity(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsPositiveInfinity(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsPositiveInfinity (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsPositiveInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsPositiveInfinity : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsPositiveInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsPositiveInfinity(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsPositiveInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositiveInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsRealNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsRealNumber (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsRealNumber(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsRealNumber(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsRealNumber (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsRealNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsRealNumber : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsRealNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsRealNumber(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsRealNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsRealNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a real number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a real number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsSubnormal">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsSubnormal (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsSubnormal(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsSubnormal(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsSubnormal (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsSubnormal" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsSubnormal : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsSubnormal value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsSubnormal(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsSubnormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsSubnormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is subnormal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is subnormal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.IsZero">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.IsZero (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsZero(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#IsZero(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsZero (value As UInt128) As Boolean Implements INumberBase(Of UInt128).IsZero" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.IsZero : UInt128 -&gt; bool" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.IsZero value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.IsZero(UInt128 value) = System::Numerics::INumberBase&lt;UInt128&gt;::IsZero;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsZero(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is zero.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is zero; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.MaxMagnitude">
      <MemberSignature Language="C#" Value="static UInt128 INumberBase&lt;UInt128&gt;.MaxMagnitude (UInt128 x, UInt128 y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.UInt128 System.Numerics.INumberBase&lt;System.UInt128&gt;.MaxMagnitude(valuetype System.UInt128 x, valuetype System.UInt128 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#MaxMagnitude(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxMagnitude (x As UInt128, y As UInt128) As UInt128 Implements INumberBase(Of UInt128).MaxMagnitude" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.MaxMagnitude : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UInt128 System.Numerics.INumberBase&lt;System.UInt128&gt;.MaxMagnitude(UInt128 x, UInt128 y) = System::Numerics::INumberBase&lt;UInt128&gt;::MaxMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UInt128" />
        <Parameter Name="y" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.MaxMagnitudeNumber">
      <MemberSignature Language="C#" Value="static UInt128 INumberBase&lt;UInt128&gt;.MaxMagnitudeNumber (UInt128 x, UInt128 y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.UInt128 System.Numerics.INumberBase&lt;System.UInt128&gt;.MaxMagnitudeNumber(valuetype System.UInt128 x, valuetype System.UInt128 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#MaxMagnitudeNumber(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxMagnitudeNumber (x As UInt128, y As UInt128) As UInt128 Implements INumberBase(Of UInt128).MaxMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.MaxMagnitudeNumber : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.MaxMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UInt128 System.Numerics.INumberBase&lt;System.UInt128&gt;.MaxMagnitudeNumber(UInt128 x, UInt128 y) = System::Numerics::INumberBase&lt;UInt128&gt;::MaxMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UInt128" />
        <Parameter Name="y" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the greater magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.MinMagnitude">
      <MemberSignature Language="C#" Value="static UInt128 INumberBase&lt;UInt128&gt;.MinMagnitude (UInt128 x, UInt128 y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.UInt128 System.Numerics.INumberBase&lt;System.UInt128&gt;.MinMagnitude(valuetype System.UInt128 x, valuetype System.UInt128 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#MinMagnitude(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinMagnitude (x As UInt128, y As UInt128) As UInt128 Implements INumberBase(Of UInt128).MinMagnitude" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.MinMagnitude : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UInt128 System.Numerics.INumberBase&lt;System.UInt128&gt;.MinMagnitude(UInt128 x, UInt128 y) = System::Numerics::INumberBase&lt;UInt128&gt;::MinMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UInt128" />
        <Parameter Name="y" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.MinMagnitudeNumber">
      <MemberSignature Language="C#" Value="static UInt128 INumberBase&lt;UInt128&gt;.MinMagnitudeNumber (UInt128 x, UInt128 y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.UInt128 System.Numerics.INumberBase&lt;System.UInt128&gt;.MinMagnitudeNumber(valuetype System.UInt128 x, valuetype System.UInt128 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#MinMagnitudeNumber(System.UInt128,System.UInt128)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinMagnitudeNumber (x As UInt128, y As UInt128) As UInt128 Implements INumberBase(Of UInt128).MinMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.MinMagnitudeNumber : UInt128 * UInt128 -&gt; UInt128" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.MinMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static UInt128 System.Numerics.INumberBase&lt;System.UInt128&gt;.MinMagnitudeNumber(UInt128 x, UInt128 y) = System::Numerics::INumberBase&lt;UInt128&gt;::MinMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.UInt128" />
        <Parameter Name="y" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the lesser magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.Radix">
      <MemberSignature Language="C#" Value="static int System.Numerics.INumberBase&lt;System.UInt128&gt;.Radix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 System.Numerics.INumberBase&lt;System.UInt128&gt;.Radix" />
      <MemberSignature Language="DocId" Value="P:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#Radix" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property Radix As Integer Implements INumberBase(Of UInt128).Radix" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.Radix : int" Usage="System.Numerics.INumberBase&lt;System.UInt128&gt;.Radix" />
      <MemberSignature Language="C++ CLI" Value="static property int System::Numerics::INumberBase&lt;System::UInt128&gt;::Radix { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Radix</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the radix, or base, for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.TryConvertToChecked&lt;TOther&gt; (UInt128 value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(valuetype System.UInt128 value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#TryConvertToChecked``1(System.UInt128,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToChecked(Of TOther As INumberBase(Of TOther)) (value As UInt128, ByRef result As TOther) As Boolean Implements INumberBase(Of UInt128).TryConvertToChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToChecked : UInt128 * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToChecked(UInt128 value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;UInt128&gt;::TryConvertToChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToChecked``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
        <Parameter Name="result" Type="TOther" RefType="out">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.TryConvertToSaturating&lt;TOther&gt; (UInt128 value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(valuetype System.UInt128 value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#TryConvertToSaturating``1(System.UInt128,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToSaturating(Of TOther As INumberBase(Of TOther)) (value As UInt128, ByRef result As TOther) As Boolean Implements INumberBase(Of UInt128).TryConvertToSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToSaturating : UInt128 * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToSaturating(UInt128 value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;UInt128&gt;::TryConvertToSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToSaturating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
        <Parameter Name="result" Type="TOther" RefType="out">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.TryConvertToTruncating&lt;TOther&gt; (UInt128 value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(valuetype System.UInt128 value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#TryConvertToTruncating``1(System.UInt128,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToTruncating(Of TOther As INumberBase(Of TOther)) (value As UInt128, ByRef result As TOther) As Boolean Implements INumberBase(Of UInt128).TryConvertToTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToTruncating : UInt128 * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertToTruncating(UInt128 value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;UInt128&gt;::TryConvertToTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToTruncating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
        <Parameter Name="result" Type="TOther" RefType="out">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.TryConvertFromChecked&lt;TOther&gt; (TOther value, out UInt128 result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#TryConvertFromChecked``1(``0,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromChecked(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As UInt128) As Boolean Implements INumberBase(Of UInt128).TryConvertFromChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromChecked : 'Other * UInt128 -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromChecked(TOther value, [Runtime::InteropServices::Out] UInt128 % result) = System::Numerics::INumberBase&lt;UInt128&gt;::TryConvertFromChecked;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
        <Parameter Name="result" Type="System.UInt128" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.TryConvertFromSaturating&lt;TOther&gt; (TOther value, out UInt128 result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#TryConvertFromSaturating``1(``0,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As UInt128) As Boolean Implements INumberBase(Of UInt128).TryConvertFromSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromSaturating : 'Other * UInt128 -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromSaturating(TOther value, [Runtime::InteropServices::Out] UInt128 % result) = System::Numerics::INumberBase&lt;UInt128&gt;::TryConvertFromSaturating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
        <Parameter Name="result" Type="System.UInt128" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;UInt128&gt;.TryConvertFromTruncating&lt;TOther&gt; (TOther value, out UInt128 result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.System#Numerics#INumberBase&lt;System#UInt128&gt;#TryConvertFromTruncating``1(``0,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As UInt128) As Boolean Implements INumberBase(Of UInt128).TryConvertFromTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromTruncating : 'Other * UInt128 -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.UInt128.System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.UInt128&gt;.TryConvertFromTruncating(TOther value, [Runtime::InteropServices::Out] UInt128 % result) = System::Numerics::INumberBase&lt;UInt128&gt;::TryConvertFromTruncating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
        <Parameter Name="result" Type="System.UInt128" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uInt128.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string that represents the current object.</summary>
        <returns>A string that represents the current object.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Object.ToString" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="uInt128.ToString provider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <summary>Converts the numeric value of this instance to its equivalent string representation using the specified culture-specific format information.</summary>
        <returns>The string representation of the value of this instance as specified by <paramref name="provider" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string? format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="uInt128.ToString format" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">The format to use, or a <see langword="null" /> reference to use the default format defined for the type of the <see cref="T:System.IFormattable" /> implementation.</param>
        <summary>Converts the numeric value of this instance to its equivalent string representation, using the specified format.</summary>
        <returns>The string representation of the value of this instance as specified by <paramref name="format" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string? format, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="uInt128.ToString (format, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">The format to use, or a <see langword="null" /> reference to use the default format defined for the type of the <see cref="T:System.IFormattable" /> implementation.</param>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <summary>Formats the value of the current instance using the specified format.</summary>
        <returns>The value of the current instance in the specified format.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount">
      <MemberSignature Language="C#" Value="public static UInt128 TrailingZeroCount (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UInt128 TrailingZeroCount(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TrailingZeroCount(System.UInt128)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrailingZeroCount (value As UInt128) As UInt128" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : UInt128 -&gt; UInt128" Usage="System.UInt128.TrailingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UInt128 TrailingZeroCount(UInt128 value) = System::Numerics::IBinaryInteger&lt;UInt128&gt;::TrailingZeroCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TrailingZeroCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" />
      </Parameters>
      <Docs>
        <param name="value">The value whose trailing zeroes are to be counted.</param>
        <summary>Computes the number of trailing zeros in a value.</summary>
        <returns>The number of trailing zeros in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TrailingZeroCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;byte&gt; utf8Destination, out int bytesWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFormat(valuetype System.Span`1&lt;unsigned int8&gt; utf8Destination, [out] int32&amp; bytesWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (utf8Destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="uInt128.TryFormat (utf8Destination, bytesWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.System#IUtf8SpanFormattable#TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
        <InterfaceMember FrameworkAlternate="net-9.0">M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="uInt128.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ISpanFormattable.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span in which to write this instance's value formatted as a span of characters.</param>
        <param name="charsWritten">When this method returns, contains the number of characters that were written in <paramref name="destination" />.</param>
        <param name="format">A span containing the characters that represent a standard or custom format string that defines the acceptable format for <paramref name="destination" />.</param>
        <param name="provider">An optional object that supplies culture-specific formatting information for <paramref name="destination" />.</param>
        <summary>Tries to format the value of the current instance into the provided span of characters.</summary>
        <returns>
          <see langword="true" /> if the formatting was successful; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, out UInt128 result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TryParse(System.ReadOnlySpan{System.Byte},System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), ByRef result As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * UInt128 -&gt; bool" Usage="System.UInt128.TryParse (utf8Text, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, [Runtime::InteropServices::Out] UInt128 % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.UInt128" RefType="out" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">A span containing the UTF-8 characters representing the number to convert.</param>
        <param name="result">When this method returns, contains the 128-bit unsigned integer value equivalent to the number contained in <paramref name="utf8Text" /> if the conversion succeeded, or zero if the conversion failed. This parameter is passed uninitialized; any value originally supplied in result will be overwritten.</param>
        <summary>Tries to convert a UTF-8 character span containing the string representation of a number to its 128-bit unsigned integer equivalent.</summary>
        <returns>
          <see langword="true" /> if <paramref name="utf8Text" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out UInt128 result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TryParse(System.ReadOnlySpan{System.Char},System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * UInt128 -&gt; bool" Usage="System.UInt128.TryParse (s, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] UInt128 % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.UInt128" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a span of characters into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, out UInt128 result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TryParse(System.String,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * UInt128 -&gt; bool" Usage="System.UInt128.TryParse (s, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] UInt128 % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.UInt128" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, IFormatProvider? provider, out UInt128 result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, class System.IFormatProvider provider, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), provider As IFormatProvider, ByRef result As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * IFormatProvider * UInt128 -&gt; bool" Usage="System.UInt128.TryParse (utf8Text, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UInt128 % result) = IUtf8SpanParsable&lt;UInt128&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.UInt128" RefType="out" Index="2" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanParsable`1.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out UInt128 result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), provider As IFormatProvider, ByRef result As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IFormatProvider * UInt128 -&gt; bool" Usage="System.UInt128.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UInt128 % result) = ISpanParsable&lt;UInt128&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.UInt128" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.ISpanParsable`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, IFormatProvider? provider, out UInt128 result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, class System.IFormatProvider provider, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TryParse(System.String,System.IFormatProvider,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, provider As IFormatProvider, ByRef result As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IFormatProvider * UInt128 -&gt; bool" Usage="System.UInt128.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UInt128 % result) = IParsable&lt;UInt128&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.UInt128" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, System.Globalization.NumberStyles style, IFormatProvider? provider, out UInt128 result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), style As NumberStyles, provider As IFormatProvider, ByRef result As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * System.Globalization.NumberStyles * IFormatProvider * UInt128 -&gt; bool" Usage="System.UInt128.TryParse (utf8Text, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UInt128 % result) = System::Numerics::INumberBase&lt;UInt128&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.UInt128" RefType="out" Index="3" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider, out UInt128 result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * UInt128 -&gt; bool" Usage="System.UInt128.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UInt128 % result) = System::Numerics::INumberBase&lt;UInt128&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.UInt128" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a span of characters into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, System.Globalization.NumberStyles style, IFormatProvider? provider, out UInt128 result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.UInt128&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UInt128.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.UInt128@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As UInt128) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * UInt128 -&gt; bool" Usage="System.UInt128.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] UInt128 % result) = System::Numerics::INumberBase&lt;UInt128&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.UInt128" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static UInt128 Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.UInt128 Zero" />
      <MemberSignature Language="DocId" Value="P:System.UInt128.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As UInt128" />
      <MemberSignature Language="F#" Value="static member Zero : UInt128" Usage="Zero" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property UInt128 Zero { UInt128 get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Zero</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt128</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>0</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.INumberBase`1.Zero" />
      </Docs>
    </Member>
  </Members>
</Type>
