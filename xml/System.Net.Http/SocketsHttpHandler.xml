<Type Name="SocketsHttpHandler" FullName="System.Net.Http.SocketsHttpHandler">
  <TypeSignature Language="C#" Value="public sealed class SocketsHttpHandler : System.Net.Http.HttpMessageHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SocketsHttpHandler extends System.Net.Http.HttpMessageHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.SocketsHttpHandler" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SocketsHttpHandler&#xA;Inherits HttpMessageHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class SocketsHttpHandler sealed : System::Net::Http::HttpMessageHandler" />
  <TypeSignature Language="F#" Value="type SocketsHttpHandler = class&#xA;    inherit HttpMessageHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpMessageHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0">
      <AttributeName Language="C#">[System.Runtime.Versioning.UnsupportedOSPlatform("browser")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.Versioning.UnsupportedOSPlatform("browser")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides the default message handler used by <see cref="T:System.Net.Http.HttpClient" /> in .NET Core 2.1 and later.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

Starting with .NET Core 2.1, the `SocketsHttpHandler` class provides the implementation used by higher-level HTTP networking classes such as <xref:System.Net.Http.HttpClient>. The use of `SocketsHttpHandler` offers a number of advantages:

- A significant performance improvement when compared with the previous implementation.

- The elimination of platform dependencies, which simplifies deployment and servicing. For example, `libcurl` is no longer a dependency on .NET Core for macOS and .NET Core for Linux.

- Consistent behavior across all .NET platforms.

If this change is undesirable and you are on .NET Core 2.1-3.1, you can configure your application to use the older <xref:System.Net.Http.HttpClientHandler?displayProperty=nameWithType> class instead in a number of ways:

- By calling the <xref:System.AppContext.SetSwitch%2A?displayProperty=nameWithType> method as follows:

   ```csharp
   AppContext.SetSwitch("System.Net.Http.UseSocketsHttpHandler", false);
   ```

   ```vb
   AppContext.SetSwitch("System.Net.Http.UseSocketsHttpHandler", False)
   ```
- By defining the `System.Net.Http.UseSocketsHttpHandler` switch in the *.netcore.runtimeconfig.json* configuration file:

  ```json
  "runtimeOptions": {
    "configProperties": {
        "System.Net.Http.UseSocketsHttpHandler": false
    }
  }
  ```

- By defining an environment variable named `DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER` and setting it to either `false` or 0.

These configuration options are not available starting with .NET 5.

         ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SocketsHttpHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.SocketsHttpHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SocketsHttpHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Creates an instance of a <see cref="T:System.Net.Http.SocketsHttpHandler" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.Http.SocketsHttpHandler.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the handler should follow redirection responses.</summary>
        <value>
          <see langword="true" /> if the handler should follow redirection responses; otherwise <see langword="false" />. The default value is <see langword="true" />.
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Set <xref:System.Net.Http.SocketsHttpHandler.AllowAutoRedirect%2A> to `true` if you want the handler to automatically follow HTTP redirection headers to the new location of the resource. The maximum number of redirections to follow is set by the <xref:System.Net.Http.SocketsHttpHandler.MaxAutomaticRedirections%2A> property.

 If <xref:System.Net.Http.SocketsHttpHandler.AllowAutoRedirect%2A> is set to `false`, all HTTP responses with an HTTP status code from 300 to 399 are returned to the application.

 The Authorization header is cleared on auto-redirects and the handler automatically tries to re-authenticate to the redirected location. In practice, this means that an application can't put custom authentication information into the Authorization header if it is possible to encounter redirection. Instead, the application must implement and register a custom authentication module.

> [!NOTE]
>  The handler never follows a redirection from HTTPS to HTTP even if <xref:System.Net.Http.SocketsHttpHandler.AllowAutoRedirect%2A> is set to `true`.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.Http.SocketsHttpHandler.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of decompression method used by the handler for automatic decompression of the HTTP content response.</summary>
        <value>The type of decompression method used by the handler for automatic decompression of the HTTP content response.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectCallback">
      <MemberSignature Language="C#" Value="public Func&lt;System.Net.Http.SocketsHttpConnectionContext,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask&lt;System.IO.Stream&gt;&gt;? ConnectCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`3&lt;class System.Net.Http.SocketsHttpConnectionContext, valuetype System.Threading.CancellationToken, valuetype System.Threading.Tasks.ValueTask`1&lt;class System.IO.Stream&gt;&gt; ConnectCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.ConnectCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectCallback As Func(Of SocketsHttpConnectionContext, CancellationToken, ValueTask(Of Stream))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Net::Http::SocketsHttpConnectionContext ^, System::Threading::CancellationToken, System::Threading::Tasks::ValueTask&lt;System::IO::Stream ^&gt;&gt; ^ ConnectCallback { Func&lt;System::Net::Http::SocketsHttpConnectionContext ^, System::Threading::CancellationToken, System::Threading::Tasks::ValueTask&lt;System::IO::Stream ^&gt;&gt; ^ get(); void set(Func&lt;System::Net::Http::SocketsHttpConnectionContext ^, System::Threading::CancellationToken, System::Threading::Tasks::ValueTask&lt;System::IO::Stream ^&gt;&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectCallback : Func&lt;System.Net.Http.SocketsHttpConnectionContext, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask&lt;System.IO.Stream&gt;&gt; with get, set" Usage="System.Net.Http.SocketsHttpHandler.ConnectCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Net.Http.SocketsHttpConnectionContext,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask&lt;System.IO.Stream&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a custom callback used to open new connections.</summary>
        <value>A callback method to create a stream.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan ConnectTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ConnectTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.ConnectTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ConnectTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectTimeout : TimeSpan with get, set" Usage="System.Net.Http.SocketsHttpHandler.ConnectTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the timespan to wait before the connection establishing times out.</summary>
        <value>The timespan to wait before the connection establishing times out. The default value is <see cref="F:System.Threading.Timeout.InfiniteTimeSpan" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public System.Net.CookieContainer? CookieContainer { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.Http.SocketsHttpHandler.CookieContainer" />
      <MemberSignature Language="C#" Value="public System.Net.CookieContainer CookieContainer { get; set; }" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the managed cookie container object. </summary>
        <value>The managed cookie container object.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.Http.SocketsHttpHandler.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets authentication information used by this handler.</summary>
        <value>The authentication credentials associated with the handler. The default value is <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultProxyCredentials">
      <MemberSignature Language="C#" Value="public System.Net.ICredentials DefaultProxyCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials DefaultProxyCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.DefaultProxyCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultProxyCredentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ICredentials ^ DefaultProxyCredentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultProxyCredentials : System.Net.ICredentials with get, set" Usage="System.Net.Http.SocketsHttpHandler.DefaultProxyCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When the default (system) proxy is used, gets or sets the credentials used to submit to the default proxy server for authentication.</summary>
        <value>The credentials used to authenticate the user to an authenticating proxy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

The default proxy is used only when <xref:System.Net.Http.SocketsHttpHandler.UseProxy> is set to `true` and <xref:System.Net.Http.SocketsHttpHandler.Proxy> is set to `null`.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.SocketsHttpHandler.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="socketsHttpHandler.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableMultipleHttp2Connections">
      <MemberSignature Language="C#" Value="public bool EnableMultipleHttp2Connections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableMultipleHttp2Connections" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.EnableMultipleHttp2Connections" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableMultipleHttp2Connections As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableMultipleHttp2Connections { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableMultipleHttp2Connections : bool with get, set" Usage="System.Net.Http.SocketsHttpHandler.EnableMultipleHttp2Connections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether additional HTTP/2 connections can be established to the same server when the maximum number of concurrent streams is reached on all existing connections.</summary>
        <value>
          <see langword="true" /> if additional HTTP/2 connections are allowed to be created; otherwise, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Expect100ContinueTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan Expect100ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan Expect100ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.Expect100ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect100ContinueTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan Expect100ContinueTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.Expect100ContinueTimeout : TimeSpan with get, set" Usage="System.Net.Http.SocketsHttpHandler.Expect100ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the time-out value for server HTTP 100 Continue response.</summary>
        <value>The timespan to wait for the HTTP 100 Continue. The default value is 1 second.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 When request contain `Expect: 100-continue` header the server should respond HTTP status `100 Continue` before the client sends the body. <xref:System.Net.Http.SocketsHttpHandler.Expect100ContinueTimeout%2A?displayProperty=nameWithType> define the timeout for the `100 Continue` server response.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSupported : bool" Usage="System.Net.Http.SocketsHttpHandler.IsSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the handler is supported on the current platform.</summary>
        <value>
          <see langword="true" /> if the handler is supported; otherwise, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlivePingDelay">
      <MemberSignature Language="C#" Value="public TimeSpan KeepAlivePingDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan KeepAlivePingDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.KeepAlivePingDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlivePingDelay As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan KeepAlivePingDelay { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlivePingDelay : TimeSpan with get, set" Usage="System.Net.Http.SocketsHttpHandler.KeepAlivePingDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the keep alive ping delay.</summary>
        <value>The keep alive ping delay. Defaults to <see cref="F:System.Threading.Timeout.InfiniteTimeSpan" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The client will send a keep alive ping to the server if it doesn't receive any frames on a connection for this period of time. This property is used together with <xref:"P:System.Net.Http.SocketsHttpHandler.KeepAlivePingTimeout%2A" /> to check whether the connection is broken.

Delay value must be greater than or equal to 1 second. Set to <xref:System.Threading.Timeout.InfiniteTimeSpan> to disable the keep alive ping.

  ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlivePingPolicy">
      <MemberSignature Language="C#" Value="public System.Net.Http.HttpKeepAlivePingPolicy KeepAlivePingPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Http.HttpKeepAlivePingPolicy KeepAlivePingPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.KeepAlivePingPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlivePingPolicy As HttpKeepAlivePingPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Http::HttpKeepAlivePingPolicy KeepAlivePingPolicy { System::Net::Http::HttpKeepAlivePingPolicy get(); void set(System::Net::Http::HttpKeepAlivePingPolicy value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlivePingPolicy : System.Net.Http.HttpKeepAlivePingPolicy with get, set" Usage="System.Net.Http.SocketsHttpHandler.KeepAlivePingPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Http.HttpKeepAlivePingPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the keep alive ping behaviour.</summary>
        <value>The keep alive ping behaviour.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Keep alive pings are sent when a period of inactivity exceeds the configured <xref:System.Net.Http.SocketsHttpHandler.KeepAlivePingDelay> value.

  ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlivePingTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan KeepAlivePingTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan KeepAlivePingTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.KeepAlivePingTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlivePingTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan KeepAlivePingTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlivePingTimeout : TimeSpan with get, set" Usage="System.Net.Http.SocketsHttpHandler.KeepAlivePingTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the keep alive ping timeout.</summary>
        <value>The keep alive ping timeout. Defaults to 20 seconds.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Keep alive pings are sent when a period of inactivity exceeds the configured <xref:System.Net.Http.SocketsHttpHandler.KeepAlivePingDelay> value. The client will close the connection if it doesn't receive any frames within the timeout.

Timeout must be greater than or equal to 1 second. Set to <xref:System.Threading.Timeout.InfiniteTimeSpan> to disable the keep alive ping timeout.

  ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaxAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.MaxAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxAutomaticRedirections : int with get, set" Usage="System.Net.Http.SocketsHttpHandler.MaxAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of allowed HTTP redirects.</summary>
        <value>The maximum number of allowed HTTP redirects.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxConnectionsPerServer">
      <MemberSignature Language="C#" Value="public int MaxConnectionsPerServer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxConnectionsPerServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.MaxConnectionsPerServer" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxConnectionsPerServer As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxConnectionsPerServer { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxConnectionsPerServer : int with get, set" Usage="System.Net.Http.SocketsHttpHandler.MaxConnectionsPerServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of simultaneous TCP connections allowed to a single server.</summary>
        <value>The maximum number of simultaneous TCP connections allowed to a single server.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseDrainSize">
      <MemberSignature Language="C#" Value="public int MaxResponseDrainSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseDrainSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.MaxResponseDrainSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseDrainSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxResponseDrainSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxResponseDrainSize : int with get, set" Usage="System.Net.Http.SocketsHttpHandler.MaxResponseDrainSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum amount of data that can be drained from responses in bytes.</summary>
        <value>The maximum amount of data that can be drained from responses in bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Draining occurs when a request is cancelled or a response is disposed prior to fully reading the content. If the number of bytes drained exceeds this amount, the connection will be closed rather than reused.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaxResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.MaxResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxResponseHeadersLength : int with get, set" Usage="System.Net.Http.SocketsHttpHandler.MaxResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum length, in kilobytes (1024 bytes), of the response headers.</summary>
        <value>The maximum size of the header portion from the server response, in kilobytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

For example, if the value is 64, then 65,536 bytes are allowed for the maximum response headers' length.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PlaintextStreamFilter">
      <MemberSignature Language="C#" Value="public Func&lt;System.Net.Http.SocketsHttpPlaintextStreamFilterContext,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask&lt;System.IO.Stream&gt;&gt;? PlaintextStreamFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`3&lt;class System.Net.Http.SocketsHttpPlaintextStreamFilterContext, valuetype System.Threading.CancellationToken, valuetype System.Threading.Tasks.ValueTask`1&lt;class System.IO.Stream&gt;&gt; PlaintextStreamFilter" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.PlaintextStreamFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property PlaintextStreamFilter As Func(Of SocketsHttpPlaintextStreamFilterContext, CancellationToken, ValueTask(Of Stream))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Net::Http::SocketsHttpPlaintextStreamFilterContext ^, System::Threading::CancellationToken, System::Threading::Tasks::ValueTask&lt;System::IO::Stream ^&gt;&gt; ^ PlaintextStreamFilter { Func&lt;System::Net::Http::SocketsHttpPlaintextStreamFilterContext ^, System::Threading::CancellationToken, System::Threading::Tasks::ValueTask&lt;System::IO::Stream ^&gt;&gt; ^ get(); void set(Func&lt;System::Net::Http::SocketsHttpPlaintextStreamFilterContext ^, System::Threading::CancellationToken, System::Threading::Tasks::ValueTask&lt;System::IO::Stream ^&gt;&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PlaintextStreamFilter : Func&lt;System.Net.Http.SocketsHttpPlaintextStreamFilterContext, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask&lt;System.IO.Stream&gt;&gt; with get, set" Usage="System.Net.Http.SocketsHttpHandler.PlaintextStreamFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Net.Http.SocketsHttpPlaintextStreamFilterContext,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask&lt;System.IO.Stream&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PooledConnectionIdleTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan PooledConnectionIdleTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PooledConnectionIdleTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.PooledConnectionIdleTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property PooledConnectionIdleTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PooledConnectionIdleTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.PooledConnectionIdleTimeout : TimeSpan with get, set" Usage="System.Net.Http.SocketsHttpHandler.PooledConnectionIdleTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets how long a connection can be idle in the pool to be considered reusable.</summary>
        <value>The maximum idle time for a connection in the pool. The default value for this property is 2 minutes.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than <see cref="F:System.TimeSpan.Zero" /> or is equal to <see cref="F:System.Threading.Timeout.InfiniteTimeSpan" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PooledConnectionLifetime">
      <MemberSignature Language="C#" Value="public TimeSpan PooledConnectionLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PooledConnectionLifetime" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.PooledConnectionLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Property PooledConnectionLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PooledConnectionLifetime { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.PooledConnectionLifetime : TimeSpan with get, set" Usage="System.Net.Http.SocketsHttpHandler.PooledConnectionLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets how long a connection can be in the pool to be considered reusable.</summary>
        <value>The maximum time for a connection to be in the pool. The default value for this property is <see cref="F:System.Threading.Timeout.InfiniteTimeSpan" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This property defines maximal connection lifetime in the pool regardless of whether the connection is idle or active. The connection is reestablished periodically to reflect the DNS or other network changes.
 
 If the connection endpoint is not the Domain name but the IP address, the value can be <xref:System.Threading.Timeout.InfiniteTimeSpan>.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than <see cref="F:System.TimeSpan.Zero" /> or is equal to <see cref="F:System.Threading.Timeout.InfiniteTimeSpan" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.Http.SocketsHttpHandler.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the handler sends an Authorization header with the request.</summary>
        <value>
          <see langword="true" /> if the handler sends an Authorization header with the request; otherwise, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt;? Properties { get; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Properties" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Properties { System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Net.Http.SocketsHttpHandler.Properties" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Properties { get; }" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.Http.SocketsHttpHandler.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the custom proxy when the <see cref="P:System.Net.Http.SocketsHttpHandler.UseProxy" /> property is <see langword="true" />.</summary>
        <value>The custom proxy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestHeaderEncodingSelector">
      <MemberSignature Language="C#" Value="public System.Net.Http.HeaderEncodingSelector&lt;System.Net.Http.HttpRequestMessage&gt;? RequestHeaderEncodingSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Http.HeaderEncodingSelector`1&lt;class System.Net.Http.HttpRequestMessage&gt; RequestHeaderEncodingSelector" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.RequestHeaderEncodingSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestHeaderEncodingSelector As HeaderEncodingSelector(Of HttpRequestMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Http::HeaderEncodingSelector&lt;System::Net::Http::HttpRequestMessage ^&gt; ^ RequestHeaderEncodingSelector { System::Net::Http::HeaderEncodingSelector&lt;System::Net::Http::HttpRequestMessage ^&gt; ^ get(); void set(System::Net::Http::HeaderEncodingSelector&lt;System::Net::Http::HttpRequestMessage ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestHeaderEncodingSelector : System.Net.Http.HeaderEncodingSelector&lt;System.Net.Http.HttpRequestMessage&gt; with get, set" Usage="System.Net.Http.SocketsHttpHandler.RequestHeaderEncodingSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Http.HeaderEncodingSelector&lt;System.Net.Http.HttpRequestMessage&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a callback that decodes request headers values.</summary>
        <value>The header encoding selector callback to decode the value for the specified response header name, or <see langword="null" /> to indicate the default behavior.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResponseDrainTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan ResponseDrainTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ResponseDrainTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.ResponseDrainTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseDrainTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ResponseDrainTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseDrainTimeout : TimeSpan with get, set" Usage="System.Net.Http.SocketsHttpHandler.ResponseDrainTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the timespan to wait for data to be drained from responses.</summary>
        <value>The timespan to wait for data to be drained from responses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Draining occurs when a request is cancelled or a response is disposed prior to fully reading the content. If the time exceeds the value, the connection will be closed rather than reused.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResponseHeaderEncodingSelector">
      <MemberSignature Language="C#" Value="public System.Net.Http.HeaderEncodingSelector&lt;System.Net.Http.HttpRequestMessage&gt;? ResponseHeaderEncodingSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Http.HeaderEncodingSelector`1&lt;class System.Net.Http.HttpRequestMessage&gt; ResponseHeaderEncodingSelector" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.ResponseHeaderEncodingSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseHeaderEncodingSelector As HeaderEncodingSelector(Of HttpRequestMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Http::HeaderEncodingSelector&lt;System::Net::Http::HttpRequestMessage ^&gt; ^ ResponseHeaderEncodingSelector { System::Net::Http::HeaderEncodingSelector&lt;System::Net::Http::HttpRequestMessage ^&gt; ^ get(); void set(System::Net::Http::HeaderEncodingSelector&lt;System::Net::Http::HttpRequestMessage ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseHeaderEncodingSelector : System.Net.Http.HeaderEncodingSelector&lt;System.Net.Http.HttpRequestMessage&gt; with get, set" Usage="System.Net.Http.SocketsHttpHandler.ResponseHeaderEncodingSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Http.HeaderEncodingSelector&lt;System.Net.Http.HttpRequestMessage&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a callback that decodes response headers values.</summary>
        <value>The header encoding selector callback to decode the value for the specified response header name, or <see langword="null" /> to indicate the default behavior.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="protected internal override System.Net.Http.HttpResponseMessage Send (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Net.Http.HttpResponseMessage Send(class System.Net.Http.HttpRequestMessage request, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.SocketsHttpHandler.Send(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function Send (request As HttpRequestMessage, cancellationToken As CancellationToken) As HttpResponseMessage" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Net::Http::HttpResponseMessage ^ Send(System::Net::Http::HttpRequestMessage ^ request, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.Send : System.Net.Http.HttpRequestMessage * System.Threading.CancellationToken -&gt; System.Net.Http.HttpResponseMessage" Usage="socketsHttpHandler.Send (request, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Http.HttpResponseMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Net.Http.HttpRequestMessage" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="request">The HTTP request message to send.</param>
        <param name="cancellationToken">The cancellation token.</param>
        <summary>Sends an HTTP request.</summary>
        <returns>The HTTP response message.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">For HTTP/2 and higher or when requesting version upgrade is enabled by <see cref="F:System.Net.Http.HttpVersionPolicy.RequestVersionOrHigher" />.

 -or-

 If using custom class derived from <see cref="T:System.Net.Http.HttpContent" /> not overriding <see cref="T:System.Net.Http.SerializeToStream" /> method.

 -or-

 If using custom <see cref="T:System.Net.Http.HttpMessageHandler" /> not overriding <see cref="T:System.Net.Http.HttpMessageHandler.Send" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="protected internal override System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; SendAsync(class System.Net.Http.HttpRequestMessage request, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.SocketsHttpHandler.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SendAsync (request As HttpRequestMessage, cancellationToken As CancellationToken) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ SendAsync(System::Net::Http::HttpRequestMessage ^ request, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.SendAsync : System.Net.Http.HttpRequestMessage * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="socketsHttpHandler.SendAsync (request, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Net.Http.HttpRequestMessage" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="request">The HTTP request message to send.</param>
        <param name="cancellationToken">The cancellation token.</param>
        <summary>Sends an HTTP request as an asynchronous operation.</summary>
        <returns>The task object representing the asynchronous operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SslOptions">
      <MemberSignature Language="C#" Value="public System.Net.Security.SslClientAuthenticationOptions? SslOptions { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.SslClientAuthenticationOptions SslOptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.SslOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property SslOptions As SslClientAuthenticationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::SslClientAuthenticationOptions ^ SslOptions { System::Net::Security::SslClientAuthenticationOptions ^ get(); void set(System::Net::Security::SslClientAuthenticationOptions ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SslOptions : System.Net.Security.SslClientAuthenticationOptions with get, set" Usage="System.Net.Http.SocketsHttpHandler.SslOptions" />
      <MemberSignature Language="C#" Value="public System.Net.Security.SslClientAuthenticationOptions SslOptions { get; set; }" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.SslClientAuthenticationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the set of options used for client TLS authentication.</summary>
        <value>The set of options used for client TLS authentication.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseCookies">
      <MemberSignature Language="C#" Value="public bool UseCookies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseCookies" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.UseCookies" />
      <MemberSignature Language="VB.NET" Value="Public Property UseCookies As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseCookies { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseCookies : bool with get, set" Usage="System.Net.Http.SocketsHttpHandler.UseCookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the handler should use cookies.</summary>
        <value>A value that indicates whether the handler should use cookies.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseProxy">
      <MemberSignature Language="C#" Value="public bool UseProxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseProxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.SocketsHttpHandler.UseProxy" />
      <MemberSignature Language="VB.NET" Value="Public Property UseProxy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseProxy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseProxy : bool with get, set" Usage="System.Net.Http.SocketsHttpHandler.UseProxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the handler should use a proxy.</summary>
        <value>A value that indicates whether the handler should use a proxy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
